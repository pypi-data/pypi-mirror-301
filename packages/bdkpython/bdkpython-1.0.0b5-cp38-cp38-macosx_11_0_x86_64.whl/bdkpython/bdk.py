

# This file was autogenerated by some hot garbage in the `uniffi` crate.
# Trust me, you don't want to mess with it!

# Common helper code.
#
# Ideally this would live in a separate .py file where it can be unittested etc
# in isolation, and perhaps even published as a re-useable package.
#
# However, it's important that the details of how this helper code works (e.g. the
# way that different builtin types are passed across the FFI) exactly match what's
# expected by the rust code on the other side of the interface. In practice right
# now that means coming from the exact some version of `uniffi` that was used to
# compile the rust component. The easiest way to ensure this is to bundle the Python
# helpers directly inline like we're doing here.

from __future__ import annotations
import os
import sys
import ctypes
import enum
import struct
import contextlib
import datetime
import threading
import itertools
import traceback
import typing
import platform
from .bitcoin import Amount
from .bitcoin import FeeRate
from .bitcoin import Network
from .bitcoin import OutPoint
from .bitcoin import Script
from .bitcoin import _UniffiConverterTypeAmount
from .bitcoin import _UniffiConverterTypeFeeRate
from .bitcoin import _UniffiConverterTypeNetwork
from .bitcoin import _UniffiConverterTypeOutPoint
from .bitcoin import _UniffiConverterTypeScript
from .bitcoin import _UniffiRustBuffer as _UniffiRustBufferAmount
from .bitcoin import _UniffiRustBuffer as _UniffiRustBufferFeeRate
from .bitcoin import _UniffiRustBuffer as _UniffiRustBufferNetwork
from .bitcoin import _UniffiRustBuffer as _UniffiRustBufferOutPoint
from .bitcoin import _UniffiRustBuffer as _UniffiRustBufferScript

# Used for default argument values
_DEFAULT = object() # type: typing.Any


class _UniffiRustBuffer(ctypes.Structure):
    _fields_ = [
        ("capacity", ctypes.c_uint64),
        ("len", ctypes.c_uint64),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    @staticmethod
    def default():
        return _UniffiRustBuffer(0, 0, None)

    @staticmethod
    def alloc(size):
        return _uniffi_rust_call(_UniffiLib.ffi_bdkffi_rustbuffer_alloc, size)

    @staticmethod
    def reserve(rbuf, additional):
        return _uniffi_rust_call(_UniffiLib.ffi_bdkffi_rustbuffer_reserve, rbuf, additional)

    def free(self):
        return _uniffi_rust_call(_UniffiLib.ffi_bdkffi_rustbuffer_free, self)

    def __str__(self):
        return "_UniffiRustBuffer(capacity={}, len={}, data={})".format(
            self.capacity,
            self.len,
            self.data[0:self.len]
        )

    @contextlib.contextmanager
    def alloc_with_builder(*args):
        """Context-manger to allocate a buffer using a _UniffiRustBufferBuilder.

        The allocated buffer will be automatically freed if an error occurs, ensuring that
        we don't accidentally leak it.
        """
        builder = _UniffiRustBufferBuilder()
        try:
            yield builder
        except:
            builder.discard()
            raise

    @contextlib.contextmanager
    def consume_with_stream(self):
        """Context-manager to consume a buffer using a _UniffiRustBufferStream.

        The _UniffiRustBuffer will be freed once the context-manager exits, ensuring that we don't
        leak it even if an error occurs.
        """
        try:
            s = _UniffiRustBufferStream.from_rust_buffer(self)
            yield s
            if s.remaining() != 0:
                raise RuntimeError("junk data left in buffer at end of consume_with_stream")
        finally:
            self.free()

    @contextlib.contextmanager
    def read_with_stream(self):
        """Context-manager to read a buffer using a _UniffiRustBufferStream.

        This is like consume_with_stream, but doesn't free the buffer afterwards.
        It should only be used with borrowed `_UniffiRustBuffer` data.
        """
        s = _UniffiRustBufferStream.from_rust_buffer(self)
        yield s
        if s.remaining() != 0:
            raise RuntimeError("junk data left in buffer at end of read_with_stream")

class _UniffiForeignBytes(ctypes.Structure):
    _fields_ = [
        ("len", ctypes.c_int32),
        ("data", ctypes.POINTER(ctypes.c_char)),
    ]

    def __str__(self):
        return "_UniffiForeignBytes(len={}, data={})".format(self.len, self.data[0:self.len])


class _UniffiRustBufferStream:
    """
    Helper for structured reading of bytes from a _UniffiRustBuffer
    """

    def __init__(self, data, len):
        self.data = data
        self.len = len
        self.offset = 0

    @classmethod
    def from_rust_buffer(cls, buf):
        return cls(buf.data, buf.len)

    def remaining(self):
        return self.len - self.offset

    def _unpack_from(self, size, format):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        value = struct.unpack(format, self.data[self.offset:self.offset+size])[0]
        self.offset += size
        return value

    def read(self, size):
        if self.offset + size > self.len:
            raise InternalError("read past end of rust buffer")
        data = self.data[self.offset:self.offset+size]
        self.offset += size
        return data

    def read_i8(self):
        return self._unpack_from(1, ">b")

    def read_u8(self):
        return self._unpack_from(1, ">B")

    def read_i16(self):
        return self._unpack_from(2, ">h")

    def read_u16(self):
        return self._unpack_from(2, ">H")

    def read_i32(self):
        return self._unpack_from(4, ">i")

    def read_u32(self):
        return self._unpack_from(4, ">I")

    def read_i64(self):
        return self._unpack_from(8, ">q")

    def read_u64(self):
        return self._unpack_from(8, ">Q")

    def read_float(self):
        v = self._unpack_from(4, ">f")
        return v

    def read_double(self):
        return self._unpack_from(8, ">d")

class _UniffiRustBufferBuilder:
    """
    Helper for structured writing of bytes into a _UniffiRustBuffer.
    """

    def __init__(self):
        self.rbuf = _UniffiRustBuffer.alloc(16)
        self.rbuf.len = 0

    def finalize(self):
        rbuf = self.rbuf
        self.rbuf = None
        return rbuf

    def discard(self):
        if self.rbuf is not None:
            rbuf = self.finalize()
            rbuf.free()

    @contextlib.contextmanager
    def _reserve(self, num_bytes):
        if self.rbuf.len + num_bytes > self.rbuf.capacity:
            self.rbuf = _UniffiRustBuffer.reserve(self.rbuf, num_bytes)
        yield None
        self.rbuf.len += num_bytes

    def _pack_into(self, size, format, value):
        with self._reserve(size):
            # XXX TODO: I feel like I should be able to use `struct.pack_into` here but can't figure it out.
            for i, byte in enumerate(struct.pack(format, value)):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write(self, value):
        with self._reserve(len(value)):
            for i, byte in enumerate(value):
                self.rbuf.data[self.rbuf.len + i] = byte

    def write_i8(self, v):
        self._pack_into(1, ">b", v)

    def write_u8(self, v):
        self._pack_into(1, ">B", v)

    def write_i16(self, v):
        self._pack_into(2, ">h", v)

    def write_u16(self, v):
        self._pack_into(2, ">H", v)

    def write_i32(self, v):
        self._pack_into(4, ">i", v)

    def write_u32(self, v):
        self._pack_into(4, ">I", v)

    def write_i64(self, v):
        self._pack_into(8, ">q", v)

    def write_u64(self, v):
        self._pack_into(8, ">Q", v)

    def write_float(self, v):
        self._pack_into(4, ">f", v)

    def write_double(self, v):
        self._pack_into(8, ">d", v)

    def write_c_size_t(self, v):
        self._pack_into(ctypes.sizeof(ctypes.c_size_t) , "@N", v)
# A handful of classes and functions to support the generated data structures.
# This would be a good candidate for isolating in its own ffi-support lib.

class InternalError(Exception):
    pass

class _UniffiRustCallStatus(ctypes.Structure):
    """
    Error runtime.
    """
    _fields_ = [
        ("code", ctypes.c_int8),
        ("error_buf", _UniffiRustBuffer),
    ]

    # These match the values from the uniffi::rustcalls module
    CALL_SUCCESS = 0
    CALL_ERROR = 1
    CALL_UNEXPECTED_ERROR = 2

    @staticmethod
    def default():
        return _UniffiRustCallStatus(code=_UniffiRustCallStatus.CALL_SUCCESS, error_buf=_UniffiRustBuffer.default())

    def __str__(self):
        if self.code == _UniffiRustCallStatus.CALL_SUCCESS:
            return "_UniffiRustCallStatus(CALL_SUCCESS)"
        elif self.code == _UniffiRustCallStatus.CALL_ERROR:
            return "_UniffiRustCallStatus(CALL_ERROR)"
        elif self.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
            return "_UniffiRustCallStatus(CALL_UNEXPECTED_ERROR)"
        else:
            return "_UniffiRustCallStatus(<invalid code>)"

def _uniffi_rust_call(fn, *args):
    # Call a rust function
    return _uniffi_rust_call_with_error(None, fn, *args)

def _uniffi_rust_call_with_error(error_ffi_converter, fn, *args):
    # Call a rust function and handle any errors
    #
    # This function is used for rust calls that return Result<> and therefore can set the CALL_ERROR status code.
    # error_ffi_converter must be set to the _UniffiConverter for the error class that corresponds to the result.
    call_status = _UniffiRustCallStatus.default()

    args_with_error = args + (ctypes.byref(call_status),)
    result = fn(*args_with_error)
    _uniffi_check_call_status(error_ffi_converter, call_status)
    return result

def _uniffi_check_call_status(error_ffi_converter, call_status):
    if call_status.code == _UniffiRustCallStatus.CALL_SUCCESS:
        pass
    elif call_status.code == _UniffiRustCallStatus.CALL_ERROR:
        if error_ffi_converter is None:
            call_status.error_buf.free()
            raise InternalError("_uniffi_rust_call_with_error: CALL_ERROR, but error_ffi_converter is None")
        else:
            raise error_ffi_converter.lift(call_status.error_buf)
    elif call_status.code == _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR:
        # When the rust code sees a panic, it tries to construct a _UniffiRustBuffer
        # with the message.  But if that code panics, then it just sends back
        # an empty buffer.
        if call_status.error_buf.len > 0:
            msg = _UniffiConverterString.lift(call_status.error_buf)
        else:
            msg = "Unknown rust panic"
        raise InternalError(msg)
    else:
        raise InternalError("Invalid _UniffiRustCallStatus code: {}".format(
            call_status.code))

def _uniffi_trait_interface_call(call_status, make_call, write_return_value):
    try:
        return write_return_value(make_call())
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))

def _uniffi_trait_interface_call_with_error(call_status, make_call, write_return_value, error_type, lower_error):
    try:
        try:
            return write_return_value(make_call())
        except error_type as e:
            call_status.code = _UniffiRustCallStatus.CALL_ERROR
            call_status.error_buf = lower_error(e)
    except Exception as e:
        call_status.code = _UniffiRustCallStatus.CALL_UNEXPECTED_ERROR
        call_status.error_buf = _UniffiConverterString.lower(repr(e))
class _UniffiHandleMap:
    """
    A map where inserting, getting and removing data is synchronized with a lock.
    """

    def __init__(self):
        # type Handle = int
        self._map = {}  # type: Dict[Handle, Any]
        self._lock = threading.Lock()
        self._counter = itertools.count()

    def insert(self, obj):
        with self._lock:
            handle = next(self._counter)
            self._map[handle] = obj
            return handle

    def get(self, handle):
        try:
            with self._lock:
                return self._map[handle]
        except KeyError:
            raise InternalError("_UniffiHandleMap.get: Invalid handle")

    def remove(self, handle):
        try:
            with self._lock:
                return self._map.pop(handle)
        except KeyError:
            raise InternalError("_UniffiHandleMap.remove: Invalid handle")

    def __len__(self):
        return len(self._map)
# Types conforming to `_UniffiConverterPrimitive` pass themselves directly over the FFI.
class _UniffiConverterPrimitive:
    @classmethod
    def lift(cls, value):
        return value

    @classmethod
    def lower(cls, value):
        return value

class _UniffiConverterPrimitiveInt(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__index__()
        except Exception:
            raise TypeError("'{}' object cannot be interpreted as an integer".format(type(value).__name__))
        if not isinstance(value, int):
            raise TypeError("__index__ returned non-int (type {})".format(type(value).__name__))
        if not cls.VALUE_MIN <= value < cls.VALUE_MAX:
            raise ValueError("{} requires {} <= value < {}".format(cls.CLASS_NAME, cls.VALUE_MIN, cls.VALUE_MAX))

class _UniffiConverterPrimitiveFloat(_UniffiConverterPrimitive):
    @classmethod
    def check_lower(cls, value):
        try:
            value = value.__float__()
        except Exception:
            raise TypeError("must be real number, not {}".format(type(value).__name__))
        if not isinstance(value, float):
            raise TypeError("__float__ returned non-float (type {})".format(type(value).__name__))

# Helper class for wrapper types that will always go through a _UniffiRustBuffer.
# Classes should inherit from this and implement the `read` and `write` static methods.
class _UniffiConverterRustBuffer:
    @classmethod
    def lift(cls, rbuf):
        with rbuf.consume_with_stream() as stream:
            return cls.read(stream)

    @classmethod
    def lower(cls, value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            cls.write(value, builder)
            return builder.finalize()

# Contains loading, initialization code, and the FFI Function declarations.
# Define some ctypes FFI types that we use in the library

"""
Function pointer for a Rust task, which a callback function that takes a opaque pointer
"""
_UNIFFI_RUST_TASK = ctypes.CFUNCTYPE(None, ctypes.c_void_p, ctypes.c_int8)

def _uniffi_future_callback_t(return_type):
    """
    Factory function to create callback function types for async functions
    """
    return ctypes.CFUNCTYPE(None, ctypes.c_uint64, return_type, _UniffiRustCallStatus)

def _uniffi_load_indirect():
    """
    This is how we find and load the dynamic library provided by the component.
    For now we just look it up by name.
    """
    if sys.platform == "darwin":
        libname = "lib{}.dylib"
    elif sys.platform.startswith("win"):
        # As of python3.8, ctypes does not seem to search $PATH when loading DLLs.
        # We could use `os.add_dll_directory` to configure the search path, but
        # it doesn't feel right to mess with application-wide settings. Let's
        # assume that the `.dll` is next to the `.py` file and load by full path.
        libname = os.path.join(
            os.path.dirname(__file__),
            "{}.dll",
        )
    else:
        # Anything else must be an ELF platform - Linux, *BSD, Solaris/illumos
        libname = "lib{}.so"

    libname = libname.format("bdkffi")
    path = os.path.join(os.path.dirname(__file__), libname)
    lib = ctypes.cdll.LoadLibrary(path)
    return lib

def _uniffi_check_contract_api_version(lib):
    # Get the bindings contract version from our ComponentInterface
    bindings_contract_version = 26
    # Get the scaffolding contract version by calling the into the dylib
    scaffolding_contract_version = lib.ffi_bdkffi_uniffi_contract_version()
    if bindings_contract_version != scaffolding_contract_version:
        raise InternalError("UniFFI contract version mismatch: try cleaning and rebuilding your project")

def _uniffi_check_api_checksums(lib):
    if lib.uniffi_bdkffi_checksum_method_address_is_valid_for_network() != 2364:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_script_pubkey() != 5809:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_address_to_qr_uri() != 48141:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish() != 18299:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_set_exact_sequence() != 35609:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptor_to_string_with_secret() != 18986:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorpublickey_as_string() != 37256:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorpublickey_derive() != 42652:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorpublickey_extend() != 46128:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public() != 56954:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string() != 28335:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_derive() != 61335:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_extend() != 19969:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes() != 40876:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_electrumclient_broadcast() != 47170:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_electrumclient_full_scan() != 63481:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_electrumclient_sync() != 23534:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_esploraclient_broadcast() != 21200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_esploraclient_full_scan() != 30443:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_esploraclient_get_tx() != 59770:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_esploraclient_sync() != 39911:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_fullscanrequestbuilder_build() != 56245:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_fullscanrequestbuilder_inspect_spks_for_all_keychains() != 6853:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_fullscanscriptinspector_inspect() != 62348:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_psbt_combine() != 42218:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_psbt_extract_tx() != 60519:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_psbt_fee() != 48877:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_psbt_json_serialize() != 9611:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_psbt_serialize() != 33309:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_syncrequestbuilder_build() != 38954:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_syncrequestbuilder_inspect_spks() != 33029:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_syncscriptinspector_inspect() != 32429:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_compute_txid() != 46504:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_input() != 5374:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_is_coinbase() != 14454:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf() != 32682:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled() != 48885:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_lock_time() != 49321:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_output() != 30237:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_serialize() != 62862:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_total_size() != 12759:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_version() != 15271:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_vsize() != 3804:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_transaction_weight() != 21879:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_global_xpubs() != 61114:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_recipient() != 20490:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_unspendable() != 14416:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_add_utxo() != 14001:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_change_policy() != 22333:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change() != 51770:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_drain_to() != 29829:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_drain_wallet() != 5081:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_fee_absolute() != 28626:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_fee_rate() != 49200:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_finish() != 61082:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only() != 12623:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_only_spend_change() != 18757:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_set_exact_sequence() != 35105:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_set_recipients() != 20461:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_txbuilder_unspendable() != 49896:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_apply_update() != 65428:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_balance() != 32173:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_calculate_fee() != 39344:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_calculate_fee_rate() != 23373:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_cancel_tx() != 27219:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_derivation_index() != 63084:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_derivation_of_spk() != 3430:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_descriptor_checksum() != 60436:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_finalize_psbt() != 44900:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_get_tx() != 59450:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_get_utxo() != 3914:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_is_mine() != 36368:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_list_output() != 27359:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_list_unspent() != 25643:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_list_unused_addresses() != 1695:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_mark_used() != 51163:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_network() != 21775:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_next_derivation_index() != 47127:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_next_unused_address() != 18644:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_peek_address() != 47647:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_persist() != 14909:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_reveal_addresses_to() != 10653:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_reveal_next_address() != 54031:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_sent_and_received() != 15077:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_sign() != 15606:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_start_full_scan() != 3023:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_start_sync_with_revealed_spks() != 41977:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_method_wallet_transactions() != 37950:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_address_from_script() != 28697:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_address_new() != 42937:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new() != 33618:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_connection_new() != 59352:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_connection_new_in_memory() != 31408:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_derivationpath_new() != 6139:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new() != 64471:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44() != 56381:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public() != 7263:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49() != 38651:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public() != 34965:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84() != 48402:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public() != 13927:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86() != 30427:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public() != 14236:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string() != 34928:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string() != 56519:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new() != 29746:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_electrumclient_new() != 10238:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_esploraclient_new() != 19298:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy() != 16992:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_mnemonic_from_string() != 56187:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_mnemonic_new() != 51578:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_psbt_new() != 33069:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_transaction_new() != 58769:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_txbuilder_new() != 6280:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_wallet_load() != 21717:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")
    if lib.uniffi_bdkffi_checksum_constructor_wallet_new() != 51039:
        raise InternalError("UniFFI API checksum mismatch: try cleaning and rebuilding your project")

# A ctypes library to expose the extern-C FFI definitions.
# This is an implementation detail which will be called internally by the public API.

_UniffiLib = _uniffi_load_indirect()
_UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_int8,
)
_UNIFFI_FOREIGN_FUTURE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
_UNIFFI_CALLBACK_INTERFACE_FREE = ctypes.CFUNCTYPE(None,ctypes.c_uint64,
)
class _UniffiForeignFuture(ctypes.Structure):
    _fields_ = [
        ("handle", ctypes.c_uint64),
        ("free", _UNIFFI_FOREIGN_FUTURE_FREE),
    ]
class _UniffiForeignFutureStructU8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU8,
)
class _UniffiForeignFutureStructI8(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int8),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I8 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI8,
)
class _UniffiForeignFutureStructU16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU16,
)
class _UniffiForeignFutureStructI16(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int16),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I16 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI16,
)
class _UniffiForeignFutureStructU32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU32,
)
class _UniffiForeignFutureStructI32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int32),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI32,
)
class _UniffiForeignFutureStructU64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_uint64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_U64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructU64,
)
class _UniffiForeignFutureStructI64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_int64),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_I64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructI64,
)
class _UniffiForeignFutureStructF32(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_float),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F32 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF32,
)
class _UniffiForeignFutureStructF64(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_double),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_F64 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructF64,
)
class _UniffiForeignFutureStructPointer(ctypes.Structure):
    _fields_ = [
        ("return_value", ctypes.c_void_p),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_POINTER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructPointer,
)
class _UniffiForeignFutureStructRustBuffer(ctypes.Structure):
    _fields_ = [
        ("return_value", _UniffiRustBuffer),
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_RUST_BUFFER = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructRustBuffer,
)
class _UniffiForeignFutureStructVoid(ctypes.Structure):
    _fields_ = [
        ("call_status", _UniffiRustCallStatus),
    ]
_UNIFFI_FOREIGN_FUTURE_COMPLETE_VOID = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiForeignFutureStructVoid,
)
_UNIFFI_CALLBACK_INTERFACE_FULL_SCAN_SCRIPT_INSPECTOR_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,_UniffiRustBuffer,ctypes.c_uint32,ctypes.c_void_p,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UNIFFI_CALLBACK_INTERFACE_SYNC_SCRIPT_INSPECTOR_METHOD0 = ctypes.CFUNCTYPE(None,ctypes.c_uint64,ctypes.c_void_p,ctypes.c_uint64,ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
class _UniffiVTableCallbackInterfaceFullScanScriptInspector(ctypes.Structure):
    _fields_ = [
        ("inspect", _UNIFFI_CALLBACK_INTERFACE_FULL_SCAN_SCRIPT_INSPECTOR_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
class _UniffiVTableCallbackInterfaceSyncScriptInspector(ctypes.Structure):
    _fields_ = [
        ("inspect", _UNIFFI_CALLBACK_INTERFACE_SYNC_SCRIPT_INSPECTOR_METHOD0),
        ("uniffi_free", _UNIFFI_CALLBACK_INTERFACE_FREE),
    ]
_UniffiLib.uniffi_bdkffi_fn_clone_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_address.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_address.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_address.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_address_from_script.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_address_from_script.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_address_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_address_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_address_is_valid_for_network.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_is_valid_for_network.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_address_script_pubkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_script_pubkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_address_to_qr_uri.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_to_qr_uri.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_address_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_address_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_bumpfeetxbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_bumpfeetxbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_bumpfeetxbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_bumpfeetxbuilder.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_set_exact_sequence.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_set_exact_sequence.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_changeset.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_changeset.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_changeset.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_changeset.restype = None
_UniffiLib.uniffi_bdkffi_fn_clone_connection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_connection.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_connection.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_connection.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_connection_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_connection_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_connection_new_in_memory.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_connection_new_in_memory.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_derivationpath.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_derivationpath.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_derivationpath.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_derivationpath.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_derivationpath_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_derivationpath_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_descriptor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_descriptor.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_descriptor.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_descriptor.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new.argtypes = (
    _UniffiRustBuffer,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    _UniffiRustBuffer,
    _UniffiRustBufferNetwork,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_to_string_with_secret.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_to_string_with_secret.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptor_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorpublickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorpublickey.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_descriptorpublickey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_descriptorpublickey.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_derive.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_derive.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_extend.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_extend.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorsecretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_descriptorsecretkey.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_descriptorsecretkey.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_descriptorsecretkey.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_new.argtypes = (
    _UniffiRustBufferNetwork,
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_public.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_public.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_string.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_string.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_derive.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_derive.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_extend.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_extend.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_electrumclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_electrumclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_electrumclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_electrumclient.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_electrumclient_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_electrumclient_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_broadcast.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_broadcast.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_full_scan.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_full_scan.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_sync.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_int8,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_sync.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_esploraclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_esploraclient.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_esploraclient.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_esploraclient.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_esploraclient_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_esploraclient_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_broadcast.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_broadcast.restype = None
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_full_scan.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_full_scan.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_get_tx.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_get_tx.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_sync.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_sync.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_fullscanrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_fullscanrequest.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_fullscanrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_fullscanrequest.restype = None
_UniffiLib.uniffi_bdkffi_fn_clone_fullscanrequestbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_fullscanrequestbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_fullscanrequestbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_fullscanrequestbuilder.restype = None
_UniffiLib.uniffi_bdkffi_fn_method_fullscanrequestbuilder_build.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_fullscanrequestbuilder_build.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_fullscanrequestbuilder_inspect_spks_for_all_keychains.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_fullscanrequestbuilder_inspect_spks_for_all_keychains.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_fullscanscriptinspector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_fullscanscriptinspector.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_fullscanscriptinspector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_fullscanscriptinspector.restype = None
_UniffiLib.uniffi_bdkffi_fn_init_callback_vtable_fullscanscriptinspector.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceFullScanScriptInspector),
)
_UniffiLib.uniffi_bdkffi_fn_init_callback_vtable_fullscanscriptinspector.restype = None
_UniffiLib.uniffi_bdkffi_fn_method_fullscanscriptinspector_inspect.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_fullscanscriptinspector_inspect.restype = None
_UniffiLib.uniffi_bdkffi_fn_clone_mnemonic.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_mnemonic.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_mnemonic.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_mnemonic.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_entropy.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_entropy.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_string.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_string.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_mnemonic_uniffi_trait_display.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_mnemonic_uniffi_trait_display.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_psbt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_psbt.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_psbt.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_psbt.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_psbt_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_psbt_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_psbt_combine.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_psbt_combine.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_psbt_extract_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_psbt_extract_tx.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_psbt_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_psbt_fee.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_method_psbt_json_serialize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_psbt_json_serialize.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_psbt_serialize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_psbt_serialize.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_clone_syncrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_syncrequest.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_syncrequest.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_syncrequest.restype = None
_UniffiLib.uniffi_bdkffi_fn_clone_syncrequestbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_syncrequestbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_syncrequestbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_syncrequestbuilder.restype = None
_UniffiLib.uniffi_bdkffi_fn_method_syncrequestbuilder_build.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_syncrequestbuilder_build.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_syncrequestbuilder_inspect_spks.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_syncrequestbuilder_inspect_spks.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_syncscriptinspector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_syncscriptinspector.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_syncscriptinspector.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_syncscriptinspector.restype = None
_UniffiLib.uniffi_bdkffi_fn_init_callback_vtable_syncscriptinspector.argtypes = (
    ctypes.POINTER(_UniffiVTableCallbackInterfaceSyncScriptInspector),
)
_UniffiLib.uniffi_bdkffi_fn_init_callback_vtable_syncscriptinspector.restype = None
_UniffiLib.uniffi_bdkffi_fn_method_syncscriptinspector_inspect.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_syncscriptinspector_inspect.restype = None
_UniffiLib.uniffi_bdkffi_fn_clone_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_transaction.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_transaction.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_transaction.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_transaction_new.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_transaction_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_transaction_compute_txid.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_compute_txid.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_input.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_input.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_coinbase.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_coinbase.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_transaction_lock_time.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_lock_time.restype = ctypes.c_uint32
_UniffiLib.uniffi_bdkffi_fn_method_transaction_output.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_output.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_serialize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_serialize.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_transaction_total_size.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_total_size.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_method_transaction_version.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_version.restype = ctypes.c_int32
_UniffiLib.uniffi_bdkffi_fn_method_transaction_vsize.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_vsize.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_method_transaction_weight.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_transaction_weight.restype = ctypes.c_uint64
_UniffiLib.uniffi_bdkffi_fn_clone_txbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_txbuilder.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_txbuilder.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_txbuilder.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_txbuilder_new.argtypes = (
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_txbuilder_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_global_xpubs.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_global_xpubs.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_recipient.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_recipient.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_unspendable.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferOutPoint,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_unspendable.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxo.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferOutPoint,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxo.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_change_policy.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_change_policy.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_to.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_to.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_wallet.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_wallet.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_absolute.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_absolute.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_rate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_rate.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_finish.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_finish.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_manually_selected_only.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_manually_selected_only.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_only_spend_change.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_only_spend_change.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_exact_sequence.argtypes = (
    ctypes.c_void_p,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_exact_sequence.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_recipients.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_recipients.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_unspendable.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_unspendable.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_clone_update.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_update.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_update.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_update.restype = None
_UniffiLib.uniffi_bdkffi_fn_clone_wallet.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_clone_wallet.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_free_wallet.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_free_wallet.restype = None
_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_load.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_load.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    _UniffiRustBufferNetwork,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_wallet_apply_update.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_apply_update.restype = None
_UniffiLib.uniffi_bdkffi_fn_method_wallet_balance.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_balance.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee_rate.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee_rate.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_wallet_cancel_tx.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_cancel_tx.restype = None
_UniffiLib.uniffi_bdkffi_fn_method_wallet_derivation_index.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_derivation_index.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_derivation_of_spk.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_derivation_of_spk.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_descriptor_checksum.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_descriptor_checksum.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_finalize_psbt.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_finalize_psbt.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_tx.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_tx.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_utxo.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBufferOutPoint,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_utxo.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_is_mine.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_is_mine.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_output.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_output.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unspent.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unspent.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unused_addresses.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unused_addresses.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_mark_used.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_mark_used.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_wallet_network.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_network.restype = _UniffiRustBufferNetwork
_UniffiLib.uniffi_bdkffi_fn_method_wallet_next_derivation_index.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_next_derivation_index.restype = ctypes.c_uint32
_UniffiLib.uniffi_bdkffi_fn_method_wallet_next_unused_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_next_unused_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_peek_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_peek_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_persist.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_persist.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_wallet_reveal_addresses_to.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.c_uint32,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_reveal_addresses_to.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_reveal_next_address.argtypes = (
    ctypes.c_void_p,
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_reveal_next_address.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sent_and_received.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sent_and_received.restype = _UniffiRustBuffer
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sign.argtypes = (
    ctypes.c_void_p,
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_sign.restype = ctypes.c_int8
_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_full_scan.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_full_scan.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_sync_with_revealed_spks.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_sync_with_revealed_spks.restype = ctypes.c_void_p
_UniffiLib.uniffi_bdkffi_fn_method_wallet_transactions.argtypes = (
    ctypes.c_void_p,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.uniffi_bdkffi_fn_method_wallet_transactions.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rustbuffer_alloc.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_alloc.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rustbuffer_from_bytes.argtypes = (
    _UniffiForeignBytes,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_from_bytes.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rustbuffer_free.argtypes = (
    _UniffiRustBuffer,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_free.restype = None
_UniffiLib.ffi_bdkffi_rustbuffer_reserve.argtypes = (
    _UniffiRustBuffer,
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rustbuffer_reserve.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rust_future_poll_u8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u8.restype = ctypes.c_uint8
_UniffiLib.ffi_bdkffi_rust_future_poll_i8.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i8.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i8.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i8.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i8.restype = ctypes.c_int8
_UniffiLib.ffi_bdkffi_rust_future_poll_u16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u16.restype = ctypes.c_uint16
_UniffiLib.ffi_bdkffi_rust_future_poll_i16.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i16.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i16.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i16.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i16.restype = ctypes.c_int16
_UniffiLib.ffi_bdkffi_rust_future_poll_u32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u32.restype = ctypes.c_uint32
_UniffiLib.ffi_bdkffi_rust_future_poll_i32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i32.restype = ctypes.c_int32
_UniffiLib.ffi_bdkffi_rust_future_poll_u64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_u64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_u64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_u64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_u64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_u64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_u64.restype = ctypes.c_uint64
_UniffiLib.ffi_bdkffi_rust_future_poll_i64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_i64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_i64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_i64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_i64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_i64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_i64.restype = ctypes.c_int64
_UniffiLib.ffi_bdkffi_rust_future_poll_f32.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_f32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_f32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_f32.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_f32.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_f32.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_f32.restype = ctypes.c_float
_UniffiLib.ffi_bdkffi_rust_future_poll_f64.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_f64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_f64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_f64.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_f64.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_f64.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_f64.restype = ctypes.c_double
_UniffiLib.ffi_bdkffi_rust_future_poll_pointer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_pointer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_pointer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_pointer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_pointer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_pointer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_pointer.restype = ctypes.c_void_p
_UniffiLib.ffi_bdkffi_rust_future_poll_rust_buffer.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_rust_buffer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_rust_buffer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_rust_buffer.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_rust_buffer.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_rust_buffer.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_rust_buffer.restype = _UniffiRustBuffer
_UniffiLib.ffi_bdkffi_rust_future_poll_void.argtypes = (
    ctypes.c_uint64,
    _UNIFFI_RUST_FUTURE_CONTINUATION_CALLBACK,
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_poll_void.restype = None
_UniffiLib.ffi_bdkffi_rust_future_cancel_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_cancel_void.restype = None
_UniffiLib.ffi_bdkffi_rust_future_free_void.argtypes = (
    ctypes.c_uint64,
)
_UniffiLib.ffi_bdkffi_rust_future_free_void.restype = None
_UniffiLib.ffi_bdkffi_rust_future_complete_void.argtypes = (
    ctypes.c_uint64,
    ctypes.POINTER(_UniffiRustCallStatus),
)
_UniffiLib.ffi_bdkffi_rust_future_complete_void.restype = None
_UniffiLib.uniffi_bdkffi_checksum_method_address_is_valid_for_network.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_is_valid_for_network.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_script_pubkey.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_script_pubkey.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_address_to_qr_uri.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_address_to_qr_uri.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_set_exact_sequence.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_bumpfeetxbuilder_set_exact_sequence.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptor_to_string_with_secret.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptor_to_string_with_secret.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_derive.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_derive.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_extend.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorpublickey_extend.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_as_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_derive.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_derive.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_extend.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_extend.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_descriptorsecretkey_secret_bytes.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_broadcast.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_broadcast.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_full_scan.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_full_scan.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_sync.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_electrumclient_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_broadcast.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_broadcast.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_full_scan.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_full_scan.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_get_tx.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_get_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_sync.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_esploraclient_sync.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_fullscanrequestbuilder_build.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_fullscanrequestbuilder_build.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_fullscanrequestbuilder_inspect_spks_for_all_keychains.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_fullscanrequestbuilder_inspect_spks_for_all_keychains.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_fullscanscriptinspector_inspect.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_fullscanscriptinspector_inspect.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_combine.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_combine.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_extract_tx.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_extract_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_fee.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_json_serialize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_json_serialize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_serialize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_psbt_serialize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_syncrequestbuilder_build.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_syncrequestbuilder_build.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_syncrequestbuilder_inspect_spks.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_syncrequestbuilder_inspect_spks.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_syncscriptinspector_inspect.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_syncscriptinspector_inspect.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_compute_txid.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_compute_txid.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_input.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_input.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_coinbase.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_coinbase.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_explicitly_rbf.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_is_lock_time_enabled.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_lock_time.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_lock_time.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_output.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_output.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_serialize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_serialize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_total_size.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_total_size.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_version.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_version.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_vsize.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_vsize.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_weight.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_transaction_weight.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_global_xpubs.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_global_xpubs.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_recipient.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_recipient.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_unspendable.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_unspendable.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_utxo.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_add_utxo.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_change_policy.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_change_policy.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_do_not_spend_change.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_to.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_wallet.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_drain_wallet.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_absolute.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_absolute.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_rate.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_fee_rate.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_finish.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_finish.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_manually_selected_only.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_only_spend_change.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_only_spend_change.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_set_exact_sequence.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_set_exact_sequence.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_set_recipients.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_set_recipients.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_unspendable.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_txbuilder_unspendable.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_apply_update.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_apply_update.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_balance.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_balance.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_calculate_fee.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_calculate_fee.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_calculate_fee_rate.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_calculate_fee_rate.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_cancel_tx.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_cancel_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_derivation_index.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_derivation_index.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_derivation_of_spk.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_derivation_of_spk.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_descriptor_checksum.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_descriptor_checksum.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_finalize_psbt.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_finalize_psbt.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_tx.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_tx.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_utxo.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_get_utxo.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_is_mine.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_is_mine.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_output.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_output.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_unspent.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_unspent.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_unused_addresses.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_list_unused_addresses.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_mark_used.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_mark_used.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_network.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_network.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_next_derivation_index.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_next_derivation_index.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_next_unused_address.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_next_unused_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_peek_address.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_peek_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_persist.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_persist.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_reveal_addresses_to.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_reveal_addresses_to.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_reveal_next_address.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_reveal_next_address.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sent_and_received.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sent_and_received.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sign.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_sign.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_start_full_scan.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_start_full_scan.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_start_sync_with_revealed_spks.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_start_sync_with_revealed_spks.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_transactions.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_method_wallet_transactions.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_address_from_script.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_address_from_script.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_address_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_address_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_bumpfeetxbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_connection_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_connection_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_connection_new_in_memory.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_connection_new_in_memory.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_derivationpath_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_derivationpath_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip44_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip49_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip84_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptor_new_bip86_public.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorpublickey_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_descriptorsecretkey_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_electrumclient_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_electrumclient_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_esploraclient_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_esploraclient_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_entropy.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_string.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_from_string.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_mnemonic_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_psbt_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_psbt_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_transaction_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_transaction_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_txbuilder_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_txbuilder_new.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_wallet_load.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_wallet_load.restype = ctypes.c_uint16
_UniffiLib.uniffi_bdkffi_checksum_constructor_wallet_new.argtypes = (
)
_UniffiLib.uniffi_bdkffi_checksum_constructor_wallet_new.restype = ctypes.c_uint16
_UniffiLib.ffi_bdkffi_uniffi_contract_version.argtypes = (
)
_UniffiLib.ffi_bdkffi_uniffi_contract_version.restype = ctypes.c_uint32

_uniffi_check_contract_api_version(_UniffiLib)
_uniffi_check_api_checksums(_UniffiLib)

# Public interface members begin here.


class _UniffiConverterUInt8(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u8"
    VALUE_MIN = 0
    VALUE_MAX = 2**8

    @staticmethod
    def read(buf):
        return buf.read_u8()

    @staticmethod
    def write(value, buf):
        buf.write_u8(value)

class _UniffiConverterUInt16(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u16"
    VALUE_MIN = 0
    VALUE_MAX = 2**16

    @staticmethod
    def read(buf):
        return buf.read_u16()

    @staticmethod
    def write(value, buf):
        buf.write_u16(value)

class _UniffiConverterUInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u32"
    VALUE_MIN = 0
    VALUE_MAX = 2**32

    @staticmethod
    def read(buf):
        return buf.read_u32()

    @staticmethod
    def write(value, buf):
        buf.write_u32(value)

class _UniffiConverterInt32(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "i32"
    VALUE_MIN = -2**31
    VALUE_MAX = 2**31

    @staticmethod
    def read(buf):
        return buf.read_i32()

    @staticmethod
    def write(value, buf):
        buf.write_i32(value)

class _UniffiConverterUInt64(_UniffiConverterPrimitiveInt):
    CLASS_NAME = "u64"
    VALUE_MIN = 0
    VALUE_MAX = 2**64

    @staticmethod
    def read(buf):
        return buf.read_u64()

    @staticmethod
    def write(value, buf):
        buf.write_u64(value)

class _UniffiConverterBool:
    @classmethod
    def check_lower(cls, value):
        return not not value

    @classmethod
    def lower(cls, value):
        return 1 if value else 0

    @staticmethod
    def lift(value):
        return value != 0

    @classmethod
    def read(cls, buf):
        return cls.lift(buf.read_u8())

    @classmethod
    def write(cls, value, buf):
        buf.write_u8(value)

class _UniffiConverterString:
    @staticmethod
    def check_lower(value):
        if not isinstance(value, str):
            raise TypeError("argument must be str, not {}".format(type(value).__name__))
        return value

    @staticmethod
    def read(buf):
        size = buf.read_i32()
        if size < 0:
            raise InternalError("Unexpected negative string length")
        utf8_bytes = buf.read(size)
        return utf8_bytes.decode("utf-8")

    @staticmethod
    def write(value, buf):
        utf8_bytes = value.encode("utf-8")
        buf.write_i32(len(utf8_bytes))
        buf.write(utf8_bytes)

    @staticmethod
    def lift(buf):
        with buf.consume_with_stream() as stream:
            return stream.read(stream.remaining()).decode("utf-8")

    @staticmethod
    def lower(value):
        with _UniffiRustBuffer.alloc_with_builder() as builder:
            builder.write(value.encode("utf-8"))
            return builder.finalize()



class AddressProtocol(typing.Protocol):
    def is_valid_for_network(self, network: "Network"):
        raise NotImplementedError
    def script_pubkey(self, ):
        raise NotImplementedError
    def to_qr_uri(self, ):
        raise NotImplementedError


class Address:
    _pointer: ctypes.c_void_p
    def __init__(self, address: "str",network: "Network"):
        _UniffiConverterString.check_lower(address)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeAddressParseError,_UniffiLib.uniffi_bdkffi_fn_constructor_address_new,
        _UniffiConverterString.lower(address),
        _UniffiConverterTypeNetwork.lower(network))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_address, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_address, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_script(cls, script: "Script",network: "Network"):
        _UniffiConverterTypeScript.check_lower(script)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeFromScriptError,_UniffiLib.uniffi_bdkffi_fn_constructor_address_from_script,
        _UniffiConverterTypeScript.lower(script),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)



    def is_valid_for_network(self, network: "Network") -> "bool":
        _UniffiConverterTypeNetwork.check_lower(network)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_is_valid_for_network,self._uniffi_clone_pointer(),
        _UniffiConverterTypeNetwork.lower(network))
        )





    def script_pubkey(self, ) -> "Script":
        return _UniffiConverterTypeScript.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_script_pubkey,self._uniffi_clone_pointer(),)
        )





    def to_qr_uri(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_to_qr_uri,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_address_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeAddress:

    @staticmethod
    def lift(value: int):
        return Address._make_instance_(value)

    @staticmethod
    def check_lower(value: Address):
        if not isinstance(value, Address):
            raise TypeError("Expected Address instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: AddressProtocol):
        if not isinstance(value, Address):
            raise TypeError("Expected Address instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: AddressProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class BumpFeeTxBuilderProtocol(typing.Protocol):
    def finish(self, wallet: "Wallet"):
        raise NotImplementedError
    def set_exact_sequence(self, nsequence: "int"):
        raise NotImplementedError


class BumpFeeTxBuilder:
    _pointer: ctypes.c_void_p
    def __init__(self, txid: "str",fee_rate: "FeeRate"):
        _UniffiConverterString.check_lower(txid)
        
        _UniffiConverterTypeFeeRate.check_lower(fee_rate)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_bumpfeetxbuilder_new,
        _UniffiConverterString.lower(txid),
        _UniffiConverterTypeFeeRate.lower(fee_rate))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_bumpfeetxbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_bumpfeetxbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def finish(self, wallet: "Wallet") -> "Psbt":
        _UniffiConverterTypeWallet.check_lower(wallet)
        
        return _UniffiConverterTypePsbt.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeCreateTxError,_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_finish,self._uniffi_clone_pointer(),
        _UniffiConverterTypeWallet.lower(wallet))
        )





    def set_exact_sequence(self, nsequence: "int") -> "BumpFeeTxBuilder":
        _UniffiConverterUInt32.check_lower(nsequence)
        
        return _UniffiConverterTypeBumpFeeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_bumpfeetxbuilder_set_exact_sequence,self._uniffi_clone_pointer(),
        _UniffiConverterUInt32.lower(nsequence))
        )






class _UniffiConverterTypeBumpFeeTxBuilder:

    @staticmethod
    def lift(value: int):
        return BumpFeeTxBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: BumpFeeTxBuilder):
        if not isinstance(value, BumpFeeTxBuilder):
            raise TypeError("Expected BumpFeeTxBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: BumpFeeTxBuilderProtocol):
        if not isinstance(value, BumpFeeTxBuilder):
            raise TypeError("Expected BumpFeeTxBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: BumpFeeTxBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ChangeSetProtocol(typing.Protocol):
    pass


class ChangeSet:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_changeset, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_changeset, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeChangeSet:

    @staticmethod
    def lift(value: int):
        return ChangeSet._make_instance_(value)

    @staticmethod
    def check_lower(value: ChangeSet):
        if not isinstance(value, ChangeSet):
            raise TypeError("Expected ChangeSet instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ChangeSetProtocol):
        if not isinstance(value, ChangeSet):
            raise TypeError("Expected ChangeSet instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ChangeSetProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ConnectionProtocol(typing.Protocol):
    pass


class Connection:
    _pointer: ctypes.c_void_p
    def __init__(self, path: "str"):
        _UniffiConverterString.check_lower(path)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSqliteError,_UniffiLib.uniffi_bdkffi_fn_constructor_connection_new,
        _UniffiConverterString.lower(path))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_connection, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_connection, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_in_memory(cls, ):
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeSqliteError,_UniffiLib.uniffi_bdkffi_fn_constructor_connection_new_in_memory,)
        return cls._make_instance_(pointer)




class _UniffiConverterTypeConnection:

    @staticmethod
    def lift(value: int):
        return Connection._make_instance_(value)

    @staticmethod
    def check_lower(value: Connection):
        if not isinstance(value, Connection):
            raise TypeError("Expected Connection instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ConnectionProtocol):
        if not isinstance(value, Connection):
            raise TypeError("Expected Connection instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ConnectionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DerivationPathProtocol(typing.Protocol):
    pass


class DerivationPath:
    _pointer: ctypes.c_void_p
    def __init__(self, path: "str"):
        _UniffiConverterString.check_lower(path)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBip32Error,_UniffiLib.uniffi_bdkffi_fn_constructor_derivationpath_new,
        _UniffiConverterString.lower(path))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_derivationpath, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_derivationpath, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeDerivationPath:

    @staticmethod
    def lift(value: int):
        return DerivationPath._make_instance_(value)

    @staticmethod
    def check_lower(value: DerivationPath):
        if not isinstance(value, DerivationPath):
            raise TypeError("Expected DerivationPath instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DerivationPathProtocol):
        if not isinstance(value, DerivationPath):
            raise TypeError("Expected DerivationPath instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DerivationPathProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DescriptorProtocol(typing.Protocol):
    def to_string_with_secret(self, ):
        raise NotImplementedError


class Descriptor:
    _pointer: ctypes.c_void_p
    def __init__(self, descriptor: "str",network: "Network"):
        _UniffiConverterString.check_lower(descriptor)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeDescriptorError,_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new,
        _UniffiConverterString.lower(descriptor),
        _UniffiConverterTypeNetwork.lower(network))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_descriptor, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_descriptor, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def new_bip44(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip44_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip44_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip49(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip49_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip49_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip84(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip84_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip84_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip86(cls, secret_key: "DescriptorSecretKey",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorSecretKey.check_lower(secret_key)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86,
        _UniffiConverterTypeDescriptorSecretKey.lower(secret_key),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)


    @classmethod
    def new_bip86_public(cls, public_key: "DescriptorPublicKey",fingerprint: "str",keychain: "KeychainKind",network: "Network"):
        _UniffiConverterTypeDescriptorPublicKey.check_lower(public_key)
        
        _UniffiConverterString.check_lower(fingerprint)
        
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptor_new_bip86_public,
        _UniffiConverterTypeDescriptorPublicKey.lower(public_key),
        _UniffiConverterString.lower(fingerprint),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterTypeNetwork.lower(network))
        return cls._make_instance_(pointer)



    def to_string_with_secret(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptor_to_string_with_secret,self._uniffi_clone_pointer(),)
        )





    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptor_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeDescriptor:

    @staticmethod
    def lift(value: int):
        return Descriptor._make_instance_(value)

    @staticmethod
    def check_lower(value: Descriptor):
        if not isinstance(value, Descriptor):
            raise TypeError("Expected Descriptor instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DescriptorProtocol):
        if not isinstance(value, Descriptor):
            raise TypeError("Expected Descriptor instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DescriptorProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DescriptorPublicKeyProtocol(typing.Protocol):
    def as_string(self, ):
        raise NotImplementedError
    def derive(self, path: "DerivationPath"):
        raise NotImplementedError
    def extend(self, path: "DerivationPath"):
        raise NotImplementedError


class DescriptorPublicKey:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_descriptorpublickey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_descriptorpublickey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, public_key: "str"):
        _UniffiConverterString.check_lower(public_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorpublickey_from_string,
        _UniffiConverterString.lower(public_key))
        return cls._make_instance_(pointer)



    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_as_string,self._uniffi_clone_pointer(),)
        )





    def derive(self, path: "DerivationPath") -> "DescriptorPublicKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorPublicKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_derive,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )





    def extend(self, path: "DerivationPath") -> "DescriptorPublicKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorPublicKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorpublickey_extend,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )






class _UniffiConverterTypeDescriptorPublicKey:

    @staticmethod
    def lift(value: int):
        return DescriptorPublicKey._make_instance_(value)

    @staticmethod
    def check_lower(value: DescriptorPublicKey):
        if not isinstance(value, DescriptorPublicKey):
            raise TypeError("Expected DescriptorPublicKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DescriptorPublicKeyProtocol):
        if not isinstance(value, DescriptorPublicKey):
            raise TypeError("Expected DescriptorPublicKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DescriptorPublicKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class DescriptorSecretKeyProtocol(typing.Protocol):
    def as_public(self, ):
        raise NotImplementedError
    def as_string(self, ):
        raise NotImplementedError
    def derive(self, path: "DerivationPath"):
        raise NotImplementedError
    def extend(self, path: "DerivationPath"):
        raise NotImplementedError
    def secret_bytes(self, ):
        raise NotImplementedError


class DescriptorSecretKey:
    _pointer: ctypes.c_void_p
    def __init__(self, network: "Network",mnemonic: "Mnemonic",password: "typing.Optional[str]"):
        _UniffiConverterTypeNetwork.check_lower(network)
        
        _UniffiConverterTypeMnemonic.check_lower(mnemonic)
        
        _UniffiConverterOptionalString.check_lower(password)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_new,
        _UniffiConverterTypeNetwork.lower(network),
        _UniffiConverterTypeMnemonic.lower(mnemonic),
        _UniffiConverterOptionalString.lower(password))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_descriptorsecretkey, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_descriptorsecretkey, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_string(cls, secret_key: "str"):
        _UniffiConverterString.check_lower(secret_key)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_constructor_descriptorsecretkey_from_string,
        _UniffiConverterString.lower(secret_key))
        return cls._make_instance_(pointer)



    def as_public(self, ) -> "DescriptorPublicKey":
        return _UniffiConverterTypeDescriptorPublicKey.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_public,self._uniffi_clone_pointer(),)
        )





    def as_string(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_as_string,self._uniffi_clone_pointer(),)
        )





    def derive(self, path: "DerivationPath") -> "DescriptorSecretKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorSecretKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_derive,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )





    def extend(self, path: "DerivationPath") -> "DescriptorSecretKey":
        _UniffiConverterTypeDerivationPath.check_lower(path)
        
        return _UniffiConverterTypeDescriptorSecretKey.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeDescriptorKeyError,_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_extend,self._uniffi_clone_pointer(),
        _UniffiConverterTypeDerivationPath.lower(path))
        )





    def secret_bytes(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_descriptorsecretkey_secret_bytes,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeDescriptorSecretKey:

    @staticmethod
    def lift(value: int):
        return DescriptorSecretKey._make_instance_(value)

    @staticmethod
    def check_lower(value: DescriptorSecretKey):
        if not isinstance(value, DescriptorSecretKey):
            raise TypeError("Expected DescriptorSecretKey instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: DescriptorSecretKeyProtocol):
        if not isinstance(value, DescriptorSecretKey):
            raise TypeError("Expected DescriptorSecretKey instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: DescriptorSecretKeyProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class ElectrumClientProtocol(typing.Protocol):
    def broadcast(self, transaction: "Transaction"):
        raise NotImplementedError
    def full_scan(self, full_scan_request: "FullScanRequest",stop_gap: "int",batch_size: "int",fetch_prev_txouts: "bool"):
        raise NotImplementedError
    def sync(self, sync_request: "SyncRequest",batch_size: "int",fetch_prev_txouts: "bool"):
        raise NotImplementedError


class ElectrumClient:
    _pointer: ctypes.c_void_p
    def __init__(self, url: "str"):
        _UniffiConverterString.check_lower(url)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeElectrumError,_UniffiLib.uniffi_bdkffi_fn_constructor_electrumclient_new,
        _UniffiConverterString.lower(url))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_electrumclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_electrumclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def broadcast(self, transaction: "Transaction") -> "str":
        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeElectrumError,_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_broadcast,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(transaction))
        )





    def full_scan(self, full_scan_request: "FullScanRequest",stop_gap: "int",batch_size: "int",fetch_prev_txouts: "bool") -> "Update":
        _UniffiConverterTypeFullScanRequest.check_lower(full_scan_request)
        
        _UniffiConverterUInt64.check_lower(stop_gap)
        
        _UniffiConverterUInt64.check_lower(batch_size)
        
        _UniffiConverterBool.check_lower(fetch_prev_txouts)
        
        return _UniffiConverterTypeUpdate.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeElectrumError,_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_full_scan,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFullScanRequest.lower(full_scan_request),
        _UniffiConverterUInt64.lower(stop_gap),
        _UniffiConverterUInt64.lower(batch_size),
        _UniffiConverterBool.lower(fetch_prev_txouts))
        )





    def sync(self, sync_request: "SyncRequest",batch_size: "int",fetch_prev_txouts: "bool") -> "Update":
        _UniffiConverterTypeSyncRequest.check_lower(sync_request)
        
        _UniffiConverterUInt64.check_lower(batch_size)
        
        _UniffiConverterBool.check_lower(fetch_prev_txouts)
        
        return _UniffiConverterTypeUpdate.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeElectrumError,_UniffiLib.uniffi_bdkffi_fn_method_electrumclient_sync,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSyncRequest.lower(sync_request),
        _UniffiConverterUInt64.lower(batch_size),
        _UniffiConverterBool.lower(fetch_prev_txouts))
        )






class _UniffiConverterTypeElectrumClient:

    @staticmethod
    def lift(value: int):
        return ElectrumClient._make_instance_(value)

    @staticmethod
    def check_lower(value: ElectrumClient):
        if not isinstance(value, ElectrumClient):
            raise TypeError("Expected ElectrumClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: ElectrumClientProtocol):
        if not isinstance(value, ElectrumClient):
            raise TypeError("Expected ElectrumClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: ElectrumClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class EsploraClientProtocol(typing.Protocol):
    def broadcast(self, transaction: "Transaction"):
        raise NotImplementedError
    def full_scan(self, full_scan_request: "FullScanRequest",stop_gap: "int",parallel_requests: "int"):
        raise NotImplementedError
    def get_tx(self, txid: "str"):
        raise NotImplementedError
    def sync(self, sync_request: "SyncRequest",parallel_requests: "int"):
        raise NotImplementedError


class EsploraClient:
    _pointer: ctypes.c_void_p
    def __init__(self, url: "str"):
        _UniffiConverterString.check_lower(url)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_esploraclient_new,
        _UniffiConverterString.lower(url))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_esploraclient, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_esploraclient, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def broadcast(self, transaction: "Transaction") -> None:
        _UniffiConverterTypeTransaction.check_lower(transaction)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeEsploraError,_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_broadcast,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(transaction))






    def full_scan(self, full_scan_request: "FullScanRequest",stop_gap: "int",parallel_requests: "int") -> "Update":
        _UniffiConverterTypeFullScanRequest.check_lower(full_scan_request)
        
        _UniffiConverterUInt64.check_lower(stop_gap)
        
        _UniffiConverterUInt64.check_lower(parallel_requests)
        
        return _UniffiConverterTypeUpdate.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeEsploraError,_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_full_scan,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFullScanRequest.lower(full_scan_request),
        _UniffiConverterUInt64.lower(stop_gap),
        _UniffiConverterUInt64.lower(parallel_requests))
        )





    def get_tx(self, txid: "str") -> "typing.Optional[Transaction]":
        _UniffiConverterString.check_lower(txid)
        
        return _UniffiConverterOptionalTypeTransaction.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeEsploraError,_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_get_tx,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(txid))
        )





    def sync(self, sync_request: "SyncRequest",parallel_requests: "int") -> "Update":
        _UniffiConverterTypeSyncRequest.check_lower(sync_request)
        
        _UniffiConverterUInt64.check_lower(parallel_requests)
        
        return _UniffiConverterTypeUpdate.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeEsploraError,_UniffiLib.uniffi_bdkffi_fn_method_esploraclient_sync,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSyncRequest.lower(sync_request),
        _UniffiConverterUInt64.lower(parallel_requests))
        )






class _UniffiConverterTypeEsploraClient:

    @staticmethod
    def lift(value: int):
        return EsploraClient._make_instance_(value)

    @staticmethod
    def check_lower(value: EsploraClient):
        if not isinstance(value, EsploraClient):
            raise TypeError("Expected EsploraClient instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: EsploraClientProtocol):
        if not isinstance(value, EsploraClient):
            raise TypeError("Expected EsploraClient instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: EsploraClientProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FullScanRequestProtocol(typing.Protocol):
    pass


class FullScanRequest:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_fullscanrequest, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_fullscanrequest, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeFullScanRequest:

    @staticmethod
    def lift(value: int):
        return FullScanRequest._make_instance_(value)

    @staticmethod
    def check_lower(value: FullScanRequest):
        if not isinstance(value, FullScanRequest):
            raise TypeError("Expected FullScanRequest instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FullScanRequestProtocol):
        if not isinstance(value, FullScanRequest):
            raise TypeError("Expected FullScanRequest instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FullScanRequestProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FullScanRequestBuilderProtocol(typing.Protocol):
    def build(self, ):
        raise NotImplementedError
    def inspect_spks_for_all_keychains(self, inspector: "FullScanScriptInspector"):
        raise NotImplementedError


class FullScanRequestBuilder:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_fullscanrequestbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_fullscanrequestbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def build(self, ) -> "FullScanRequest":
        return _UniffiConverterTypeFullScanRequest.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeRequestBuilderError,_UniffiLib.uniffi_bdkffi_fn_method_fullscanrequestbuilder_build,self._uniffi_clone_pointer(),)
        )





    def inspect_spks_for_all_keychains(self, inspector: "FullScanScriptInspector") -> "FullScanRequestBuilder":
        _UniffiConverterTypeFullScanScriptInspector.check_lower(inspector)
        
        return _UniffiConverterTypeFullScanRequestBuilder.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeRequestBuilderError,_UniffiLib.uniffi_bdkffi_fn_method_fullscanrequestbuilder_inspect_spks_for_all_keychains,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFullScanScriptInspector.lower(inspector))
        )






class _UniffiConverterTypeFullScanRequestBuilder:

    @staticmethod
    def lift(value: int):
        return FullScanRequestBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: FullScanRequestBuilder):
        if not isinstance(value, FullScanRequestBuilder):
            raise TypeError("Expected FullScanRequestBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: FullScanRequestBuilderProtocol):
        if not isinstance(value, FullScanRequestBuilder):
            raise TypeError("Expected FullScanRequestBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FullScanRequestBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class FullScanScriptInspector(typing.Protocol):
    def inspect(self, keychain: "KeychainKind",index: "int",script: "Script"):
        raise NotImplementedError


class FullScanScriptInspectorImpl:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_fullscanscriptinspector, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_fullscanscriptinspector, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def inspect(self, keychain: "KeychainKind",index: "int",script: "Script") -> None:
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterUInt32.check_lower(index)
        
        _UniffiConverterTypeScript.check_lower(script)
        
        _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_fullscanscriptinspector_inspect,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterUInt32.lower(index),
        _UniffiConverterTypeScript.lower(script))




# Magic number for the Rust proxy to call using the same mechanism as every other method,
# to free the callback once it's dropped by Rust.
_UNIFFI_IDX_CALLBACK_FREE = 0
# Return codes for callback calls
_UNIFFI_CALLBACK_SUCCESS = 0
_UNIFFI_CALLBACK_ERROR = 1
_UNIFFI_CALLBACK_UNEXPECTED_ERROR = 2

class _UniffiCallbackInterfaceFfiConverter:
    _handle_map = _UniffiHandleMap()

    @classmethod
    def lift(cls, handle):
        return cls._handle_map.get(handle)

    @classmethod
    def read(cls, buf):
        handle = buf.read_u64()
        cls.lift(handle)

    @classmethod
    def check_lower(cls, cb):
        pass

    @classmethod
    def lower(cls, cb):
        handle = cls._handle_map.insert(cb)
        return handle

    @classmethod
    def write(cls, cb, buf):
        buf.write_u64(cls.lower(cb))

# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplFullScanScriptInspector:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_FULL_SCAN_SCRIPT_INSPECTOR_METHOD0
    def inspect(
            uniffi_handle,
            keychain,
            index,
            script,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeFullScanScriptInspector._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeKeychainKind.lift(keychain), _UniffiConverterUInt32.lift(index), _UniffiConverterTypeScript.lift(script), )
            method = uniffi_obj.inspect
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeFullScanScriptInspector._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceFullScanScriptInspector(
        inspect,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_bdkffi_fn_init_callback_vtable_fullscanscriptinspector(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeFullScanScriptInspector:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return FullScanScriptInspectorImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: FullScanScriptInspector):
        pass

    @staticmethod
    def lower(value: FullScanScriptInspector):
        return _UniffiConverterTypeFullScanScriptInspector._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: FullScanScriptInspector, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class MnemonicProtocol(typing.Protocol):
    pass


class Mnemonic:
    _pointer: ctypes.c_void_p
    def __init__(self, word_count: "WordCount"):
        _UniffiConverterTypeWordCount.check_lower(word_count)
        
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_new,
        _UniffiConverterTypeWordCount.lower(word_count))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_mnemonic, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_mnemonic, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def from_entropy(cls, entropy: "typing.List[int]"):
        _UniffiConverterSequenceUInt8.check_lower(entropy)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBip39Error,_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_entropy,
        _UniffiConverterSequenceUInt8.lower(entropy))
        return cls._make_instance_(pointer)


    @classmethod
    def from_string(cls, mnemonic: "str"):
        _UniffiConverterString.check_lower(mnemonic)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeBip39Error,_UniffiLib.uniffi_bdkffi_fn_constructor_mnemonic_from_string,
        _UniffiConverterString.lower(mnemonic))
        return cls._make_instance_(pointer)



    def __str__(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_mnemonic_uniffi_trait_display,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeMnemonic:

    @staticmethod
    def lift(value: int):
        return Mnemonic._make_instance_(value)

    @staticmethod
    def check_lower(value: Mnemonic):
        if not isinstance(value, Mnemonic):
            raise TypeError("Expected Mnemonic instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: MnemonicProtocol):
        if not isinstance(value, Mnemonic):
            raise TypeError("Expected Mnemonic instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: MnemonicProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class PsbtProtocol(typing.Protocol):
    def combine(self, other: "Psbt"):
        raise NotImplementedError
    def extract_tx(self, ):
        raise NotImplementedError
    def fee(self, ):
        raise NotImplementedError
    def json_serialize(self, ):
        raise NotImplementedError
    def serialize(self, ):
        raise NotImplementedError


class Psbt:
    _pointer: ctypes.c_void_p
    def __init__(self, psbt_base64: "str"):
        _UniffiConverterString.check_lower(psbt_base64)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypePsbtParseError,_UniffiLib.uniffi_bdkffi_fn_constructor_psbt_new,
        _UniffiConverterString.lower(psbt_base64))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_psbt, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_psbt, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def combine(self, other: "Psbt") -> "Psbt":
        _UniffiConverterTypePsbt.check_lower(other)
        
        return _UniffiConverterTypePsbt.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypePsbtError,_UniffiLib.uniffi_bdkffi_fn_method_psbt_combine,self._uniffi_clone_pointer(),
        _UniffiConverterTypePsbt.lower(other))
        )





    def extract_tx(self, ) -> "Transaction":
        return _UniffiConverterTypeTransaction.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeExtractTxError,_UniffiLib.uniffi_bdkffi_fn_method_psbt_extract_tx,self._uniffi_clone_pointer(),)
        )





    def fee(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypePsbtError,_UniffiLib.uniffi_bdkffi_fn_method_psbt_fee,self._uniffi_clone_pointer(),)
        )





    def json_serialize(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_psbt_json_serialize,self._uniffi_clone_pointer(),)
        )





    def serialize(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_psbt_serialize,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypePsbt:

    @staticmethod
    def lift(value: int):
        return Psbt._make_instance_(value)

    @staticmethod
    def check_lower(value: Psbt):
        if not isinstance(value, Psbt):
            raise TypeError("Expected Psbt instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: PsbtProtocol):
        if not isinstance(value, Psbt):
            raise TypeError("Expected Psbt instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: PsbtProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SyncRequestProtocol(typing.Protocol):
    pass


class SyncRequest:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_syncrequest, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_syncrequest, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeSyncRequest:

    @staticmethod
    def lift(value: int):
        return SyncRequest._make_instance_(value)

    @staticmethod
    def check_lower(value: SyncRequest):
        if not isinstance(value, SyncRequest):
            raise TypeError("Expected SyncRequest instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SyncRequestProtocol):
        if not isinstance(value, SyncRequest):
            raise TypeError("Expected SyncRequest instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SyncRequestProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SyncRequestBuilderProtocol(typing.Protocol):
    def build(self, ):
        raise NotImplementedError
    def inspect_spks(self, inspector: "SyncScriptInspector"):
        raise NotImplementedError


class SyncRequestBuilder:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_syncrequestbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_syncrequestbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def build(self, ) -> "SyncRequest":
        return _UniffiConverterTypeSyncRequest.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeRequestBuilderError,_UniffiLib.uniffi_bdkffi_fn_method_syncrequestbuilder_build,self._uniffi_clone_pointer(),)
        )





    def inspect_spks(self, inspector: "SyncScriptInspector") -> "SyncRequestBuilder":
        _UniffiConverterTypeSyncScriptInspector.check_lower(inspector)
        
        return _UniffiConverterTypeSyncRequestBuilder.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeRequestBuilderError,_UniffiLib.uniffi_bdkffi_fn_method_syncrequestbuilder_inspect_spks,self._uniffi_clone_pointer(),
        _UniffiConverterTypeSyncScriptInspector.lower(inspector))
        )






class _UniffiConverterTypeSyncRequestBuilder:

    @staticmethod
    def lift(value: int):
        return SyncRequestBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: SyncRequestBuilder):
        if not isinstance(value, SyncRequestBuilder):
            raise TypeError("Expected SyncRequestBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: SyncRequestBuilderProtocol):
        if not isinstance(value, SyncRequestBuilder):
            raise TypeError("Expected SyncRequestBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SyncRequestBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class SyncScriptInspector(typing.Protocol):
    def inspect(self, script: "Script",total: "int"):
        raise NotImplementedError


class SyncScriptInspectorImpl:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_syncscriptinspector, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_syncscriptinspector, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def inspect(self, script: "Script",total: "int") -> None:
        _UniffiConverterTypeScript.check_lower(script)
        
        _UniffiConverterUInt64.check_lower(total)
        
        _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_syncscriptinspector_inspect,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script),
        _UniffiConverterUInt64.lower(total))






# Put all the bits inside a class to keep the top-level namespace clean
class _UniffiTraitImplSyncScriptInspector:
    # For each method, generate a callback function to pass to Rust

    @_UNIFFI_CALLBACK_INTERFACE_SYNC_SCRIPT_INSPECTOR_METHOD0
    def inspect(
            uniffi_handle,
            script,
            total,
            uniffi_out_return,
            uniffi_call_status_ptr,
        ):
        uniffi_obj = _UniffiConverterTypeSyncScriptInspector._handle_map.get(uniffi_handle)
        def make_call():
            args = (_UniffiConverterTypeScript.lift(script), _UniffiConverterUInt64.lift(total), )
            method = uniffi_obj.inspect
            return method(*args)

        
        write_return_value = lambda v: None
        _uniffi_trait_interface_call(
                uniffi_call_status_ptr.contents,
                make_call,
                write_return_value,
        )

    @_UNIFFI_CALLBACK_INTERFACE_FREE
    def _uniffi_free(uniffi_handle):
        _UniffiConverterTypeSyncScriptInspector._handle_map.remove(uniffi_handle)

    # Generate the FFI VTable.  This has a field for each callback interface method.
    _uniffi_vtable = _UniffiVTableCallbackInterfaceSyncScriptInspector(
        inspect,
        _uniffi_free
    )
    # Send Rust a pointer to the VTable.  Note: this means we need to keep the struct alive forever,
    # or else bad things will happen when Rust tries to access it.
    _UniffiLib.uniffi_bdkffi_fn_init_callback_vtable_syncscriptinspector(ctypes.byref(_uniffi_vtable))



class _UniffiConverterTypeSyncScriptInspector:
    _handle_map = _UniffiHandleMap()

    @staticmethod
    def lift(value: int):
        return SyncScriptInspectorImpl._make_instance_(value)

    @staticmethod
    def check_lower(value: SyncScriptInspector):
        pass

    @staticmethod
    def lower(value: SyncScriptInspector):
        return _UniffiConverterTypeSyncScriptInspector._handle_map.insert(value)

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: SyncScriptInspector, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TransactionProtocol(typing.Protocol):
    def compute_txid(self, ):
        raise NotImplementedError
    def input(self, ):
        raise NotImplementedError
    def is_coinbase(self, ):
        raise NotImplementedError
    def is_explicitly_rbf(self, ):
        raise NotImplementedError
    def is_lock_time_enabled(self, ):
        raise NotImplementedError
    def lock_time(self, ):
        raise NotImplementedError
    def output(self, ):
        raise NotImplementedError
    def serialize(self, ):
        raise NotImplementedError
    def total_size(self, ):
        raise NotImplementedError
    def version(self, ):
        raise NotImplementedError
    def vsize(self, ):
        raise NotImplementedError
    def weight(self, ):
        raise NotImplementedError


class Transaction:
    _pointer: ctypes.c_void_p
    def __init__(self, transaction_bytes: "typing.List[int]"):
        _UniffiConverterSequenceUInt8.check_lower(transaction_bytes)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeTransactionError,_UniffiLib.uniffi_bdkffi_fn_constructor_transaction_new,
        _UniffiConverterSequenceUInt8.lower(transaction_bytes))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_transaction, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_transaction, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def compute_txid(self, ) -> "str":
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_compute_txid,self._uniffi_clone_pointer(),)
        )





    def input(self, ) -> "typing.List[TxIn]":
        return _UniffiConverterSequenceTypeTxIn.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_input,self._uniffi_clone_pointer(),)
        )





    def is_coinbase(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_coinbase,self._uniffi_clone_pointer(),)
        )





    def is_explicitly_rbf(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_explicitly_rbf,self._uniffi_clone_pointer(),)
        )





    def is_lock_time_enabled(self, ) -> "bool":
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_is_lock_time_enabled,self._uniffi_clone_pointer(),)
        )





    def lock_time(self, ) -> "int":
        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_lock_time,self._uniffi_clone_pointer(),)
        )





    def output(self, ) -> "typing.List[TxOut]":
        return _UniffiConverterSequenceTypeTxOut.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_output,self._uniffi_clone_pointer(),)
        )





    def serialize(self, ) -> "typing.List[int]":
        return _UniffiConverterSequenceUInt8.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_serialize,self._uniffi_clone_pointer(),)
        )





    def total_size(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_total_size,self._uniffi_clone_pointer(),)
        )





    def version(self, ) -> "int":
        return _UniffiConverterInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_version,self._uniffi_clone_pointer(),)
        )





    def vsize(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_vsize,self._uniffi_clone_pointer(),)
        )





    def weight(self, ) -> "int":
        return _UniffiConverterUInt64.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_transaction_weight,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeTransaction:

    @staticmethod
    def lift(value: int):
        return Transaction._make_instance_(value)

    @staticmethod
    def check_lower(value: Transaction):
        if not isinstance(value, Transaction):
            raise TypeError("Expected Transaction instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TransactionProtocol):
        if not isinstance(value, Transaction):
            raise TypeError("Expected Transaction instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TransactionProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class TxBuilderProtocol(typing.Protocol):
    def add_global_xpubs(self, ):
        raise NotImplementedError
    def add_recipient(self, script: "Script",amount: "Amount"):
        raise NotImplementedError
    def add_unspendable(self, unspendable: "OutPoint"):
        raise NotImplementedError
    def add_utxo(self, outpoint: "OutPoint"):
        raise NotImplementedError
    def change_policy(self, change_policy: "ChangeSpendPolicy"):
        raise NotImplementedError
    def do_not_spend_change(self, ):
        raise NotImplementedError
    def drain_to(self, script: "Script"):
        raise NotImplementedError
    def drain_wallet(self, ):
        raise NotImplementedError
    def fee_absolute(self, fee: "Amount"):
        raise NotImplementedError
    def fee_rate(self, fee_rate: "FeeRate"):
        raise NotImplementedError
    def finish(self, wallet: "Wallet"):
        raise NotImplementedError
    def manually_selected_only(self, ):
        raise NotImplementedError
    def only_spend_change(self, ):
        raise NotImplementedError
    def set_exact_sequence(self, nsequence: "int"):
        raise NotImplementedError
    def set_recipients(self, recipients: "typing.List[ScriptAmount]"):
        raise NotImplementedError
    def unspendable(self, unspendable: "typing.List[OutPoint]"):
        raise NotImplementedError


class TxBuilder:
    _pointer: ctypes.c_void_p
    def __init__(self, ):
        self._pointer = _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_constructor_txbuilder_new,)

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_txbuilder, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_txbuilder, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst


    def add_global_xpubs(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_global_xpubs,self._uniffi_clone_pointer(),)
        )





    def add_recipient(self, script: "Script",amount: "Amount") -> "TxBuilder":
        _UniffiConverterTypeScript.check_lower(script)
        
        _UniffiConverterTypeAmount.check_lower(amount)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_recipient,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script),
        _UniffiConverterTypeAmount.lower(amount))
        )





    def add_unspendable(self, unspendable: "OutPoint") -> "TxBuilder":
        _UniffiConverterTypeOutPoint.check_lower(unspendable)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_unspendable,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOutPoint.lower(unspendable))
        )





    def add_utxo(self, outpoint: "OutPoint") -> "TxBuilder":
        _UniffiConverterTypeOutPoint.check_lower(outpoint)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_add_utxo,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOutPoint.lower(outpoint))
        )





    def change_policy(self, change_policy: "ChangeSpendPolicy") -> "TxBuilder":
        _UniffiConverterTypeChangeSpendPolicy.check_lower(change_policy)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_change_policy,self._uniffi_clone_pointer(),
        _UniffiConverterTypeChangeSpendPolicy.lower(change_policy))
        )





    def do_not_spend_change(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_do_not_spend_change,self._uniffi_clone_pointer(),)
        )





    def drain_to(self, script: "Script") -> "TxBuilder":
        _UniffiConverterTypeScript.check_lower(script)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_to,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script))
        )





    def drain_wallet(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_drain_wallet,self._uniffi_clone_pointer(),)
        )





    def fee_absolute(self, fee: "Amount") -> "TxBuilder":
        _UniffiConverterTypeAmount.check_lower(fee)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_absolute,self._uniffi_clone_pointer(),
        _UniffiConverterTypeAmount.lower(fee))
        )





    def fee_rate(self, fee_rate: "FeeRate") -> "TxBuilder":
        _UniffiConverterTypeFeeRate.check_lower(fee_rate)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_fee_rate,self._uniffi_clone_pointer(),
        _UniffiConverterTypeFeeRate.lower(fee_rate))
        )





    def finish(self, wallet: "Wallet") -> "Psbt":
        _UniffiConverterTypeWallet.check_lower(wallet)
        
        return _UniffiConverterTypePsbt.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeCreateTxError,_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_finish,self._uniffi_clone_pointer(),
        _UniffiConverterTypeWallet.lower(wallet))
        )





    def manually_selected_only(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_manually_selected_only,self._uniffi_clone_pointer(),)
        )





    def only_spend_change(self, ) -> "TxBuilder":
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_only_spend_change,self._uniffi_clone_pointer(),)
        )





    def set_exact_sequence(self, nsequence: "int") -> "TxBuilder":
        _UniffiConverterUInt32.check_lower(nsequence)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_exact_sequence,self._uniffi_clone_pointer(),
        _UniffiConverterUInt32.lower(nsequence))
        )





    def set_recipients(self, recipients: "typing.List[ScriptAmount]") -> "TxBuilder":
        _UniffiConverterSequenceTypeScriptAmount.check_lower(recipients)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_set_recipients,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeScriptAmount.lower(recipients))
        )





    def unspendable(self, unspendable: "typing.List[OutPoint]") -> "TxBuilder":
        _UniffiConverterSequenceTypeOutPoint.check_lower(unspendable)
        
        return _UniffiConverterTypeTxBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_txbuilder_unspendable,self._uniffi_clone_pointer(),
        _UniffiConverterSequenceTypeOutPoint.lower(unspendable))
        )






class _UniffiConverterTypeTxBuilder:

    @staticmethod
    def lift(value: int):
        return TxBuilder._make_instance_(value)

    @staticmethod
    def check_lower(value: TxBuilder):
        if not isinstance(value, TxBuilder):
            raise TypeError("Expected TxBuilder instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: TxBuilderProtocol):
        if not isinstance(value, TxBuilder):
            raise TypeError("Expected TxBuilder instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: TxBuilderProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class UpdateProtocol(typing.Protocol):
    pass


class Update:
    _pointer: ctypes.c_void_p
    
    def __init__(self, *args, **kwargs):
        raise ValueError("This class has no default constructor")

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_update, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_update, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst



class _UniffiConverterTypeUpdate:

    @staticmethod
    def lift(value: int):
        return Update._make_instance_(value)

    @staticmethod
    def check_lower(value: Update):
        if not isinstance(value, Update):
            raise TypeError("Expected Update instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: UpdateProtocol):
        if not isinstance(value, Update):
            raise TypeError("Expected Update instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: UpdateProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))



class WalletProtocol(typing.Protocol):
    def apply_update(self, update: "Update"):
        raise NotImplementedError
    def balance(self, ):
        raise NotImplementedError
    def calculate_fee(self, tx: "Transaction"):
        raise NotImplementedError
    def calculate_fee_rate(self, tx: "Transaction"):
        raise NotImplementedError
    def cancel_tx(self, tx: "Transaction"):
        raise NotImplementedError
    def derivation_index(self, keychain: "KeychainKind"):
        raise NotImplementedError
    def derivation_of_spk(self, spk: "Script"):
        raise NotImplementedError
    def descriptor_checksum(self, keychain: "KeychainKind"):
        raise NotImplementedError
    def finalize_psbt(self, psbt: "Psbt"):
        raise NotImplementedError
    def get_tx(self, txid: "str"):
        raise NotImplementedError
    def get_utxo(self, op: "OutPoint"):
        raise NotImplementedError
    def is_mine(self, script: "Script"):
        raise NotImplementedError
    def list_output(self, ):
        raise NotImplementedError
    def list_unspent(self, ):
        raise NotImplementedError
    def list_unused_addresses(self, keychain: "KeychainKind"):
        raise NotImplementedError
    def mark_used(self, keychain: "KeychainKind",index: "int"):
        raise NotImplementedError
    def network(self, ):
        raise NotImplementedError
    def next_derivation_index(self, keychain: "KeychainKind"):
        raise NotImplementedError
    def next_unused_address(self, keychain: "KeychainKind"):
        raise NotImplementedError
    def peek_address(self, keychain: "KeychainKind",index: "int"):
        raise NotImplementedError
    def persist(self, connection: "Connection"):
        raise NotImplementedError
    def reveal_addresses_to(self, keychain: "KeychainKind",index: "int"):
        raise NotImplementedError
    def reveal_next_address(self, keychain: "KeychainKind"):
        raise NotImplementedError
    def sent_and_received(self, tx: "Transaction"):
        raise NotImplementedError
    def sign(self, psbt: "Psbt"):
        raise NotImplementedError
    def start_full_scan(self, ):
        raise NotImplementedError
    def start_sync_with_revealed_spks(self, ):
        raise NotImplementedError
    def transactions(self, ):
        raise NotImplementedError


class Wallet:
    _pointer: ctypes.c_void_p
    def __init__(self, descriptor: "Descriptor",change_descriptor: "Descriptor",network: "Network",connection: "Connection"):
        _UniffiConverterTypeDescriptor.check_lower(descriptor)
        
        _UniffiConverterTypeDescriptor.check_lower(change_descriptor)
        
        _UniffiConverterTypeNetwork.check_lower(network)
        
        _UniffiConverterTypeConnection.check_lower(connection)
        
        self._pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeCreateWithPersistError,_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_new,
        _UniffiConverterTypeDescriptor.lower(descriptor),
        _UniffiConverterTypeDescriptor.lower(change_descriptor),
        _UniffiConverterTypeNetwork.lower(network),
        _UniffiConverterTypeConnection.lower(connection))

    def __del__(self):
        # In case of partial initialization of instances.
        pointer = getattr(self, "_pointer", None)
        if pointer is not None:
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_free_wallet, pointer)

    def _uniffi_clone_pointer(self):
        return _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_clone_wallet, self._pointer)

    # Used by alternative constructors or any methods which return this type.
    @classmethod
    def _make_instance_(cls, pointer):
        # Lightly yucky way to bypass the usual __init__ logic
        # and just create a new instance with the required pointer.
        inst = cls.__new__(cls)
        inst._pointer = pointer
        return inst

    @classmethod
    def load(cls, descriptor: "Descriptor",change_descriptor: "Descriptor",connection: "Connection"):
        _UniffiConverterTypeDescriptor.check_lower(descriptor)
        
        _UniffiConverterTypeDescriptor.check_lower(change_descriptor)
        
        _UniffiConverterTypeConnection.check_lower(connection)
        
        # Call the (fallible) function before creating any half-baked object instances.
        pointer = _uniffi_rust_call_with_error(_UniffiConverterTypeLoadWithPersistError,_UniffiLib.uniffi_bdkffi_fn_constructor_wallet_load,
        _UniffiConverterTypeDescriptor.lower(descriptor),
        _UniffiConverterTypeDescriptor.lower(change_descriptor),
        _UniffiConverterTypeConnection.lower(connection))
        return cls._make_instance_(pointer)



    def apply_update(self, update: "Update") -> None:
        _UniffiConverterTypeUpdate.check_lower(update)
        
        _uniffi_rust_call_with_error(_UniffiConverterTypeCannotConnectError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_apply_update,self._uniffi_clone_pointer(),
        _UniffiConverterTypeUpdate.lower(update))






    def balance(self, ) -> "Balance":
        return _UniffiConverterTypeBalance.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_balance,self._uniffi_clone_pointer(),)
        )





    def calculate_fee(self, tx: "Transaction") -> "Amount":
        _UniffiConverterTypeTransaction.check_lower(tx)
        
        return _UniffiConverterTypeAmount.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeCalculateFeeError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(tx))
        )





    def calculate_fee_rate(self, tx: "Transaction") -> "FeeRate":
        _UniffiConverterTypeTransaction.check_lower(tx)
        
        return _UniffiConverterTypeFeeRate.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeCalculateFeeError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_calculate_fee_rate,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(tx))
        )





    def cancel_tx(self, tx: "Transaction") -> None:
        _UniffiConverterTypeTransaction.check_lower(tx)
        
        _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_cancel_tx,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(tx))






    def derivation_index(self, keychain: "KeychainKind") -> "typing.Optional[int]":
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        return _UniffiConverterOptionalUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_derivation_index,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain))
        )





    def derivation_of_spk(self, spk: "Script") -> "typing.Optional[KeychainAndIndex]":
        _UniffiConverterTypeScript.check_lower(spk)
        
        return _UniffiConverterOptionalTypeKeychainAndIndex.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_derivation_of_spk,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(spk))
        )





    def descriptor_checksum(self, keychain: "KeychainKind") -> "str":
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        return _UniffiConverterString.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_descriptor_checksum,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain))
        )





    def finalize_psbt(self, psbt: "Psbt") -> "bool":
        _UniffiConverterTypePsbt.check_lower(psbt)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSignerError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_finalize_psbt,self._uniffi_clone_pointer(),
        _UniffiConverterTypePsbt.lower(psbt))
        )





    def get_tx(self, txid: "str") -> "typing.Optional[CanonicalTx]":
        _UniffiConverterString.check_lower(txid)
        
        return _UniffiConverterOptionalTypeCanonicalTx.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeTxidParseError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_tx,self._uniffi_clone_pointer(),
        _UniffiConverterString.lower(txid))
        )





    def get_utxo(self, op: "OutPoint") -> "typing.Optional[LocalOutput]":
        _UniffiConverterTypeOutPoint.check_lower(op)
        
        return _UniffiConverterOptionalTypeLocalOutput.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_get_utxo,self._uniffi_clone_pointer(),
        _UniffiConverterTypeOutPoint.lower(op))
        )





    def is_mine(self, script: "Script") -> "bool":
        _UniffiConverterTypeScript.check_lower(script)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_is_mine,self._uniffi_clone_pointer(),
        _UniffiConverterTypeScript.lower(script))
        )





    def list_output(self, ) -> "typing.List[LocalOutput]":
        return _UniffiConverterSequenceTypeLocalOutput.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_output,self._uniffi_clone_pointer(),)
        )





    def list_unspent(self, ) -> "typing.List[LocalOutput]":
        return _UniffiConverterSequenceTypeLocalOutput.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unspent,self._uniffi_clone_pointer(),)
        )





    def list_unused_addresses(self, keychain: "KeychainKind") -> "typing.List[AddressInfo]":
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        return _UniffiConverterSequenceTypeAddressInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_list_unused_addresses,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain))
        )





    def mark_used(self, keychain: "KeychainKind",index: "int") -> "bool":
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterUInt32.check_lower(index)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_mark_used,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterUInt32.lower(index))
        )





    def network(self, ) -> "Network":
        return _UniffiConverterTypeNetwork.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_network,self._uniffi_clone_pointer(),)
        )





    def next_derivation_index(self, keychain: "KeychainKind") -> "int":
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        return _UniffiConverterUInt32.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_next_derivation_index,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain))
        )





    def next_unused_address(self, keychain: "KeychainKind") -> "AddressInfo":
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        return _UniffiConverterTypeAddressInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_next_unused_address,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain))
        )





    def peek_address(self, keychain: "KeychainKind",index: "int") -> "AddressInfo":
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterUInt32.check_lower(index)
        
        return _UniffiConverterTypeAddressInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_peek_address,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterUInt32.lower(index))
        )





    def persist(self, connection: "Connection") -> "bool":
        _UniffiConverterTypeConnection.check_lower(connection)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSqliteError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_persist,self._uniffi_clone_pointer(),
        _UniffiConverterTypeConnection.lower(connection))
        )





    def reveal_addresses_to(self, keychain: "KeychainKind",index: "int") -> "typing.List[AddressInfo]":
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        _UniffiConverterUInt32.check_lower(index)
        
        return _UniffiConverterSequenceTypeAddressInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_reveal_addresses_to,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain),
        _UniffiConverterUInt32.lower(index))
        )





    def reveal_next_address(self, keychain: "KeychainKind") -> "AddressInfo":
        _UniffiConverterTypeKeychainKind.check_lower(keychain)
        
        return _UniffiConverterTypeAddressInfo.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_reveal_next_address,self._uniffi_clone_pointer(),
        _UniffiConverterTypeKeychainKind.lower(keychain))
        )





    def sent_and_received(self, tx: "Transaction") -> "SentAndReceivedValues":
        _UniffiConverterTypeTransaction.check_lower(tx)
        
        return _UniffiConverterTypeSentAndReceivedValues.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_sent_and_received,self._uniffi_clone_pointer(),
        _UniffiConverterTypeTransaction.lower(tx))
        )





    def sign(self, psbt: "Psbt") -> "bool":
        _UniffiConverterTypePsbt.check_lower(psbt)
        
        return _UniffiConverterBool.lift(
            _uniffi_rust_call_with_error(_UniffiConverterTypeSignerError,_UniffiLib.uniffi_bdkffi_fn_method_wallet_sign,self._uniffi_clone_pointer(),
        _UniffiConverterTypePsbt.lower(psbt))
        )





    def start_full_scan(self, ) -> "FullScanRequestBuilder":
        return _UniffiConverterTypeFullScanRequestBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_full_scan,self._uniffi_clone_pointer(),)
        )





    def start_sync_with_revealed_spks(self, ) -> "SyncRequestBuilder":
        return _UniffiConverterTypeSyncRequestBuilder.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_start_sync_with_revealed_spks,self._uniffi_clone_pointer(),)
        )





    def transactions(self, ) -> "typing.List[CanonicalTx]":
        return _UniffiConverterSequenceTypeCanonicalTx.lift(
            _uniffi_rust_call(_UniffiLib.uniffi_bdkffi_fn_method_wallet_transactions,self._uniffi_clone_pointer(),)
        )






class _UniffiConverterTypeWallet:

    @staticmethod
    def lift(value: int):
        return Wallet._make_instance_(value)

    @staticmethod
    def check_lower(value: Wallet):
        if not isinstance(value, Wallet):
            raise TypeError("Expected Wallet instance, {} found".format(type(value).__name__))

    @staticmethod
    def lower(value: WalletProtocol):
        if not isinstance(value, Wallet):
            raise TypeError("Expected Wallet instance, {} found".format(type(value).__name__))
        return value._uniffi_clone_pointer()

    @classmethod
    def read(cls, buf: _UniffiRustBuffer):
        ptr = buf.read_u64()
        if ptr == 0:
            raise InternalError("Raw pointer value was null")
        return cls.lift(ptr)

    @classmethod
    def write(cls, value: WalletProtocol, buf: _UniffiRustBuffer):
        buf.write_u64(cls.lower(value))


class AddressInfo:
    index: "int"
    address: "Address"
    keychain: "KeychainKind"
    def __init__(self, *, index: "int", address: "Address", keychain: "KeychainKind"):
        self.index = index
        self.address = address
        self.keychain = keychain

    def __str__(self):
        return "AddressInfo(index={}, address={}, keychain={})".format(self.index, self.address, self.keychain)

    def __eq__(self, other):
        if self.index != other.index:
            return False
        if self.address != other.address:
            return False
        if self.keychain != other.keychain:
            return False
        return True

class _UniffiConverterTypeAddressInfo(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return AddressInfo(
            index=_UniffiConverterUInt32.read(buf),
            address=_UniffiConverterTypeAddress.read(buf),
            keychain=_UniffiConverterTypeKeychainKind.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.index)
        _UniffiConverterTypeAddress.check_lower(value.address)
        _UniffiConverterTypeKeychainKind.check_lower(value.keychain)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.index, buf)
        _UniffiConverterTypeAddress.write(value.address, buf)
        _UniffiConverterTypeKeychainKind.write(value.keychain, buf)


class Balance:
    immature: "Amount"
    trusted_pending: "Amount"
    untrusted_pending: "Amount"
    confirmed: "Amount"
    trusted_spendable: "Amount"
    total: "Amount"
    def __init__(self, *, immature: "Amount", trusted_pending: "Amount", untrusted_pending: "Amount", confirmed: "Amount", trusted_spendable: "Amount", total: "Amount"):
        self.immature = immature
        self.trusted_pending = trusted_pending
        self.untrusted_pending = untrusted_pending
        self.confirmed = confirmed
        self.trusted_spendable = trusted_spendable
        self.total = total

    def __str__(self):
        return "Balance(immature={}, trusted_pending={}, untrusted_pending={}, confirmed={}, trusted_spendable={}, total={})".format(self.immature, self.trusted_pending, self.untrusted_pending, self.confirmed, self.trusted_spendable, self.total)

    def __eq__(self, other):
        if self.immature != other.immature:
            return False
        if self.trusted_pending != other.trusted_pending:
            return False
        if self.untrusted_pending != other.untrusted_pending:
            return False
        if self.confirmed != other.confirmed:
            return False
        if self.trusted_spendable != other.trusted_spendable:
            return False
        if self.total != other.total:
            return False
        return True

class _UniffiConverterTypeBalance(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return Balance(
            immature=_UniffiConverterTypeAmount.read(buf),
            trusted_pending=_UniffiConverterTypeAmount.read(buf),
            untrusted_pending=_UniffiConverterTypeAmount.read(buf),
            confirmed=_UniffiConverterTypeAmount.read(buf),
            trusted_spendable=_UniffiConverterTypeAmount.read(buf),
            total=_UniffiConverterTypeAmount.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAmount.check_lower(value.immature)
        _UniffiConverterTypeAmount.check_lower(value.trusted_pending)
        _UniffiConverterTypeAmount.check_lower(value.untrusted_pending)
        _UniffiConverterTypeAmount.check_lower(value.confirmed)
        _UniffiConverterTypeAmount.check_lower(value.trusted_spendable)
        _UniffiConverterTypeAmount.check_lower(value.total)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAmount.write(value.immature, buf)
        _UniffiConverterTypeAmount.write(value.trusted_pending, buf)
        _UniffiConverterTypeAmount.write(value.untrusted_pending, buf)
        _UniffiConverterTypeAmount.write(value.confirmed, buf)
        _UniffiConverterTypeAmount.write(value.trusted_spendable, buf)
        _UniffiConverterTypeAmount.write(value.total, buf)


class BlockId:
    height: "int"
    hash: "str"
    def __init__(self, *, height: "int", hash: "str"):
        self.height = height
        self.hash = hash

    def __str__(self):
        return "BlockId(height={}, hash={})".format(self.height, self.hash)

    def __eq__(self, other):
        if self.height != other.height:
            return False
        if self.hash != other.hash:
            return False
        return True

class _UniffiConverterTypeBlockId(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return BlockId(
            height=_UniffiConverterUInt32.read(buf),
            hash=_UniffiConverterString.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt32.check_lower(value.height)
        _UniffiConverterString.check_lower(value.hash)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt32.write(value.height, buf)
        _UniffiConverterString.write(value.hash, buf)


class CanonicalTx:
    transaction: "Transaction"
    chain_position: "ChainPosition"
    def __init__(self, *, transaction: "Transaction", chain_position: "ChainPosition"):
        self.transaction = transaction
        self.chain_position = chain_position

    def __str__(self):
        return "CanonicalTx(transaction={}, chain_position={})".format(self.transaction, self.chain_position)

    def __eq__(self, other):
        if self.transaction != other.transaction:
            return False
        if self.chain_position != other.chain_position:
            return False
        return True

class _UniffiConverterTypeCanonicalTx(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return CanonicalTx(
            transaction=_UniffiConverterTypeTransaction.read(buf),
            chain_position=_UniffiConverterTypeChainPosition.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeTransaction.check_lower(value.transaction)
        _UniffiConverterTypeChainPosition.check_lower(value.chain_position)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeTransaction.write(value.transaction, buf)
        _UniffiConverterTypeChainPosition.write(value.chain_position, buf)


class ConfirmationBlockTime:
    block_id: "BlockId"
    confirmation_time: "int"
    def __init__(self, *, block_id: "BlockId", confirmation_time: "int"):
        self.block_id = block_id
        self.confirmation_time = confirmation_time

    def __str__(self):
        return "ConfirmationBlockTime(block_id={}, confirmation_time={})".format(self.block_id, self.confirmation_time)

    def __eq__(self, other):
        if self.block_id != other.block_id:
            return False
        if self.confirmation_time != other.confirmation_time:
            return False
        return True

class _UniffiConverterTypeConfirmationBlockTime(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ConfirmationBlockTime(
            block_id=_UniffiConverterTypeBlockId.read(buf),
            confirmation_time=_UniffiConverterUInt64.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeBlockId.check_lower(value.block_id)
        _UniffiConverterUInt64.check_lower(value.confirmation_time)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeBlockId.write(value.block_id, buf)
        _UniffiConverterUInt64.write(value.confirmation_time, buf)


class KeychainAndIndex:
    keychain: "KeychainKind"
    index: "int"
    def __init__(self, *, keychain: "KeychainKind", index: "int"):
        self.keychain = keychain
        self.index = index

    def __str__(self):
        return "KeychainAndIndex(keychain={}, index={})".format(self.keychain, self.index)

    def __eq__(self, other):
        if self.keychain != other.keychain:
            return False
        if self.index != other.index:
            return False
        return True

class _UniffiConverterTypeKeychainAndIndex(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return KeychainAndIndex(
            keychain=_UniffiConverterTypeKeychainKind.read(buf),
            index=_UniffiConverterUInt32.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeKeychainKind.check_lower(value.keychain)
        _UniffiConverterUInt32.check_lower(value.index)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeKeychainKind.write(value.keychain, buf)
        _UniffiConverterUInt32.write(value.index, buf)


class LocalOutput:
    outpoint: "OutPoint"
    txout: "TxOut"
    keychain: "KeychainKind"
    is_spent: "bool"
    def __init__(self, *, outpoint: "OutPoint", txout: "TxOut", keychain: "KeychainKind", is_spent: "bool"):
        self.outpoint = outpoint
        self.txout = txout
        self.keychain = keychain
        self.is_spent = is_spent

    def __str__(self):
        return "LocalOutput(outpoint={}, txout={}, keychain={}, is_spent={})".format(self.outpoint, self.txout, self.keychain, self.is_spent)

    def __eq__(self, other):
        if self.outpoint != other.outpoint:
            return False
        if self.txout != other.txout:
            return False
        if self.keychain != other.keychain:
            return False
        if self.is_spent != other.is_spent:
            return False
        return True

class _UniffiConverterTypeLocalOutput(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return LocalOutput(
            outpoint=_UniffiConverterTypeOutPoint.read(buf),
            txout=_UniffiConverterTypeTxOut.read(buf),
            keychain=_UniffiConverterTypeKeychainKind.read(buf),
            is_spent=_UniffiConverterBool.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeOutPoint.check_lower(value.outpoint)
        _UniffiConverterTypeTxOut.check_lower(value.txout)
        _UniffiConverterTypeKeychainKind.check_lower(value.keychain)
        _UniffiConverterBool.check_lower(value.is_spent)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeOutPoint.write(value.outpoint, buf)
        _UniffiConverterTypeTxOut.write(value.txout, buf)
        _UniffiConverterTypeKeychainKind.write(value.keychain, buf)
        _UniffiConverterBool.write(value.is_spent, buf)


class ScriptAmount:
    script: "Script"
    amount: "Amount"
    def __init__(self, *, script: "Script", amount: "Amount"):
        self.script = script
        self.amount = amount

    def __str__(self):
        return "ScriptAmount(script={}, amount={})".format(self.script, self.amount)

    def __eq__(self, other):
        if self.script != other.script:
            return False
        if self.amount != other.amount:
            return False
        return True

class _UniffiConverterTypeScriptAmount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return ScriptAmount(
            script=_UniffiConverterTypeScript.read(buf),
            amount=_UniffiConverterTypeAmount.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeScript.check_lower(value.script)
        _UniffiConverterTypeAmount.check_lower(value.amount)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeScript.write(value.script, buf)
        _UniffiConverterTypeAmount.write(value.amount, buf)


class SentAndReceivedValues:
    sent: "Amount"
    received: "Amount"
    def __init__(self, *, sent: "Amount", received: "Amount"):
        self.sent = sent
        self.received = received

    def __str__(self):
        return "SentAndReceivedValues(sent={}, received={})".format(self.sent, self.received)

    def __eq__(self, other):
        if self.sent != other.sent:
            return False
        if self.received != other.received:
            return False
        return True

class _UniffiConverterTypeSentAndReceivedValues(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return SentAndReceivedValues(
            sent=_UniffiConverterTypeAmount.read(buf),
            received=_UniffiConverterTypeAmount.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeAmount.check_lower(value.sent)
        _UniffiConverterTypeAmount.check_lower(value.received)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeAmount.write(value.sent, buf)
        _UniffiConverterTypeAmount.write(value.received, buf)


class TxIn:
    previous_output: "OutPoint"
    script_sig: "Script"
    sequence: "int"
    witness: "typing.List[typing.List[int]]"
    def __init__(self, *, previous_output: "OutPoint", script_sig: "Script", sequence: "int", witness: "typing.List[typing.List[int]]"):
        self.previous_output = previous_output
        self.script_sig = script_sig
        self.sequence = sequence
        self.witness = witness

    def __str__(self):
        return "TxIn(previous_output={}, script_sig={}, sequence={}, witness={})".format(self.previous_output, self.script_sig, self.sequence, self.witness)

    def __eq__(self, other):
        if self.previous_output != other.previous_output:
            return False
        if self.script_sig != other.script_sig:
            return False
        if self.sequence != other.sequence:
            return False
        if self.witness != other.witness:
            return False
        return True

class _UniffiConverterTypeTxIn(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxIn(
            previous_output=_UniffiConverterTypeOutPoint.read(buf),
            script_sig=_UniffiConverterTypeScript.read(buf),
            sequence=_UniffiConverterUInt32.read(buf),
            witness=_UniffiConverterSequenceSequenceUInt8.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterTypeOutPoint.check_lower(value.previous_output)
        _UniffiConverterTypeScript.check_lower(value.script_sig)
        _UniffiConverterUInt32.check_lower(value.sequence)
        _UniffiConverterSequenceSequenceUInt8.check_lower(value.witness)

    @staticmethod
    def write(value, buf):
        _UniffiConverterTypeOutPoint.write(value.previous_output, buf)
        _UniffiConverterTypeScript.write(value.script_sig, buf)
        _UniffiConverterUInt32.write(value.sequence, buf)
        _UniffiConverterSequenceSequenceUInt8.write(value.witness, buf)


class TxOut:
    value: "int"
    script_pubkey: "Script"
    def __init__(self, *, value: "int", script_pubkey: "Script"):
        self.value = value
        self.script_pubkey = script_pubkey

    def __str__(self):
        return "TxOut(value={}, script_pubkey={})".format(self.value, self.script_pubkey)

    def __eq__(self, other):
        if self.value != other.value:
            return False
        if self.script_pubkey != other.script_pubkey:
            return False
        return True

class _UniffiConverterTypeTxOut(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        return TxOut(
            value=_UniffiConverterUInt64.read(buf),
            script_pubkey=_UniffiConverterTypeScript.read(buf),
        )

    @staticmethod
    def check_lower(value):
        _UniffiConverterUInt64.check_lower(value.value)
        _UniffiConverterTypeScript.check_lower(value.script_pubkey)

    @staticmethod
    def write(value, buf):
        _UniffiConverterUInt64.write(value.value, buf)
        _UniffiConverterTypeScript.write(value.script_pubkey, buf)


# AddressParseError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class AddressParseError(Exception):
    pass

_UniffiTempAddressParseError = AddressParseError

class AddressParseError:  # type: ignore
    class Base58(_UniffiTempAddressParseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AddressParseError.Base58({})".format(str(self))
    _UniffiTempAddressParseError.Base58 = Base58 # type: ignore
    class Bech32(_UniffiTempAddressParseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AddressParseError.Bech32({})".format(str(self))
    _UniffiTempAddressParseError.Bech32 = Bech32 # type: ignore
    class WitnessVersion(_UniffiTempAddressParseError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "AddressParseError.WitnessVersion({})".format(str(self))
    _UniffiTempAddressParseError.WitnessVersion = WitnessVersion # type: ignore
    class WitnessProgram(_UniffiTempAddressParseError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "AddressParseError.WitnessProgram({})".format(str(self))
    _UniffiTempAddressParseError.WitnessProgram = WitnessProgram # type: ignore
    class UnknownHrp(_UniffiTempAddressParseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AddressParseError.UnknownHrp({})".format(str(self))
    _UniffiTempAddressParseError.UnknownHrp = UnknownHrp # type: ignore
    class LegacyAddressTooLong(_UniffiTempAddressParseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AddressParseError.LegacyAddressTooLong({})".format(str(self))
    _UniffiTempAddressParseError.LegacyAddressTooLong = LegacyAddressTooLong # type: ignore
    class InvalidBase58PayloadLength(_UniffiTempAddressParseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AddressParseError.InvalidBase58PayloadLength({})".format(str(self))
    _UniffiTempAddressParseError.InvalidBase58PayloadLength = InvalidBase58PayloadLength # type: ignore
    class InvalidLegacyPrefix(_UniffiTempAddressParseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AddressParseError.InvalidLegacyPrefix({})".format(str(self))
    _UniffiTempAddressParseError.InvalidLegacyPrefix = InvalidLegacyPrefix # type: ignore
    class NetworkValidation(_UniffiTempAddressParseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AddressParseError.NetworkValidation({})".format(str(self))
    _UniffiTempAddressParseError.NetworkValidation = NetworkValidation # type: ignore
    class OtherAddressParseErr(_UniffiTempAddressParseError):
        def __init__(self):
            pass

        def __repr__(self):
            return "AddressParseError.OtherAddressParseErr({})".format(str(self))
    _UniffiTempAddressParseError.OtherAddressParseErr = OtherAddressParseErr # type: ignore

AddressParseError = _UniffiTempAddressParseError # type: ignore
del _UniffiTempAddressParseError


class _UniffiConverterTypeAddressParseError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return AddressParseError.Base58(
            )
        if variant == 2:
            return AddressParseError.Bech32(
            )
        if variant == 3:
            return AddressParseError.WitnessVersion(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return AddressParseError.WitnessProgram(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return AddressParseError.UnknownHrp(
            )
        if variant == 6:
            return AddressParseError.LegacyAddressTooLong(
            )
        if variant == 7:
            return AddressParseError.InvalidBase58PayloadLength(
            )
        if variant == 8:
            return AddressParseError.InvalidLegacyPrefix(
            )
        if variant == 9:
            return AddressParseError.NetworkValidation(
            )
        if variant == 10:
            return AddressParseError.OtherAddressParseErr(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, AddressParseError.Base58):
            return
        if isinstance(value, AddressParseError.Bech32):
            return
        if isinstance(value, AddressParseError.WitnessVersion):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, AddressParseError.WitnessProgram):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, AddressParseError.UnknownHrp):
            return
        if isinstance(value, AddressParseError.LegacyAddressTooLong):
            return
        if isinstance(value, AddressParseError.InvalidBase58PayloadLength):
            return
        if isinstance(value, AddressParseError.InvalidLegacyPrefix):
            return
        if isinstance(value, AddressParseError.NetworkValidation):
            return
        if isinstance(value, AddressParseError.OtherAddressParseErr):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, AddressParseError.Base58):
            buf.write_i32(1)
        if isinstance(value, AddressParseError.Bech32):
            buf.write_i32(2)
        if isinstance(value, AddressParseError.WitnessVersion):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, AddressParseError.WitnessProgram):
            buf.write_i32(4)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, AddressParseError.UnknownHrp):
            buf.write_i32(5)
        if isinstance(value, AddressParseError.LegacyAddressTooLong):
            buf.write_i32(6)
        if isinstance(value, AddressParseError.InvalidBase58PayloadLength):
            buf.write_i32(7)
        if isinstance(value, AddressParseError.InvalidLegacyPrefix):
            buf.write_i32(8)
        if isinstance(value, AddressParseError.NetworkValidation):
            buf.write_i32(9)
        if isinstance(value, AddressParseError.OtherAddressParseErr):
            buf.write_i32(10)


# Bip32Error
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class Bip32Error(Exception):
    pass

_UniffiTempBip32Error = Bip32Error

class Bip32Error:  # type: ignore
    class CannotDeriveFromHardenedKey(_UniffiTempBip32Error):
        def __init__(self):
            pass

        def __repr__(self):
            return "Bip32Error.CannotDeriveFromHardenedKey({})".format(str(self))
    _UniffiTempBip32Error.CannotDeriveFromHardenedKey = CannotDeriveFromHardenedKey # type: ignore
    class Secp256k1(_UniffiTempBip32Error):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "Bip32Error.Secp256k1({})".format(str(self))
    _UniffiTempBip32Error.Secp256k1 = Secp256k1 # type: ignore
    class InvalidChildNumber(_UniffiTempBip32Error):
        def __init__(self, child_number):
            super().__init__(", ".join([
                "child_number={!r}".format(child_number),
            ]))
            self.child_number = child_number

        def __repr__(self):
            return "Bip32Error.InvalidChildNumber({})".format(str(self))
    _UniffiTempBip32Error.InvalidChildNumber = InvalidChildNumber # type: ignore
    class InvalidChildNumberFormat(_UniffiTempBip32Error):
        def __init__(self):
            pass

        def __repr__(self):
            return "Bip32Error.InvalidChildNumberFormat({})".format(str(self))
    _UniffiTempBip32Error.InvalidChildNumberFormat = InvalidChildNumberFormat # type: ignore
    class InvalidDerivationPathFormat(_UniffiTempBip32Error):
        def __init__(self):
            pass

        def __repr__(self):
            return "Bip32Error.InvalidDerivationPathFormat({})".format(str(self))
    _UniffiTempBip32Error.InvalidDerivationPathFormat = InvalidDerivationPathFormat # type: ignore
    class UnknownVersion(_UniffiTempBip32Error):
        def __init__(self, version):
            super().__init__(", ".join([
                "version={!r}".format(version),
            ]))
            self.version = version

        def __repr__(self):
            return "Bip32Error.UnknownVersion({})".format(str(self))
    _UniffiTempBip32Error.UnknownVersion = UnknownVersion # type: ignore
    class WrongExtendedKeyLength(_UniffiTempBip32Error):
        def __init__(self, length):
            super().__init__(", ".join([
                "length={!r}".format(length),
            ]))
            self.length = length

        def __repr__(self):
            return "Bip32Error.WrongExtendedKeyLength({})".format(str(self))
    _UniffiTempBip32Error.WrongExtendedKeyLength = WrongExtendedKeyLength # type: ignore
    class Base58(_UniffiTempBip32Error):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "Bip32Error.Base58({})".format(str(self))
    _UniffiTempBip32Error.Base58 = Base58 # type: ignore
    class Hex(_UniffiTempBip32Error):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "Bip32Error.Hex({})".format(str(self))
    _UniffiTempBip32Error.Hex = Hex # type: ignore
    class InvalidPublicKeyHexLength(_UniffiTempBip32Error):
        def __init__(self, length):
            super().__init__(", ".join([
                "length={!r}".format(length),
            ]))
            self.length = length

        def __repr__(self):
            return "Bip32Error.InvalidPublicKeyHexLength({})".format(str(self))
    _UniffiTempBip32Error.InvalidPublicKeyHexLength = InvalidPublicKeyHexLength # type: ignore
    class UnknownError(_UniffiTempBip32Error):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "Bip32Error.UnknownError({})".format(str(self))
    _UniffiTempBip32Error.UnknownError = UnknownError # type: ignore

Bip32Error = _UniffiTempBip32Error # type: ignore
del _UniffiTempBip32Error


class _UniffiConverterTypeBip32Error(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Bip32Error.CannotDeriveFromHardenedKey(
            )
        if variant == 2:
            return Bip32Error.Secp256k1(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return Bip32Error.InvalidChildNumber(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 4:
            return Bip32Error.InvalidChildNumberFormat(
            )
        if variant == 5:
            return Bip32Error.InvalidDerivationPathFormat(
            )
        if variant == 6:
            return Bip32Error.UnknownVersion(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return Bip32Error.WrongExtendedKeyLength(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 8:
            return Bip32Error.Base58(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return Bip32Error.Hex(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return Bip32Error.InvalidPublicKeyHexLength(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 11:
            return Bip32Error.UnknownError(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, Bip32Error.CannotDeriveFromHardenedKey):
            return
        if isinstance(value, Bip32Error.Secp256k1):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, Bip32Error.InvalidChildNumber):
            _UniffiConverterUInt32.check_lower(value.child_number)
            return
        if isinstance(value, Bip32Error.InvalidChildNumberFormat):
            return
        if isinstance(value, Bip32Error.InvalidDerivationPathFormat):
            return
        if isinstance(value, Bip32Error.UnknownVersion):
            _UniffiConverterString.check_lower(value.version)
            return
        if isinstance(value, Bip32Error.WrongExtendedKeyLength):
            _UniffiConverterUInt32.check_lower(value.length)
            return
        if isinstance(value, Bip32Error.Base58):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, Bip32Error.Hex):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, Bip32Error.InvalidPublicKeyHexLength):
            _UniffiConverterUInt32.check_lower(value.length)
            return
        if isinstance(value, Bip32Error.UnknownError):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, Bip32Error.CannotDeriveFromHardenedKey):
            buf.write_i32(1)
        if isinstance(value, Bip32Error.Secp256k1):
            buf.write_i32(2)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, Bip32Error.InvalidChildNumber):
            buf.write_i32(3)
            _UniffiConverterUInt32.write(value.child_number, buf)
        if isinstance(value, Bip32Error.InvalidChildNumberFormat):
            buf.write_i32(4)
        if isinstance(value, Bip32Error.InvalidDerivationPathFormat):
            buf.write_i32(5)
        if isinstance(value, Bip32Error.UnknownVersion):
            buf.write_i32(6)
            _UniffiConverterString.write(value.version, buf)
        if isinstance(value, Bip32Error.WrongExtendedKeyLength):
            buf.write_i32(7)
            _UniffiConverterUInt32.write(value.length, buf)
        if isinstance(value, Bip32Error.Base58):
            buf.write_i32(8)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, Bip32Error.Hex):
            buf.write_i32(9)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, Bip32Error.InvalidPublicKeyHexLength):
            buf.write_i32(10)
            _UniffiConverterUInt32.write(value.length, buf)
        if isinstance(value, Bip32Error.UnknownError):
            buf.write_i32(11)
            _UniffiConverterString.write(value.error_message, buf)


# Bip39Error
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class Bip39Error(Exception):
    pass

_UniffiTempBip39Error = Bip39Error

class Bip39Error:  # type: ignore
    class BadWordCount(_UniffiTempBip39Error):
        def __init__(self, word_count):
            super().__init__(", ".join([
                "word_count={!r}".format(word_count),
            ]))
            self.word_count = word_count

        def __repr__(self):
            return "Bip39Error.BadWordCount({})".format(str(self))
    _UniffiTempBip39Error.BadWordCount = BadWordCount # type: ignore
    class UnknownWord(_UniffiTempBip39Error):
        def __init__(self, index):
            super().__init__(", ".join([
                "index={!r}".format(index),
            ]))
            self.index = index

        def __repr__(self):
            return "Bip39Error.UnknownWord({})".format(str(self))
    _UniffiTempBip39Error.UnknownWord = UnknownWord # type: ignore
    class BadEntropyBitCount(_UniffiTempBip39Error):
        def __init__(self, bit_count):
            super().__init__(", ".join([
                "bit_count={!r}".format(bit_count),
            ]))
            self.bit_count = bit_count

        def __repr__(self):
            return "Bip39Error.BadEntropyBitCount({})".format(str(self))
    _UniffiTempBip39Error.BadEntropyBitCount = BadEntropyBitCount # type: ignore
    class InvalidChecksum(_UniffiTempBip39Error):
        def __init__(self):
            pass

        def __repr__(self):
            return "Bip39Error.InvalidChecksum({})".format(str(self))
    _UniffiTempBip39Error.InvalidChecksum = InvalidChecksum # type: ignore
    class AmbiguousLanguages(_UniffiTempBip39Error):
        def __init__(self, languages):
            super().__init__(", ".join([
                "languages={!r}".format(languages),
            ]))
            self.languages = languages

        def __repr__(self):
            return "Bip39Error.AmbiguousLanguages({})".format(str(self))
    _UniffiTempBip39Error.AmbiguousLanguages = AmbiguousLanguages # type: ignore

Bip39Error = _UniffiTempBip39Error # type: ignore
del _UniffiTempBip39Error


class _UniffiConverterTypeBip39Error(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return Bip39Error.BadWordCount(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return Bip39Error.UnknownWord(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 3:
            return Bip39Error.BadEntropyBitCount(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 4:
            return Bip39Error.InvalidChecksum(
            )
        if variant == 5:
            return Bip39Error.AmbiguousLanguages(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, Bip39Error.BadWordCount):
            _UniffiConverterUInt64.check_lower(value.word_count)
            return
        if isinstance(value, Bip39Error.UnknownWord):
            _UniffiConverterUInt64.check_lower(value.index)
            return
        if isinstance(value, Bip39Error.BadEntropyBitCount):
            _UniffiConverterUInt64.check_lower(value.bit_count)
            return
        if isinstance(value, Bip39Error.InvalidChecksum):
            return
        if isinstance(value, Bip39Error.AmbiguousLanguages):
            _UniffiConverterString.check_lower(value.languages)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, Bip39Error.BadWordCount):
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.word_count, buf)
        if isinstance(value, Bip39Error.UnknownWord):
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.index, buf)
        if isinstance(value, Bip39Error.BadEntropyBitCount):
            buf.write_i32(3)
            _UniffiConverterUInt64.write(value.bit_count, buf)
        if isinstance(value, Bip39Error.InvalidChecksum):
            buf.write_i32(4)
        if isinstance(value, Bip39Error.AmbiguousLanguages):
            buf.write_i32(5)
            _UniffiConverterString.write(value.languages, buf)


# CalculateFeeError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class CalculateFeeError(Exception):
    pass

_UniffiTempCalculateFeeError = CalculateFeeError

class CalculateFeeError:  # type: ignore
    class MissingTxOut(_UniffiTempCalculateFeeError):
        def __init__(self, out_points):
            super().__init__(", ".join([
                "out_points={!r}".format(out_points),
            ]))
            self.out_points = out_points

        def __repr__(self):
            return "CalculateFeeError.MissingTxOut({})".format(str(self))
    _UniffiTempCalculateFeeError.MissingTxOut = MissingTxOut # type: ignore
    class NegativeFee(_UniffiTempCalculateFeeError):
        def __init__(self, amount):
            super().__init__(", ".join([
                "amount={!r}".format(amount),
            ]))
            self.amount = amount

        def __repr__(self):
            return "CalculateFeeError.NegativeFee({})".format(str(self))
    _UniffiTempCalculateFeeError.NegativeFee = NegativeFee # type: ignore

CalculateFeeError = _UniffiTempCalculateFeeError # type: ignore
del _UniffiTempCalculateFeeError


class _UniffiConverterTypeCalculateFeeError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CalculateFeeError.MissingTxOut(
                _UniffiConverterSequenceTypeOutPoint.read(buf),
            )
        if variant == 2:
            return CalculateFeeError.NegativeFee(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, CalculateFeeError.MissingTxOut):
            _UniffiConverterSequenceTypeOutPoint.check_lower(value.out_points)
            return
        if isinstance(value, CalculateFeeError.NegativeFee):
            _UniffiConverterString.check_lower(value.amount)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, CalculateFeeError.MissingTxOut):
            buf.write_i32(1)
            _UniffiConverterSequenceTypeOutPoint.write(value.out_points, buf)
        if isinstance(value, CalculateFeeError.NegativeFee):
            buf.write_i32(2)
            _UniffiConverterString.write(value.amount, buf)


# CannotConnectError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class CannotConnectError(Exception):
    pass

_UniffiTempCannotConnectError = CannotConnectError

class CannotConnectError:  # type: ignore
    class Include(_UniffiTempCannotConnectError):
        def __init__(self, height):
            super().__init__(", ".join([
                "height={!r}".format(height),
            ]))
            self.height = height

        def __repr__(self):
            return "CannotConnectError.Include({})".format(str(self))
    _UniffiTempCannotConnectError.Include = Include # type: ignore

CannotConnectError = _UniffiTempCannotConnectError # type: ignore
del _UniffiTempCannotConnectError


class _UniffiConverterTypeCannotConnectError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CannotConnectError.Include(
                _UniffiConverterUInt32.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, CannotConnectError.Include):
            _UniffiConverterUInt32.check_lower(value.height)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, CannotConnectError.Include):
            buf.write_i32(1)
            _UniffiConverterUInt32.write(value.height, buf)





class ChainPosition:
    def __init__(self):
        raise RuntimeError("ChainPosition cannot be instantiated directly")

    # Each enum variant is a nested class of the enum itself.
    class CONFIRMED:
        confirmation_block_time: "ConfirmationBlockTime"

        def __init__(self,confirmation_block_time: "ConfirmationBlockTime"):
            self.confirmation_block_time = confirmation_block_time

        def __str__(self):
            return "ChainPosition.CONFIRMED(confirmation_block_time={})".format(self.confirmation_block_time)

        def __eq__(self, other):
            if not other.is_confirmed():
                return False
            if self.confirmation_block_time != other.confirmation_block_time:
                return False
            return True
    
    class UNCONFIRMED:
        timestamp: "int"

        def __init__(self,timestamp: "int"):
            self.timestamp = timestamp

        def __str__(self):
            return "ChainPosition.UNCONFIRMED(timestamp={})".format(self.timestamp)

        def __eq__(self, other):
            if not other.is_unconfirmed():
                return False
            if self.timestamp != other.timestamp:
                return False
            return True
    
    

    # For each variant, we have an `is_NAME` method for easily checking
    # whether an instance is that variant.
    def is_confirmed(self) -> bool:
        return isinstance(self, ChainPosition.CONFIRMED)
    def is_unconfirmed(self) -> bool:
        return isinstance(self, ChainPosition.UNCONFIRMED)
    

# Now, a little trick - we make each nested variant class be a subclass of the main
# enum class, so that method calls and instance checks etc will work intuitively.
# We might be able to do this a little more neatly with a metaclass, but this'll do.
ChainPosition.CONFIRMED = type("ChainPosition.CONFIRMED", (ChainPosition.CONFIRMED, ChainPosition,), {})  # type: ignore
ChainPosition.UNCONFIRMED = type("ChainPosition.UNCONFIRMED", (ChainPosition.UNCONFIRMED, ChainPosition,), {})  # type: ignore




class _UniffiConverterTypeChainPosition(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ChainPosition.CONFIRMED(
                _UniffiConverterTypeConfirmationBlockTime.read(buf),
            )
        if variant == 2:
            return ChainPosition.UNCONFIRMED(
                _UniffiConverterUInt64.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value.is_confirmed():
            _UniffiConverterTypeConfirmationBlockTime.check_lower(value.confirmation_block_time)
            return
        if value.is_unconfirmed():
            _UniffiConverterUInt64.check_lower(value.timestamp)
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value.is_confirmed():
            buf.write_i32(1)
            _UniffiConverterTypeConfirmationBlockTime.write(value.confirmation_block_time, buf)
        if value.is_unconfirmed():
            buf.write_i32(2)
            _UniffiConverterUInt64.write(value.timestamp, buf)







class ChangeSpendPolicy(enum.Enum):
    CHANGE_ALLOWED = 0
    
    ONLY_CHANGE = 1
    
    CHANGE_FORBIDDEN = 2
    


class _UniffiConverterTypeChangeSpendPolicy(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ChangeSpendPolicy.CHANGE_ALLOWED
        if variant == 2:
            return ChangeSpendPolicy.ONLY_CHANGE
        if variant == 3:
            return ChangeSpendPolicy.CHANGE_FORBIDDEN
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == ChangeSpendPolicy.CHANGE_ALLOWED:
            return
        if value == ChangeSpendPolicy.ONLY_CHANGE:
            return
        if value == ChangeSpendPolicy.CHANGE_FORBIDDEN:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == ChangeSpendPolicy.CHANGE_ALLOWED:
            buf.write_i32(1)
        if value == ChangeSpendPolicy.ONLY_CHANGE:
            buf.write_i32(2)
        if value == ChangeSpendPolicy.CHANGE_FORBIDDEN:
            buf.write_i32(3)




# CreateTxError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class CreateTxError(Exception):
    pass

_UniffiTempCreateTxError = CreateTxError

class CreateTxError:  # type: ignore
    class Descriptor(_UniffiTempCreateTxError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "CreateTxError.Descriptor({})".format(str(self))
    _UniffiTempCreateTxError.Descriptor = Descriptor # type: ignore
    class Policy(_UniffiTempCreateTxError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "CreateTxError.Policy({})".format(str(self))
    _UniffiTempCreateTxError.Policy = Policy # type: ignore
    class SpendingPolicyRequired(_UniffiTempCreateTxError):
        def __init__(self, kind):
            super().__init__(", ".join([
                "kind={!r}".format(kind),
            ]))
            self.kind = kind

        def __repr__(self):
            return "CreateTxError.SpendingPolicyRequired({})".format(str(self))
    _UniffiTempCreateTxError.SpendingPolicyRequired = SpendingPolicyRequired # type: ignore
    class Version0(_UniffiTempCreateTxError):
        def __init__(self):
            pass

        def __repr__(self):
            return "CreateTxError.Version0({})".format(str(self))
    _UniffiTempCreateTxError.Version0 = Version0 # type: ignore
    class Version1Csv(_UniffiTempCreateTxError):
        def __init__(self):
            pass

        def __repr__(self):
            return "CreateTxError.Version1Csv({})".format(str(self))
    _UniffiTempCreateTxError.Version1Csv = Version1Csv # type: ignore
    class LockTime(_UniffiTempCreateTxError):
        def __init__(self, requested, required):
            super().__init__(", ".join([
                "requested={!r}".format(requested),
                "required={!r}".format(required),
            ]))
            self.requested = requested
            self.required = required

        def __repr__(self):
            return "CreateTxError.LockTime({})".format(str(self))
    _UniffiTempCreateTxError.LockTime = LockTime # type: ignore
    class RbfSequenceCsv(_UniffiTempCreateTxError):
        def __init__(self, sequence, csv):
            super().__init__(", ".join([
                "sequence={!r}".format(sequence),
                "csv={!r}".format(csv),
            ]))
            self.sequence = sequence
            self.csv = csv

        def __repr__(self):
            return "CreateTxError.RbfSequenceCsv({})".format(str(self))
    _UniffiTempCreateTxError.RbfSequenceCsv = RbfSequenceCsv # type: ignore
    class FeeTooLow(_UniffiTempCreateTxError):
        def __init__(self, required):
            super().__init__(", ".join([
                "required={!r}".format(required),
            ]))
            self.required = required

        def __repr__(self):
            return "CreateTxError.FeeTooLow({})".format(str(self))
    _UniffiTempCreateTxError.FeeTooLow = FeeTooLow # type: ignore
    class FeeRateTooLow(_UniffiTempCreateTxError):
        def __init__(self, required):
            super().__init__(", ".join([
                "required={!r}".format(required),
            ]))
            self.required = required

        def __repr__(self):
            return "CreateTxError.FeeRateTooLow({})".format(str(self))
    _UniffiTempCreateTxError.FeeRateTooLow = FeeRateTooLow # type: ignore
    class NoUtxosSelected(_UniffiTempCreateTxError):
        def __init__(self):
            pass

        def __repr__(self):
            return "CreateTxError.NoUtxosSelected({})".format(str(self))
    _UniffiTempCreateTxError.NoUtxosSelected = NoUtxosSelected # type: ignore
    class OutputBelowDustLimit(_UniffiTempCreateTxError):
        def __init__(self, index):
            super().__init__(", ".join([
                "index={!r}".format(index),
            ]))
            self.index = index

        def __repr__(self):
            return "CreateTxError.OutputBelowDustLimit({})".format(str(self))
    _UniffiTempCreateTxError.OutputBelowDustLimit = OutputBelowDustLimit # type: ignore
    class ChangePolicyDescriptor(_UniffiTempCreateTxError):
        def __init__(self):
            pass

        def __repr__(self):
            return "CreateTxError.ChangePolicyDescriptor({})".format(str(self))
    _UniffiTempCreateTxError.ChangePolicyDescriptor = ChangePolicyDescriptor # type: ignore
    class CoinSelection(_UniffiTempCreateTxError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "CreateTxError.CoinSelection({})".format(str(self))
    _UniffiTempCreateTxError.CoinSelection = CoinSelection # type: ignore
    class InsufficientFunds(_UniffiTempCreateTxError):
        def __init__(self, needed, available):
            super().__init__(", ".join([
                "needed={!r}".format(needed),
                "available={!r}".format(available),
            ]))
            self.needed = needed
            self.available = available

        def __repr__(self):
            return "CreateTxError.InsufficientFunds({})".format(str(self))
    _UniffiTempCreateTxError.InsufficientFunds = InsufficientFunds # type: ignore
    class NoRecipients(_UniffiTempCreateTxError):
        def __init__(self):
            pass

        def __repr__(self):
            return "CreateTxError.NoRecipients({})".format(str(self))
    _UniffiTempCreateTxError.NoRecipients = NoRecipients # type: ignore
    class Psbt(_UniffiTempCreateTxError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "CreateTxError.Psbt({})".format(str(self))
    _UniffiTempCreateTxError.Psbt = Psbt # type: ignore
    class MissingKeyOrigin(_UniffiTempCreateTxError):
        def __init__(self, key):
            super().__init__(", ".join([
                "key={!r}".format(key),
            ]))
            self.key = key

        def __repr__(self):
            return "CreateTxError.MissingKeyOrigin({})".format(str(self))
    _UniffiTempCreateTxError.MissingKeyOrigin = MissingKeyOrigin # type: ignore
    class UnknownUtxo(_UniffiTempCreateTxError):
        def __init__(self, outpoint):
            super().__init__(", ".join([
                "outpoint={!r}".format(outpoint),
            ]))
            self.outpoint = outpoint

        def __repr__(self):
            return "CreateTxError.UnknownUtxo({})".format(str(self))
    _UniffiTempCreateTxError.UnknownUtxo = UnknownUtxo # type: ignore
    class MissingNonWitnessUtxo(_UniffiTempCreateTxError):
        def __init__(self, outpoint):
            super().__init__(", ".join([
                "outpoint={!r}".format(outpoint),
            ]))
            self.outpoint = outpoint

        def __repr__(self):
            return "CreateTxError.MissingNonWitnessUtxo({})".format(str(self))
    _UniffiTempCreateTxError.MissingNonWitnessUtxo = MissingNonWitnessUtxo # type: ignore
    class MiniscriptPsbt(_UniffiTempCreateTxError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "CreateTxError.MiniscriptPsbt({})".format(str(self))
    _UniffiTempCreateTxError.MiniscriptPsbt = MiniscriptPsbt # type: ignore

CreateTxError = _UniffiTempCreateTxError # type: ignore
del _UniffiTempCreateTxError


class _UniffiConverterTypeCreateTxError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CreateTxError.Descriptor(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return CreateTxError.Policy(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return CreateTxError.SpendingPolicyRequired(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return CreateTxError.Version0(
            )
        if variant == 5:
            return CreateTxError.Version1Csv(
            )
        if variant == 6:
            return CreateTxError.LockTime(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return CreateTxError.RbfSequenceCsv(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return CreateTxError.FeeTooLow(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return CreateTxError.FeeRateTooLow(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return CreateTxError.NoUtxosSelected(
            )
        if variant == 11:
            return CreateTxError.OutputBelowDustLimit(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 12:
            return CreateTxError.ChangePolicyDescriptor(
            )
        if variant == 13:
            return CreateTxError.CoinSelection(
                _UniffiConverterString.read(buf),
            )
        if variant == 14:
            return CreateTxError.InsufficientFunds(
                _UniffiConverterUInt64.read(buf),
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 15:
            return CreateTxError.NoRecipients(
            )
        if variant == 16:
            return CreateTxError.Psbt(
                _UniffiConverterString.read(buf),
            )
        if variant == 17:
            return CreateTxError.MissingKeyOrigin(
                _UniffiConverterString.read(buf),
            )
        if variant == 18:
            return CreateTxError.UnknownUtxo(
                _UniffiConverterString.read(buf),
            )
        if variant == 19:
            return CreateTxError.MissingNonWitnessUtxo(
                _UniffiConverterString.read(buf),
            )
        if variant == 20:
            return CreateTxError.MiniscriptPsbt(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, CreateTxError.Descriptor):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, CreateTxError.Policy):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, CreateTxError.SpendingPolicyRequired):
            _UniffiConverterString.check_lower(value.kind)
            return
        if isinstance(value, CreateTxError.Version0):
            return
        if isinstance(value, CreateTxError.Version1Csv):
            return
        if isinstance(value, CreateTxError.LockTime):
            _UniffiConverterString.check_lower(value.requested)
            _UniffiConverterString.check_lower(value.required)
            return
        if isinstance(value, CreateTxError.RbfSequenceCsv):
            _UniffiConverterString.check_lower(value.sequence)
            _UniffiConverterString.check_lower(value.csv)
            return
        if isinstance(value, CreateTxError.FeeTooLow):
            _UniffiConverterString.check_lower(value.required)
            return
        if isinstance(value, CreateTxError.FeeRateTooLow):
            _UniffiConverterString.check_lower(value.required)
            return
        if isinstance(value, CreateTxError.NoUtxosSelected):
            return
        if isinstance(value, CreateTxError.OutputBelowDustLimit):
            _UniffiConverterUInt64.check_lower(value.index)
            return
        if isinstance(value, CreateTxError.ChangePolicyDescriptor):
            return
        if isinstance(value, CreateTxError.CoinSelection):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, CreateTxError.InsufficientFunds):
            _UniffiConverterUInt64.check_lower(value.needed)
            _UniffiConverterUInt64.check_lower(value.available)
            return
        if isinstance(value, CreateTxError.NoRecipients):
            return
        if isinstance(value, CreateTxError.Psbt):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, CreateTxError.MissingKeyOrigin):
            _UniffiConverterString.check_lower(value.key)
            return
        if isinstance(value, CreateTxError.UnknownUtxo):
            _UniffiConverterString.check_lower(value.outpoint)
            return
        if isinstance(value, CreateTxError.MissingNonWitnessUtxo):
            _UniffiConverterString.check_lower(value.outpoint)
            return
        if isinstance(value, CreateTxError.MiniscriptPsbt):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, CreateTxError.Descriptor):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, CreateTxError.Policy):
            buf.write_i32(2)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, CreateTxError.SpendingPolicyRequired):
            buf.write_i32(3)
            _UniffiConverterString.write(value.kind, buf)
        if isinstance(value, CreateTxError.Version0):
            buf.write_i32(4)
        if isinstance(value, CreateTxError.Version1Csv):
            buf.write_i32(5)
        if isinstance(value, CreateTxError.LockTime):
            buf.write_i32(6)
            _UniffiConverterString.write(value.requested, buf)
            _UniffiConverterString.write(value.required, buf)
        if isinstance(value, CreateTxError.RbfSequenceCsv):
            buf.write_i32(7)
            _UniffiConverterString.write(value.sequence, buf)
            _UniffiConverterString.write(value.csv, buf)
        if isinstance(value, CreateTxError.FeeTooLow):
            buf.write_i32(8)
            _UniffiConverterString.write(value.required, buf)
        if isinstance(value, CreateTxError.FeeRateTooLow):
            buf.write_i32(9)
            _UniffiConverterString.write(value.required, buf)
        if isinstance(value, CreateTxError.NoUtxosSelected):
            buf.write_i32(10)
        if isinstance(value, CreateTxError.OutputBelowDustLimit):
            buf.write_i32(11)
            _UniffiConverterUInt64.write(value.index, buf)
        if isinstance(value, CreateTxError.ChangePolicyDescriptor):
            buf.write_i32(12)
        if isinstance(value, CreateTxError.CoinSelection):
            buf.write_i32(13)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, CreateTxError.InsufficientFunds):
            buf.write_i32(14)
            _UniffiConverterUInt64.write(value.needed, buf)
            _UniffiConverterUInt64.write(value.available, buf)
        if isinstance(value, CreateTxError.NoRecipients):
            buf.write_i32(15)
        if isinstance(value, CreateTxError.Psbt):
            buf.write_i32(16)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, CreateTxError.MissingKeyOrigin):
            buf.write_i32(17)
            _UniffiConverterString.write(value.key, buf)
        if isinstance(value, CreateTxError.UnknownUtxo):
            buf.write_i32(18)
            _UniffiConverterString.write(value.outpoint, buf)
        if isinstance(value, CreateTxError.MissingNonWitnessUtxo):
            buf.write_i32(19)
            _UniffiConverterString.write(value.outpoint, buf)
        if isinstance(value, CreateTxError.MiniscriptPsbt):
            buf.write_i32(20)
            _UniffiConverterString.write(value.error_message, buf)


# CreateWithPersistError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class CreateWithPersistError(Exception):
    pass

_UniffiTempCreateWithPersistError = CreateWithPersistError

class CreateWithPersistError:  # type: ignore
    class Persist(_UniffiTempCreateWithPersistError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "CreateWithPersistError.Persist({})".format(str(self))
    _UniffiTempCreateWithPersistError.Persist = Persist # type: ignore
    class DataAlreadyExists(_UniffiTempCreateWithPersistError):
        def __init__(self):
            pass

        def __repr__(self):
            return "CreateWithPersistError.DataAlreadyExists({})".format(str(self))
    _UniffiTempCreateWithPersistError.DataAlreadyExists = DataAlreadyExists # type: ignore
    class Descriptor(_UniffiTempCreateWithPersistError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "CreateWithPersistError.Descriptor({})".format(str(self))
    _UniffiTempCreateWithPersistError.Descriptor = Descriptor # type: ignore

CreateWithPersistError = _UniffiTempCreateWithPersistError # type: ignore
del _UniffiTempCreateWithPersistError


class _UniffiConverterTypeCreateWithPersistError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return CreateWithPersistError.Persist(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return CreateWithPersistError.DataAlreadyExists(
            )
        if variant == 3:
            return CreateWithPersistError.Descriptor(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, CreateWithPersistError.Persist):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, CreateWithPersistError.DataAlreadyExists):
            return
        if isinstance(value, CreateWithPersistError.Descriptor):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, CreateWithPersistError.Persist):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, CreateWithPersistError.DataAlreadyExists):
            buf.write_i32(2)
        if isinstance(value, CreateWithPersistError.Descriptor):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)


# DescriptorError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class DescriptorError(Exception):
    pass

_UniffiTempDescriptorError = DescriptorError

class DescriptorError:  # type: ignore
    class InvalidHdKeyPath(_UniffiTempDescriptorError):
        def __init__(self):
            pass

        def __repr__(self):
            return "DescriptorError.InvalidHdKeyPath({})".format(str(self))
    _UniffiTempDescriptorError.InvalidHdKeyPath = InvalidHdKeyPath # type: ignore
    class InvalidDescriptorChecksum(_UniffiTempDescriptorError):
        def __init__(self):
            pass

        def __repr__(self):
            return "DescriptorError.InvalidDescriptorChecksum({})".format(str(self))
    _UniffiTempDescriptorError.InvalidDescriptorChecksum = InvalidDescriptorChecksum # type: ignore
    class HardenedDerivationXpub(_UniffiTempDescriptorError):
        def __init__(self):
            pass

        def __repr__(self):
            return "DescriptorError.HardenedDerivationXpub({})".format(str(self))
    _UniffiTempDescriptorError.HardenedDerivationXpub = HardenedDerivationXpub # type: ignore
    class MultiPath(_UniffiTempDescriptorError):
        def __init__(self):
            pass

        def __repr__(self):
            return "DescriptorError.MultiPath({})".format(str(self))
    _UniffiTempDescriptorError.MultiPath = MultiPath # type: ignore
    class Key(_UniffiTempDescriptorError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "DescriptorError.Key({})".format(str(self))
    _UniffiTempDescriptorError.Key = Key # type: ignore
    class Policy(_UniffiTempDescriptorError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "DescriptorError.Policy({})".format(str(self))
    _UniffiTempDescriptorError.Policy = Policy # type: ignore
    class InvalidDescriptorCharacter(_UniffiTempDescriptorError):
        def __init__(self, char):
            super().__init__(", ".join([
                "char={!r}".format(char),
            ]))
            self.char = char

        def __repr__(self):
            return "DescriptorError.InvalidDescriptorCharacter({})".format(str(self))
    _UniffiTempDescriptorError.InvalidDescriptorCharacter = InvalidDescriptorCharacter # type: ignore
    class Bip32(_UniffiTempDescriptorError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "DescriptorError.Bip32({})".format(str(self))
    _UniffiTempDescriptorError.Bip32 = Bip32 # type: ignore
    class Base58(_UniffiTempDescriptorError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "DescriptorError.Base58({})".format(str(self))
    _UniffiTempDescriptorError.Base58 = Base58 # type: ignore
    class Pk(_UniffiTempDescriptorError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "DescriptorError.Pk({})".format(str(self))
    _UniffiTempDescriptorError.Pk = Pk # type: ignore
    class Miniscript(_UniffiTempDescriptorError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "DescriptorError.Miniscript({})".format(str(self))
    _UniffiTempDescriptorError.Miniscript = Miniscript # type: ignore
    class Hex(_UniffiTempDescriptorError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "DescriptorError.Hex({})".format(str(self))
    _UniffiTempDescriptorError.Hex = Hex # type: ignore
    class ExternalAndInternalAreTheSame(_UniffiTempDescriptorError):
        def __init__(self):
            pass

        def __repr__(self):
            return "DescriptorError.ExternalAndInternalAreTheSame({})".format(str(self))
    _UniffiTempDescriptorError.ExternalAndInternalAreTheSame = ExternalAndInternalAreTheSame # type: ignore

DescriptorError = _UniffiTempDescriptorError # type: ignore
del _UniffiTempDescriptorError


class _UniffiConverterTypeDescriptorError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DescriptorError.InvalidHdKeyPath(
            )
        if variant == 2:
            return DescriptorError.InvalidDescriptorChecksum(
            )
        if variant == 3:
            return DescriptorError.HardenedDerivationXpub(
            )
        if variant == 4:
            return DescriptorError.MultiPath(
            )
        if variant == 5:
            return DescriptorError.Key(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return DescriptorError.Policy(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return DescriptorError.InvalidDescriptorCharacter(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return DescriptorError.Bip32(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return DescriptorError.Base58(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return DescriptorError.Pk(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return DescriptorError.Miniscript(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return DescriptorError.Hex(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return DescriptorError.ExternalAndInternalAreTheSame(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, DescriptorError.InvalidHdKeyPath):
            return
        if isinstance(value, DescriptorError.InvalidDescriptorChecksum):
            return
        if isinstance(value, DescriptorError.HardenedDerivationXpub):
            return
        if isinstance(value, DescriptorError.MultiPath):
            return
        if isinstance(value, DescriptorError.Key):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.Policy):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.InvalidDescriptorCharacter):
            _UniffiConverterString.check_lower(value.char)
            return
        if isinstance(value, DescriptorError.Bip32):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.Base58):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.Pk):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.Miniscript):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.Hex):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorError.ExternalAndInternalAreTheSame):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, DescriptorError.InvalidHdKeyPath):
            buf.write_i32(1)
        if isinstance(value, DescriptorError.InvalidDescriptorChecksum):
            buf.write_i32(2)
        if isinstance(value, DescriptorError.HardenedDerivationXpub):
            buf.write_i32(3)
        if isinstance(value, DescriptorError.MultiPath):
            buf.write_i32(4)
        if isinstance(value, DescriptorError.Key):
            buf.write_i32(5)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.Policy):
            buf.write_i32(6)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.InvalidDescriptorCharacter):
            buf.write_i32(7)
            _UniffiConverterString.write(value.char, buf)
        if isinstance(value, DescriptorError.Bip32):
            buf.write_i32(8)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.Base58):
            buf.write_i32(9)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.Pk):
            buf.write_i32(10)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.Miniscript):
            buf.write_i32(11)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.Hex):
            buf.write_i32(12)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorError.ExternalAndInternalAreTheSame):
            buf.write_i32(13)


# DescriptorKeyError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class DescriptorKeyError(Exception):
    pass

_UniffiTempDescriptorKeyError = DescriptorKeyError

class DescriptorKeyError:  # type: ignore
    class Parse(_UniffiTempDescriptorKeyError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "DescriptorKeyError.Parse({})".format(str(self))
    _UniffiTempDescriptorKeyError.Parse = Parse # type: ignore
    class InvalidKeyType(_UniffiTempDescriptorKeyError):
        def __init__(self):
            pass

        def __repr__(self):
            return "DescriptorKeyError.InvalidKeyType({})".format(str(self))
    _UniffiTempDescriptorKeyError.InvalidKeyType = InvalidKeyType # type: ignore
    class Bip32(_UniffiTempDescriptorKeyError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "DescriptorKeyError.Bip32({})".format(str(self))
    _UniffiTempDescriptorKeyError.Bip32 = Bip32 # type: ignore

DescriptorKeyError = _UniffiTempDescriptorKeyError # type: ignore
del _UniffiTempDescriptorKeyError


class _UniffiConverterTypeDescriptorKeyError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return DescriptorKeyError.Parse(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return DescriptorKeyError.InvalidKeyType(
            )
        if variant == 3:
            return DescriptorKeyError.Bip32(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, DescriptorKeyError.Parse):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, DescriptorKeyError.InvalidKeyType):
            return
        if isinstance(value, DescriptorKeyError.Bip32):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, DescriptorKeyError.Parse):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, DescriptorKeyError.InvalidKeyType):
            buf.write_i32(2)
        if isinstance(value, DescriptorKeyError.Bip32):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)


# ElectrumError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ElectrumError(Exception):
    pass

_UniffiTempElectrumError = ElectrumError

class ElectrumError:  # type: ignore
    class IoError(_UniffiTempElectrumError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "ElectrumError.IoError({})".format(str(self))
    _UniffiTempElectrumError.IoError = IoError # type: ignore
    class Json(_UniffiTempElectrumError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "ElectrumError.Json({})".format(str(self))
    _UniffiTempElectrumError.Json = Json # type: ignore
    class Hex(_UniffiTempElectrumError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "ElectrumError.Hex({})".format(str(self))
    _UniffiTempElectrumError.Hex = Hex # type: ignore
    class Protocol(_UniffiTempElectrumError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "ElectrumError.Protocol({})".format(str(self))
    _UniffiTempElectrumError.Protocol = Protocol # type: ignore
    class Bitcoin(_UniffiTempElectrumError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "ElectrumError.Bitcoin({})".format(str(self))
    _UniffiTempElectrumError.Bitcoin = Bitcoin # type: ignore
    class AlreadySubscribed(_UniffiTempElectrumError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ElectrumError.AlreadySubscribed({})".format(str(self))
    _UniffiTempElectrumError.AlreadySubscribed = AlreadySubscribed # type: ignore
    class NotSubscribed(_UniffiTempElectrumError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ElectrumError.NotSubscribed({})".format(str(self))
    _UniffiTempElectrumError.NotSubscribed = NotSubscribed # type: ignore
    class InvalidResponse(_UniffiTempElectrumError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "ElectrumError.InvalidResponse({})".format(str(self))
    _UniffiTempElectrumError.InvalidResponse = InvalidResponse # type: ignore
    class Message(_UniffiTempElectrumError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "ElectrumError.Message({})".format(str(self))
    _UniffiTempElectrumError.Message = Message # type: ignore
    class InvalidDnsNameError(_UniffiTempElectrumError):
        def __init__(self, domain):
            super().__init__(", ".join([
                "domain={!r}".format(domain),
            ]))
            self.domain = domain

        def __repr__(self):
            return "ElectrumError.InvalidDnsNameError({})".format(str(self))
    _UniffiTempElectrumError.InvalidDnsNameError = InvalidDnsNameError # type: ignore
    class MissingDomain(_UniffiTempElectrumError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ElectrumError.MissingDomain({})".format(str(self))
    _UniffiTempElectrumError.MissingDomain = MissingDomain # type: ignore
    class AllAttemptsErrored(_UniffiTempElectrumError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ElectrumError.AllAttemptsErrored({})".format(str(self))
    _UniffiTempElectrumError.AllAttemptsErrored = AllAttemptsErrored # type: ignore
    class SharedIoError(_UniffiTempElectrumError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "ElectrumError.SharedIoError({})".format(str(self))
    _UniffiTempElectrumError.SharedIoError = SharedIoError # type: ignore
    class CouldntLockReader(_UniffiTempElectrumError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ElectrumError.CouldntLockReader({})".format(str(self))
    _UniffiTempElectrumError.CouldntLockReader = CouldntLockReader # type: ignore
    class Mpsc(_UniffiTempElectrumError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ElectrumError.Mpsc({})".format(str(self))
    _UniffiTempElectrumError.Mpsc = Mpsc # type: ignore
    class CouldNotCreateConnection(_UniffiTempElectrumError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "ElectrumError.CouldNotCreateConnection({})".format(str(self))
    _UniffiTempElectrumError.CouldNotCreateConnection = CouldNotCreateConnection # type: ignore
    class RequestAlreadyConsumed(_UniffiTempElectrumError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ElectrumError.RequestAlreadyConsumed({})".format(str(self))
    _UniffiTempElectrumError.RequestAlreadyConsumed = RequestAlreadyConsumed # type: ignore

ElectrumError = _UniffiTempElectrumError # type: ignore
del _UniffiTempElectrumError


class _UniffiConverterTypeElectrumError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ElectrumError.IoError(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return ElectrumError.Json(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return ElectrumError.Hex(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return ElectrumError.Protocol(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return ElectrumError.Bitcoin(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return ElectrumError.AlreadySubscribed(
            )
        if variant == 7:
            return ElectrumError.NotSubscribed(
            )
        if variant == 8:
            return ElectrumError.InvalidResponse(
                _UniffiConverterString.read(buf),
            )
        if variant == 9:
            return ElectrumError.Message(
                _UniffiConverterString.read(buf),
            )
        if variant == 10:
            return ElectrumError.InvalidDnsNameError(
                _UniffiConverterString.read(buf),
            )
        if variant == 11:
            return ElectrumError.MissingDomain(
            )
        if variant == 12:
            return ElectrumError.AllAttemptsErrored(
            )
        if variant == 13:
            return ElectrumError.SharedIoError(
                _UniffiConverterString.read(buf),
            )
        if variant == 14:
            return ElectrumError.CouldntLockReader(
            )
        if variant == 15:
            return ElectrumError.Mpsc(
            )
        if variant == 16:
            return ElectrumError.CouldNotCreateConnection(
                _UniffiConverterString.read(buf),
            )
        if variant == 17:
            return ElectrumError.RequestAlreadyConsumed(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ElectrumError.IoError):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.Json):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.Hex):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.Protocol):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.Bitcoin):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.AlreadySubscribed):
            return
        if isinstance(value, ElectrumError.NotSubscribed):
            return
        if isinstance(value, ElectrumError.InvalidResponse):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.Message):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.InvalidDnsNameError):
            _UniffiConverterString.check_lower(value.domain)
            return
        if isinstance(value, ElectrumError.MissingDomain):
            return
        if isinstance(value, ElectrumError.AllAttemptsErrored):
            return
        if isinstance(value, ElectrumError.SharedIoError):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.CouldntLockReader):
            return
        if isinstance(value, ElectrumError.Mpsc):
            return
        if isinstance(value, ElectrumError.CouldNotCreateConnection):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, ElectrumError.RequestAlreadyConsumed):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ElectrumError.IoError):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.Json):
            buf.write_i32(2)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.Hex):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.Protocol):
            buf.write_i32(4)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.Bitcoin):
            buf.write_i32(5)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.AlreadySubscribed):
            buf.write_i32(6)
        if isinstance(value, ElectrumError.NotSubscribed):
            buf.write_i32(7)
        if isinstance(value, ElectrumError.InvalidResponse):
            buf.write_i32(8)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.Message):
            buf.write_i32(9)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.InvalidDnsNameError):
            buf.write_i32(10)
            _UniffiConverterString.write(value.domain, buf)
        if isinstance(value, ElectrumError.MissingDomain):
            buf.write_i32(11)
        if isinstance(value, ElectrumError.AllAttemptsErrored):
            buf.write_i32(12)
        if isinstance(value, ElectrumError.SharedIoError):
            buf.write_i32(13)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.CouldntLockReader):
            buf.write_i32(14)
        if isinstance(value, ElectrumError.Mpsc):
            buf.write_i32(15)
        if isinstance(value, ElectrumError.CouldNotCreateConnection):
            buf.write_i32(16)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, ElectrumError.RequestAlreadyConsumed):
            buf.write_i32(17)


# EsploraError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class EsploraError(Exception):
    pass

_UniffiTempEsploraError = EsploraError

class EsploraError:  # type: ignore
    class Minreq(_UniffiTempEsploraError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "EsploraError.Minreq({})".format(str(self))
    _UniffiTempEsploraError.Minreq = Minreq # type: ignore
    class HttpResponse(_UniffiTempEsploraError):
        def __init__(self, status, error_message):
            super().__init__(", ".join([
                "status={!r}".format(status),
                "error_message={!r}".format(error_message),
            ]))
            self.status = status
            self.error_message = error_message

        def __repr__(self):
            return "EsploraError.HttpResponse({})".format(str(self))
    _UniffiTempEsploraError.HttpResponse = HttpResponse # type: ignore
    class Parsing(_UniffiTempEsploraError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "EsploraError.Parsing({})".format(str(self))
    _UniffiTempEsploraError.Parsing = Parsing # type: ignore
    class StatusCode(_UniffiTempEsploraError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "EsploraError.StatusCode({})".format(str(self))
    _UniffiTempEsploraError.StatusCode = StatusCode # type: ignore
    class BitcoinEncoding(_UniffiTempEsploraError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "EsploraError.BitcoinEncoding({})".format(str(self))
    _UniffiTempEsploraError.BitcoinEncoding = BitcoinEncoding # type: ignore
    class HexToArray(_UniffiTempEsploraError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "EsploraError.HexToArray({})".format(str(self))
    _UniffiTempEsploraError.HexToArray = HexToArray # type: ignore
    class HexToBytes(_UniffiTempEsploraError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "EsploraError.HexToBytes({})".format(str(self))
    _UniffiTempEsploraError.HexToBytes = HexToBytes # type: ignore
    class TransactionNotFound(_UniffiTempEsploraError):
        def __init__(self):
            pass

        def __repr__(self):
            return "EsploraError.TransactionNotFound({})".format(str(self))
    _UniffiTempEsploraError.TransactionNotFound = TransactionNotFound # type: ignore
    class HeaderHeightNotFound(_UniffiTempEsploraError):
        def __init__(self, height):
            super().__init__(", ".join([
                "height={!r}".format(height),
            ]))
            self.height = height

        def __repr__(self):
            return "EsploraError.HeaderHeightNotFound({})".format(str(self))
    _UniffiTempEsploraError.HeaderHeightNotFound = HeaderHeightNotFound # type: ignore
    class HeaderHashNotFound(_UniffiTempEsploraError):
        def __init__(self):
            pass

        def __repr__(self):
            return "EsploraError.HeaderHashNotFound({})".format(str(self))
    _UniffiTempEsploraError.HeaderHashNotFound = HeaderHashNotFound # type: ignore
    class InvalidHttpHeaderName(_UniffiTempEsploraError):
        def __init__(self, name):
            super().__init__(", ".join([
                "name={!r}".format(name),
            ]))
            self.name = name

        def __repr__(self):
            return "EsploraError.InvalidHttpHeaderName({})".format(str(self))
    _UniffiTempEsploraError.InvalidHttpHeaderName = InvalidHttpHeaderName # type: ignore
    class InvalidHttpHeaderValue(_UniffiTempEsploraError):
        def __init__(self, value):
            super().__init__(", ".join([
                "value={!r}".format(value),
            ]))
            self.value = value

        def __repr__(self):
            return "EsploraError.InvalidHttpHeaderValue({})".format(str(self))
    _UniffiTempEsploraError.InvalidHttpHeaderValue = InvalidHttpHeaderValue # type: ignore
    class RequestAlreadyConsumed(_UniffiTempEsploraError):
        def __init__(self):
            pass

        def __repr__(self):
            return "EsploraError.RequestAlreadyConsumed({})".format(str(self))
    _UniffiTempEsploraError.RequestAlreadyConsumed = RequestAlreadyConsumed # type: ignore

EsploraError = _UniffiTempEsploraError # type: ignore
del _UniffiTempEsploraError


class _UniffiConverterTypeEsploraError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return EsploraError.Minreq(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return EsploraError.HttpResponse(
                _UniffiConverterUInt16.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return EsploraError.Parsing(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return EsploraError.StatusCode(
                _UniffiConverterString.read(buf),
            )
        if variant == 5:
            return EsploraError.BitcoinEncoding(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return EsploraError.HexToArray(
                _UniffiConverterString.read(buf),
            )
        if variant == 7:
            return EsploraError.HexToBytes(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return EsploraError.TransactionNotFound(
            )
        if variant == 9:
            return EsploraError.HeaderHeightNotFound(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 10:
            return EsploraError.HeaderHashNotFound(
            )
        if variant == 11:
            return EsploraError.InvalidHttpHeaderName(
                _UniffiConverterString.read(buf),
            )
        if variant == 12:
            return EsploraError.InvalidHttpHeaderValue(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return EsploraError.RequestAlreadyConsumed(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, EsploraError.Minreq):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.HttpResponse):
            _UniffiConverterUInt16.check_lower(value.status)
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.Parsing):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.StatusCode):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.BitcoinEncoding):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.HexToArray):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.HexToBytes):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, EsploraError.TransactionNotFound):
            return
        if isinstance(value, EsploraError.HeaderHeightNotFound):
            _UniffiConverterUInt32.check_lower(value.height)
            return
        if isinstance(value, EsploraError.HeaderHashNotFound):
            return
        if isinstance(value, EsploraError.InvalidHttpHeaderName):
            _UniffiConverterString.check_lower(value.name)
            return
        if isinstance(value, EsploraError.InvalidHttpHeaderValue):
            _UniffiConverterString.check_lower(value.value)
            return
        if isinstance(value, EsploraError.RequestAlreadyConsumed):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, EsploraError.Minreq):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.HttpResponse):
            buf.write_i32(2)
            _UniffiConverterUInt16.write(value.status, buf)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.Parsing):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.StatusCode):
            buf.write_i32(4)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.BitcoinEncoding):
            buf.write_i32(5)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.HexToArray):
            buf.write_i32(6)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.HexToBytes):
            buf.write_i32(7)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, EsploraError.TransactionNotFound):
            buf.write_i32(8)
        if isinstance(value, EsploraError.HeaderHeightNotFound):
            buf.write_i32(9)
            _UniffiConverterUInt32.write(value.height, buf)
        if isinstance(value, EsploraError.HeaderHashNotFound):
            buf.write_i32(10)
        if isinstance(value, EsploraError.InvalidHttpHeaderName):
            buf.write_i32(11)
            _UniffiConverterString.write(value.name, buf)
        if isinstance(value, EsploraError.InvalidHttpHeaderValue):
            buf.write_i32(12)
            _UniffiConverterString.write(value.value, buf)
        if isinstance(value, EsploraError.RequestAlreadyConsumed):
            buf.write_i32(13)


# ExtractTxError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class ExtractTxError(Exception):
    pass

_UniffiTempExtractTxError = ExtractTxError

class ExtractTxError:  # type: ignore
    class AbsurdFeeRate(_UniffiTempExtractTxError):
        def __init__(self, fee_rate):
            super().__init__(", ".join([
                "fee_rate={!r}".format(fee_rate),
            ]))
            self.fee_rate = fee_rate

        def __repr__(self):
            return "ExtractTxError.AbsurdFeeRate({})".format(str(self))
    _UniffiTempExtractTxError.AbsurdFeeRate = AbsurdFeeRate # type: ignore
    class MissingInputValue(_UniffiTempExtractTxError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ExtractTxError.MissingInputValue({})".format(str(self))
    _UniffiTempExtractTxError.MissingInputValue = MissingInputValue # type: ignore
    class SendingTooMuch(_UniffiTempExtractTxError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ExtractTxError.SendingTooMuch({})".format(str(self))
    _UniffiTempExtractTxError.SendingTooMuch = SendingTooMuch # type: ignore
    class OtherExtractTxErr(_UniffiTempExtractTxError):
        def __init__(self):
            pass

        def __repr__(self):
            return "ExtractTxError.OtherExtractTxErr({})".format(str(self))
    _UniffiTempExtractTxError.OtherExtractTxErr = OtherExtractTxErr # type: ignore

ExtractTxError = _UniffiTempExtractTxError # type: ignore
del _UniffiTempExtractTxError


class _UniffiConverterTypeExtractTxError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return ExtractTxError.AbsurdFeeRate(
                _UniffiConverterUInt64.read(buf),
            )
        if variant == 2:
            return ExtractTxError.MissingInputValue(
            )
        if variant == 3:
            return ExtractTxError.SendingTooMuch(
            )
        if variant == 4:
            return ExtractTxError.OtherExtractTxErr(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, ExtractTxError.AbsurdFeeRate):
            _UniffiConverterUInt64.check_lower(value.fee_rate)
            return
        if isinstance(value, ExtractTxError.MissingInputValue):
            return
        if isinstance(value, ExtractTxError.SendingTooMuch):
            return
        if isinstance(value, ExtractTxError.OtherExtractTxErr):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, ExtractTxError.AbsurdFeeRate):
            buf.write_i32(1)
            _UniffiConverterUInt64.write(value.fee_rate, buf)
        if isinstance(value, ExtractTxError.MissingInputValue):
            buf.write_i32(2)
        if isinstance(value, ExtractTxError.SendingTooMuch):
            buf.write_i32(3)
        if isinstance(value, ExtractTxError.OtherExtractTxErr):
            buf.write_i32(4)


# FromScriptError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class FromScriptError(Exception):
    pass

_UniffiTempFromScriptError = FromScriptError

class FromScriptError:  # type: ignore
    class UnrecognizedScript(_UniffiTempFromScriptError):
        def __init__(self):
            pass

        def __repr__(self):
            return "FromScriptError.UnrecognizedScript({})".format(str(self))
    _UniffiTempFromScriptError.UnrecognizedScript = UnrecognizedScript # type: ignore
    class WitnessProgram(_UniffiTempFromScriptError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "FromScriptError.WitnessProgram({})".format(str(self))
    _UniffiTempFromScriptError.WitnessProgram = WitnessProgram # type: ignore
    class WitnessVersion(_UniffiTempFromScriptError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "FromScriptError.WitnessVersion({})".format(str(self))
    _UniffiTempFromScriptError.WitnessVersion = WitnessVersion # type: ignore
    class OtherFromScriptErr(_UniffiTempFromScriptError):
        def __init__(self):
            pass

        def __repr__(self):
            return "FromScriptError.OtherFromScriptErr({})".format(str(self))
    _UniffiTempFromScriptError.OtherFromScriptErr = OtherFromScriptErr # type: ignore

FromScriptError = _UniffiTempFromScriptError # type: ignore
del _UniffiTempFromScriptError


class _UniffiConverterTypeFromScriptError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return FromScriptError.UnrecognizedScript(
            )
        if variant == 2:
            return FromScriptError.WitnessProgram(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return FromScriptError.WitnessVersion(
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return FromScriptError.OtherFromScriptErr(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, FromScriptError.UnrecognizedScript):
            return
        if isinstance(value, FromScriptError.WitnessProgram):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, FromScriptError.WitnessVersion):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, FromScriptError.OtherFromScriptErr):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, FromScriptError.UnrecognizedScript):
            buf.write_i32(1)
        if isinstance(value, FromScriptError.WitnessProgram):
            buf.write_i32(2)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, FromScriptError.WitnessVersion):
            buf.write_i32(3)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, FromScriptError.OtherFromScriptErr):
            buf.write_i32(4)





class KeychainKind(enum.Enum):
    EXTERNAL = 0
    
    INTERNAL = 1
    


class _UniffiConverterTypeKeychainKind(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return KeychainKind.EXTERNAL
        if variant == 2:
            return KeychainKind.INTERNAL
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == KeychainKind.EXTERNAL:
            return
        if value == KeychainKind.INTERNAL:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == KeychainKind.EXTERNAL:
            buf.write_i32(1)
        if value == KeychainKind.INTERNAL:
            buf.write_i32(2)




# LoadWithPersistError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class LoadWithPersistError(Exception):
    pass

_UniffiTempLoadWithPersistError = LoadWithPersistError

class LoadWithPersistError:  # type: ignore
    class Persist(_UniffiTempLoadWithPersistError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "LoadWithPersistError.Persist({})".format(str(self))
    _UniffiTempLoadWithPersistError.Persist = Persist # type: ignore
    class InvalidChangeSet(_UniffiTempLoadWithPersistError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "LoadWithPersistError.InvalidChangeSet({})".format(str(self))
    _UniffiTempLoadWithPersistError.InvalidChangeSet = InvalidChangeSet # type: ignore
    class CouldNotLoad(_UniffiTempLoadWithPersistError):
        def __init__(self):
            pass

        def __repr__(self):
            return "LoadWithPersistError.CouldNotLoad({})".format(str(self))
    _UniffiTempLoadWithPersistError.CouldNotLoad = CouldNotLoad # type: ignore

LoadWithPersistError = _UniffiTempLoadWithPersistError # type: ignore
del _UniffiTempLoadWithPersistError


class _UniffiConverterTypeLoadWithPersistError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return LoadWithPersistError.Persist(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return LoadWithPersistError.InvalidChangeSet(
                _UniffiConverterString.read(buf),
            )
        if variant == 3:
            return LoadWithPersistError.CouldNotLoad(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, LoadWithPersistError.Persist):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, LoadWithPersistError.InvalidChangeSet):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, LoadWithPersistError.CouldNotLoad):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, LoadWithPersistError.Persist):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, LoadWithPersistError.InvalidChangeSet):
            buf.write_i32(2)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, LoadWithPersistError.CouldNotLoad):
            buf.write_i32(3)


# PersistenceError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class PersistenceError(Exception):
    pass

_UniffiTempPersistenceError = PersistenceError

class PersistenceError:  # type: ignore
    class Write(_UniffiTempPersistenceError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "PersistenceError.Write({})".format(str(self))
    _UniffiTempPersistenceError.Write = Write # type: ignore

PersistenceError = _UniffiTempPersistenceError # type: ignore
del _UniffiTempPersistenceError


class _UniffiConverterTypePersistenceError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PersistenceError.Write(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, PersistenceError.Write):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, PersistenceError.Write):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)


# PsbtError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class PsbtError(Exception):
    pass

_UniffiTempPsbtError = PsbtError

class PsbtError:  # type: ignore
    class InvalidMagic(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.InvalidMagic({})".format(str(self))
    _UniffiTempPsbtError.InvalidMagic = InvalidMagic # type: ignore
    class MissingUtxo(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.MissingUtxo({})".format(str(self))
    _UniffiTempPsbtError.MissingUtxo = MissingUtxo # type: ignore
    class InvalidSeparator(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.InvalidSeparator({})".format(str(self))
    _UniffiTempPsbtError.InvalidSeparator = InvalidSeparator # type: ignore
    class PsbtUtxoOutOfBounds(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.PsbtUtxoOutOfBounds({})".format(str(self))
    _UniffiTempPsbtError.PsbtUtxoOutOfBounds = PsbtUtxoOutOfBounds # type: ignore
    class InvalidKey(_UniffiTempPsbtError):
        def __init__(self, key):
            super().__init__(", ".join([
                "key={!r}".format(key),
            ]))
            self.key = key

        def __repr__(self):
            return "PsbtError.InvalidKey({})".format(str(self))
    _UniffiTempPsbtError.InvalidKey = InvalidKey # type: ignore
    class InvalidProprietaryKey(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.InvalidProprietaryKey({})".format(str(self))
    _UniffiTempPsbtError.InvalidProprietaryKey = InvalidProprietaryKey # type: ignore
    class DuplicateKey(_UniffiTempPsbtError):
        def __init__(self, key):
            super().__init__(", ".join([
                "key={!r}".format(key),
            ]))
            self.key = key

        def __repr__(self):
            return "PsbtError.DuplicateKey({})".format(str(self))
    _UniffiTempPsbtError.DuplicateKey = DuplicateKey # type: ignore
    class UnsignedTxHasScriptSigs(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.UnsignedTxHasScriptSigs({})".format(str(self))
    _UniffiTempPsbtError.UnsignedTxHasScriptSigs = UnsignedTxHasScriptSigs # type: ignore
    class UnsignedTxHasScriptWitnesses(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.UnsignedTxHasScriptWitnesses({})".format(str(self))
    _UniffiTempPsbtError.UnsignedTxHasScriptWitnesses = UnsignedTxHasScriptWitnesses # type: ignore
    class MustHaveUnsignedTx(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.MustHaveUnsignedTx({})".format(str(self))
    _UniffiTempPsbtError.MustHaveUnsignedTx = MustHaveUnsignedTx # type: ignore
    class NoMorePairs(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.NoMorePairs({})".format(str(self))
    _UniffiTempPsbtError.NoMorePairs = NoMorePairs # type: ignore
    class UnexpectedUnsignedTx(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.UnexpectedUnsignedTx({})".format(str(self))
    _UniffiTempPsbtError.UnexpectedUnsignedTx = UnexpectedUnsignedTx # type: ignore
    class NonStandardSighashType(_UniffiTempPsbtError):
        def __init__(self, sighash):
            super().__init__(", ".join([
                "sighash={!r}".format(sighash),
            ]))
            self.sighash = sighash

        def __repr__(self):
            return "PsbtError.NonStandardSighashType({})".format(str(self))
    _UniffiTempPsbtError.NonStandardSighashType = NonStandardSighashType # type: ignore
    class InvalidHash(_UniffiTempPsbtError):
        def __init__(self, hash):
            super().__init__(", ".join([
                "hash={!r}".format(hash),
            ]))
            self.hash = hash

        def __repr__(self):
            return "PsbtError.InvalidHash({})".format(str(self))
    _UniffiTempPsbtError.InvalidHash = InvalidHash # type: ignore
    class InvalidPreimageHashPair(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.InvalidPreimageHashPair({})".format(str(self))
    _UniffiTempPsbtError.InvalidPreimageHashPair = InvalidPreimageHashPair # type: ignore
    class CombineInconsistentKeySources(_UniffiTempPsbtError):
        def __init__(self, xpub):
            super().__init__(", ".join([
                "xpub={!r}".format(xpub),
            ]))
            self.xpub = xpub

        def __repr__(self):
            return "PsbtError.CombineInconsistentKeySources({})".format(str(self))
    _UniffiTempPsbtError.CombineInconsistentKeySources = CombineInconsistentKeySources # type: ignore
    class ConsensusEncoding(_UniffiTempPsbtError):
        def __init__(self, encoding_error):
            super().__init__(", ".join([
                "encoding_error={!r}".format(encoding_error),
            ]))
            self.encoding_error = encoding_error

        def __repr__(self):
            return "PsbtError.ConsensusEncoding({})".format(str(self))
    _UniffiTempPsbtError.ConsensusEncoding = ConsensusEncoding # type: ignore
    class NegativeFee(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.NegativeFee({})".format(str(self))
    _UniffiTempPsbtError.NegativeFee = NegativeFee # type: ignore
    class FeeOverflow(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.FeeOverflow({})".format(str(self))
    _UniffiTempPsbtError.FeeOverflow = FeeOverflow # type: ignore
    class InvalidPublicKey(_UniffiTempPsbtError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "PsbtError.InvalidPublicKey({})".format(str(self))
    _UniffiTempPsbtError.InvalidPublicKey = InvalidPublicKey # type: ignore
    class InvalidSecp256k1PublicKey(_UniffiTempPsbtError):
        def __init__(self, secp256k1_error):
            super().__init__(", ".join([
                "secp256k1_error={!r}".format(secp256k1_error),
            ]))
            self.secp256k1_error = secp256k1_error

        def __repr__(self):
            return "PsbtError.InvalidSecp256k1PublicKey({})".format(str(self))
    _UniffiTempPsbtError.InvalidSecp256k1PublicKey = InvalidSecp256k1PublicKey # type: ignore
    class InvalidXOnlyPublicKey(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.InvalidXOnlyPublicKey({})".format(str(self))
    _UniffiTempPsbtError.InvalidXOnlyPublicKey = InvalidXOnlyPublicKey # type: ignore
    class InvalidEcdsaSignature(_UniffiTempPsbtError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "PsbtError.InvalidEcdsaSignature({})".format(str(self))
    _UniffiTempPsbtError.InvalidEcdsaSignature = InvalidEcdsaSignature # type: ignore
    class InvalidTaprootSignature(_UniffiTempPsbtError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "PsbtError.InvalidTaprootSignature({})".format(str(self))
    _UniffiTempPsbtError.InvalidTaprootSignature = InvalidTaprootSignature # type: ignore
    class InvalidControlBlock(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.InvalidControlBlock({})".format(str(self))
    _UniffiTempPsbtError.InvalidControlBlock = InvalidControlBlock # type: ignore
    class InvalidLeafVersion(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.InvalidLeafVersion({})".format(str(self))
    _UniffiTempPsbtError.InvalidLeafVersion = InvalidLeafVersion # type: ignore
    class Taproot(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.Taproot({})".format(str(self))
    _UniffiTempPsbtError.Taproot = Taproot # type: ignore
    class TapTree(_UniffiTempPsbtError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "PsbtError.TapTree({})".format(str(self))
    _UniffiTempPsbtError.TapTree = TapTree # type: ignore
    class XPubKey(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.XPubKey({})".format(str(self))
    _UniffiTempPsbtError.XPubKey = XPubKey # type: ignore
    class Version(_UniffiTempPsbtError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "PsbtError.Version({})".format(str(self))
    _UniffiTempPsbtError.Version = Version # type: ignore
    class PartialDataConsumption(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.PartialDataConsumption({})".format(str(self))
    _UniffiTempPsbtError.PartialDataConsumption = PartialDataConsumption # type: ignore
    class Io(_UniffiTempPsbtError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "PsbtError.Io({})".format(str(self))
    _UniffiTempPsbtError.Io = Io # type: ignore
    class OtherPsbtErr(_UniffiTempPsbtError):
        def __init__(self):
            pass

        def __repr__(self):
            return "PsbtError.OtherPsbtErr({})".format(str(self))
    _UniffiTempPsbtError.OtherPsbtErr = OtherPsbtErr # type: ignore

PsbtError = _UniffiTempPsbtError # type: ignore
del _UniffiTempPsbtError


class _UniffiConverterTypePsbtError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PsbtError.InvalidMagic(
            )
        if variant == 2:
            return PsbtError.MissingUtxo(
            )
        if variant == 3:
            return PsbtError.InvalidSeparator(
            )
        if variant == 4:
            return PsbtError.PsbtUtxoOutOfBounds(
            )
        if variant == 5:
            return PsbtError.InvalidKey(
                _UniffiConverterString.read(buf),
            )
        if variant == 6:
            return PsbtError.InvalidProprietaryKey(
            )
        if variant == 7:
            return PsbtError.DuplicateKey(
                _UniffiConverterString.read(buf),
            )
        if variant == 8:
            return PsbtError.UnsignedTxHasScriptSigs(
            )
        if variant == 9:
            return PsbtError.UnsignedTxHasScriptWitnesses(
            )
        if variant == 10:
            return PsbtError.MustHaveUnsignedTx(
            )
        if variant == 11:
            return PsbtError.NoMorePairs(
            )
        if variant == 12:
            return PsbtError.UnexpectedUnsignedTx(
            )
        if variant == 13:
            return PsbtError.NonStandardSighashType(
                _UniffiConverterUInt32.read(buf),
            )
        if variant == 14:
            return PsbtError.InvalidHash(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return PsbtError.InvalidPreimageHashPair(
            )
        if variant == 16:
            return PsbtError.CombineInconsistentKeySources(
                _UniffiConverterString.read(buf),
            )
        if variant == 17:
            return PsbtError.ConsensusEncoding(
                _UniffiConverterString.read(buf),
            )
        if variant == 18:
            return PsbtError.NegativeFee(
            )
        if variant == 19:
            return PsbtError.FeeOverflow(
            )
        if variant == 20:
            return PsbtError.InvalidPublicKey(
                _UniffiConverterString.read(buf),
            )
        if variant == 21:
            return PsbtError.InvalidSecp256k1PublicKey(
                _UniffiConverterString.read(buf),
            )
        if variant == 22:
            return PsbtError.InvalidXOnlyPublicKey(
            )
        if variant == 23:
            return PsbtError.InvalidEcdsaSignature(
                _UniffiConverterString.read(buf),
            )
        if variant == 24:
            return PsbtError.InvalidTaprootSignature(
                _UniffiConverterString.read(buf),
            )
        if variant == 25:
            return PsbtError.InvalidControlBlock(
            )
        if variant == 26:
            return PsbtError.InvalidLeafVersion(
            )
        if variant == 27:
            return PsbtError.Taproot(
            )
        if variant == 28:
            return PsbtError.TapTree(
                _UniffiConverterString.read(buf),
            )
        if variant == 29:
            return PsbtError.XPubKey(
            )
        if variant == 30:
            return PsbtError.Version(
                _UniffiConverterString.read(buf),
            )
        if variant == 31:
            return PsbtError.PartialDataConsumption(
            )
        if variant == 32:
            return PsbtError.Io(
                _UniffiConverterString.read(buf),
            )
        if variant == 33:
            return PsbtError.OtherPsbtErr(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, PsbtError.InvalidMagic):
            return
        if isinstance(value, PsbtError.MissingUtxo):
            return
        if isinstance(value, PsbtError.InvalidSeparator):
            return
        if isinstance(value, PsbtError.PsbtUtxoOutOfBounds):
            return
        if isinstance(value, PsbtError.InvalidKey):
            _UniffiConverterString.check_lower(value.key)
            return
        if isinstance(value, PsbtError.InvalidProprietaryKey):
            return
        if isinstance(value, PsbtError.DuplicateKey):
            _UniffiConverterString.check_lower(value.key)
            return
        if isinstance(value, PsbtError.UnsignedTxHasScriptSigs):
            return
        if isinstance(value, PsbtError.UnsignedTxHasScriptWitnesses):
            return
        if isinstance(value, PsbtError.MustHaveUnsignedTx):
            return
        if isinstance(value, PsbtError.NoMorePairs):
            return
        if isinstance(value, PsbtError.UnexpectedUnsignedTx):
            return
        if isinstance(value, PsbtError.NonStandardSighashType):
            _UniffiConverterUInt32.check_lower(value.sighash)
            return
        if isinstance(value, PsbtError.InvalidHash):
            _UniffiConverterString.check_lower(value.hash)
            return
        if isinstance(value, PsbtError.InvalidPreimageHashPair):
            return
        if isinstance(value, PsbtError.CombineInconsistentKeySources):
            _UniffiConverterString.check_lower(value.xpub)
            return
        if isinstance(value, PsbtError.ConsensusEncoding):
            _UniffiConverterString.check_lower(value.encoding_error)
            return
        if isinstance(value, PsbtError.NegativeFee):
            return
        if isinstance(value, PsbtError.FeeOverflow):
            return
        if isinstance(value, PsbtError.InvalidPublicKey):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, PsbtError.InvalidSecp256k1PublicKey):
            _UniffiConverterString.check_lower(value.secp256k1_error)
            return
        if isinstance(value, PsbtError.InvalidXOnlyPublicKey):
            return
        if isinstance(value, PsbtError.InvalidEcdsaSignature):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, PsbtError.InvalidTaprootSignature):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, PsbtError.InvalidControlBlock):
            return
        if isinstance(value, PsbtError.InvalidLeafVersion):
            return
        if isinstance(value, PsbtError.Taproot):
            return
        if isinstance(value, PsbtError.TapTree):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, PsbtError.XPubKey):
            return
        if isinstance(value, PsbtError.Version):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, PsbtError.PartialDataConsumption):
            return
        if isinstance(value, PsbtError.Io):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, PsbtError.OtherPsbtErr):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, PsbtError.InvalidMagic):
            buf.write_i32(1)
        if isinstance(value, PsbtError.MissingUtxo):
            buf.write_i32(2)
        if isinstance(value, PsbtError.InvalidSeparator):
            buf.write_i32(3)
        if isinstance(value, PsbtError.PsbtUtxoOutOfBounds):
            buf.write_i32(4)
        if isinstance(value, PsbtError.InvalidKey):
            buf.write_i32(5)
            _UniffiConverterString.write(value.key, buf)
        if isinstance(value, PsbtError.InvalidProprietaryKey):
            buf.write_i32(6)
        if isinstance(value, PsbtError.DuplicateKey):
            buf.write_i32(7)
            _UniffiConverterString.write(value.key, buf)
        if isinstance(value, PsbtError.UnsignedTxHasScriptSigs):
            buf.write_i32(8)
        if isinstance(value, PsbtError.UnsignedTxHasScriptWitnesses):
            buf.write_i32(9)
        if isinstance(value, PsbtError.MustHaveUnsignedTx):
            buf.write_i32(10)
        if isinstance(value, PsbtError.NoMorePairs):
            buf.write_i32(11)
        if isinstance(value, PsbtError.UnexpectedUnsignedTx):
            buf.write_i32(12)
        if isinstance(value, PsbtError.NonStandardSighashType):
            buf.write_i32(13)
            _UniffiConverterUInt32.write(value.sighash, buf)
        if isinstance(value, PsbtError.InvalidHash):
            buf.write_i32(14)
            _UniffiConverterString.write(value.hash, buf)
        if isinstance(value, PsbtError.InvalidPreimageHashPair):
            buf.write_i32(15)
        if isinstance(value, PsbtError.CombineInconsistentKeySources):
            buf.write_i32(16)
            _UniffiConverterString.write(value.xpub, buf)
        if isinstance(value, PsbtError.ConsensusEncoding):
            buf.write_i32(17)
            _UniffiConverterString.write(value.encoding_error, buf)
        if isinstance(value, PsbtError.NegativeFee):
            buf.write_i32(18)
        if isinstance(value, PsbtError.FeeOverflow):
            buf.write_i32(19)
        if isinstance(value, PsbtError.InvalidPublicKey):
            buf.write_i32(20)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, PsbtError.InvalidSecp256k1PublicKey):
            buf.write_i32(21)
            _UniffiConverterString.write(value.secp256k1_error, buf)
        if isinstance(value, PsbtError.InvalidXOnlyPublicKey):
            buf.write_i32(22)
        if isinstance(value, PsbtError.InvalidEcdsaSignature):
            buf.write_i32(23)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, PsbtError.InvalidTaprootSignature):
            buf.write_i32(24)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, PsbtError.InvalidControlBlock):
            buf.write_i32(25)
        if isinstance(value, PsbtError.InvalidLeafVersion):
            buf.write_i32(26)
        if isinstance(value, PsbtError.Taproot):
            buf.write_i32(27)
        if isinstance(value, PsbtError.TapTree):
            buf.write_i32(28)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, PsbtError.XPubKey):
            buf.write_i32(29)
        if isinstance(value, PsbtError.Version):
            buf.write_i32(30)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, PsbtError.PartialDataConsumption):
            buf.write_i32(31)
        if isinstance(value, PsbtError.Io):
            buf.write_i32(32)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, PsbtError.OtherPsbtErr):
            buf.write_i32(33)


# PsbtParseError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class PsbtParseError(Exception):
    pass

_UniffiTempPsbtParseError = PsbtParseError

class PsbtParseError:  # type: ignore
    class PsbtEncoding(_UniffiTempPsbtParseError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "PsbtParseError.PsbtEncoding({})".format(str(self))
    _UniffiTempPsbtParseError.PsbtEncoding = PsbtEncoding # type: ignore
    class Base64Encoding(_UniffiTempPsbtParseError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "PsbtParseError.Base64Encoding({})".format(str(self))
    _UniffiTempPsbtParseError.Base64Encoding = Base64Encoding # type: ignore

PsbtParseError = _UniffiTempPsbtParseError # type: ignore
del _UniffiTempPsbtParseError


class _UniffiConverterTypePsbtParseError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return PsbtParseError.PsbtEncoding(
                _UniffiConverterString.read(buf),
            )
        if variant == 2:
            return PsbtParseError.Base64Encoding(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, PsbtParseError.PsbtEncoding):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, PsbtParseError.Base64Encoding):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, PsbtParseError.PsbtEncoding):
            buf.write_i32(1)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, PsbtParseError.Base64Encoding):
            buf.write_i32(2)
            _UniffiConverterString.write(value.error_message, buf)


# RequestBuilderError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class RequestBuilderError(Exception):
    pass

_UniffiTempRequestBuilderError = RequestBuilderError

class RequestBuilderError:  # type: ignore
    class RequestAlreadyConsumed(_UniffiTempRequestBuilderError):
        def __init__(self):
            pass

        def __repr__(self):
            return "RequestBuilderError.RequestAlreadyConsumed({})".format(str(self))
    _UniffiTempRequestBuilderError.RequestAlreadyConsumed = RequestAlreadyConsumed # type: ignore

RequestBuilderError = _UniffiTempRequestBuilderError # type: ignore
del _UniffiTempRequestBuilderError


class _UniffiConverterTypeRequestBuilderError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return RequestBuilderError.RequestAlreadyConsumed(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, RequestBuilderError.RequestAlreadyConsumed):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, RequestBuilderError.RequestAlreadyConsumed):
            buf.write_i32(1)


# SignerError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SignerError(Exception):
    pass

_UniffiTempSignerError = SignerError

class SignerError:  # type: ignore
    class MissingKey(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.MissingKey({})".format(str(self))
    _UniffiTempSignerError.MissingKey = MissingKey # type: ignore
    class InvalidKey(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.InvalidKey({})".format(str(self))
    _UniffiTempSignerError.InvalidKey = InvalidKey # type: ignore
    class UserCanceled(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.UserCanceled({})".format(str(self))
    _UniffiTempSignerError.UserCanceled = UserCanceled # type: ignore
    class InputIndexOutOfRange(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.InputIndexOutOfRange({})".format(str(self))
    _UniffiTempSignerError.InputIndexOutOfRange = InputIndexOutOfRange # type: ignore
    class MissingNonWitnessUtxo(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.MissingNonWitnessUtxo({})".format(str(self))
    _UniffiTempSignerError.MissingNonWitnessUtxo = MissingNonWitnessUtxo # type: ignore
    class InvalidNonWitnessUtxo(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.InvalidNonWitnessUtxo({})".format(str(self))
    _UniffiTempSignerError.InvalidNonWitnessUtxo = InvalidNonWitnessUtxo # type: ignore
    class MissingWitnessUtxo(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.MissingWitnessUtxo({})".format(str(self))
    _UniffiTempSignerError.MissingWitnessUtxo = MissingWitnessUtxo # type: ignore
    class MissingWitnessScript(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.MissingWitnessScript({})".format(str(self))
    _UniffiTempSignerError.MissingWitnessScript = MissingWitnessScript # type: ignore
    class MissingHdKeypath(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.MissingHdKeypath({})".format(str(self))
    _UniffiTempSignerError.MissingHdKeypath = MissingHdKeypath # type: ignore
    class NonStandardSighash(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.NonStandardSighash({})".format(str(self))
    _UniffiTempSignerError.NonStandardSighash = NonStandardSighash # type: ignore
    class InvalidSighash(_UniffiTempSignerError):
        def __init__(self):
            pass

        def __repr__(self):
            return "SignerError.InvalidSighash({})".format(str(self))
    _UniffiTempSignerError.InvalidSighash = InvalidSighash # type: ignore
    class SighashP2wpkh(_UniffiTempSignerError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "SignerError.SighashP2wpkh({})".format(str(self))
    _UniffiTempSignerError.SighashP2wpkh = SighashP2wpkh # type: ignore
    class SighashTaproot(_UniffiTempSignerError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "SignerError.SighashTaproot({})".format(str(self))
    _UniffiTempSignerError.SighashTaproot = SighashTaproot # type: ignore
    class TxInputsIndexError(_UniffiTempSignerError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "SignerError.TxInputsIndexError({})".format(str(self))
    _UniffiTempSignerError.TxInputsIndexError = TxInputsIndexError # type: ignore
    class MiniscriptPsbt(_UniffiTempSignerError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "SignerError.MiniscriptPsbt({})".format(str(self))
    _UniffiTempSignerError.MiniscriptPsbt = MiniscriptPsbt # type: ignore
    class External(_UniffiTempSignerError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "SignerError.External({})".format(str(self))
    _UniffiTempSignerError.External = External # type: ignore
    class Psbt(_UniffiTempSignerError):
        def __init__(self, error_message):
            super().__init__(", ".join([
                "error_message={!r}".format(error_message),
            ]))
            self.error_message = error_message

        def __repr__(self):
            return "SignerError.Psbt({})".format(str(self))
    _UniffiTempSignerError.Psbt = Psbt # type: ignore

SignerError = _UniffiTempSignerError # type: ignore
del _UniffiTempSignerError


class _UniffiConverterTypeSignerError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SignerError.MissingKey(
            )
        if variant == 2:
            return SignerError.InvalidKey(
            )
        if variant == 3:
            return SignerError.UserCanceled(
            )
        if variant == 4:
            return SignerError.InputIndexOutOfRange(
            )
        if variant == 5:
            return SignerError.MissingNonWitnessUtxo(
            )
        if variant == 6:
            return SignerError.InvalidNonWitnessUtxo(
            )
        if variant == 7:
            return SignerError.MissingWitnessUtxo(
            )
        if variant == 8:
            return SignerError.MissingWitnessScript(
            )
        if variant == 9:
            return SignerError.MissingHdKeypath(
            )
        if variant == 10:
            return SignerError.NonStandardSighash(
            )
        if variant == 11:
            return SignerError.InvalidSighash(
            )
        if variant == 12:
            return SignerError.SighashP2wpkh(
                _UniffiConverterString.read(buf),
            )
        if variant == 13:
            return SignerError.SighashTaproot(
                _UniffiConverterString.read(buf),
            )
        if variant == 14:
            return SignerError.TxInputsIndexError(
                _UniffiConverterString.read(buf),
            )
        if variant == 15:
            return SignerError.MiniscriptPsbt(
                _UniffiConverterString.read(buf),
            )
        if variant == 16:
            return SignerError.External(
                _UniffiConverterString.read(buf),
            )
        if variant == 17:
            return SignerError.Psbt(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SignerError.MissingKey):
            return
        if isinstance(value, SignerError.InvalidKey):
            return
        if isinstance(value, SignerError.UserCanceled):
            return
        if isinstance(value, SignerError.InputIndexOutOfRange):
            return
        if isinstance(value, SignerError.MissingNonWitnessUtxo):
            return
        if isinstance(value, SignerError.InvalidNonWitnessUtxo):
            return
        if isinstance(value, SignerError.MissingWitnessUtxo):
            return
        if isinstance(value, SignerError.MissingWitnessScript):
            return
        if isinstance(value, SignerError.MissingHdKeypath):
            return
        if isinstance(value, SignerError.NonStandardSighash):
            return
        if isinstance(value, SignerError.InvalidSighash):
            return
        if isinstance(value, SignerError.SighashP2wpkh):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, SignerError.SighashTaproot):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, SignerError.TxInputsIndexError):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, SignerError.MiniscriptPsbt):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, SignerError.External):
            _UniffiConverterString.check_lower(value.error_message)
            return
        if isinstance(value, SignerError.Psbt):
            _UniffiConverterString.check_lower(value.error_message)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SignerError.MissingKey):
            buf.write_i32(1)
        if isinstance(value, SignerError.InvalidKey):
            buf.write_i32(2)
        if isinstance(value, SignerError.UserCanceled):
            buf.write_i32(3)
        if isinstance(value, SignerError.InputIndexOutOfRange):
            buf.write_i32(4)
        if isinstance(value, SignerError.MissingNonWitnessUtxo):
            buf.write_i32(5)
        if isinstance(value, SignerError.InvalidNonWitnessUtxo):
            buf.write_i32(6)
        if isinstance(value, SignerError.MissingWitnessUtxo):
            buf.write_i32(7)
        if isinstance(value, SignerError.MissingWitnessScript):
            buf.write_i32(8)
        if isinstance(value, SignerError.MissingHdKeypath):
            buf.write_i32(9)
        if isinstance(value, SignerError.NonStandardSighash):
            buf.write_i32(10)
        if isinstance(value, SignerError.InvalidSighash):
            buf.write_i32(11)
        if isinstance(value, SignerError.SighashP2wpkh):
            buf.write_i32(12)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, SignerError.SighashTaproot):
            buf.write_i32(13)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, SignerError.TxInputsIndexError):
            buf.write_i32(14)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, SignerError.MiniscriptPsbt):
            buf.write_i32(15)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, SignerError.External):
            buf.write_i32(16)
            _UniffiConverterString.write(value.error_message, buf)
        if isinstance(value, SignerError.Psbt):
            buf.write_i32(17)
            _UniffiConverterString.write(value.error_message, buf)


# SqliteError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class SqliteError(Exception):
    pass

_UniffiTempSqliteError = SqliteError

class SqliteError:  # type: ignore
    class Sqlite(_UniffiTempSqliteError):
        def __init__(self, rusqlite_error):
            super().__init__(", ".join([
                "rusqlite_error={!r}".format(rusqlite_error),
            ]))
            self.rusqlite_error = rusqlite_error

        def __repr__(self):
            return "SqliteError.Sqlite({})".format(str(self))
    _UniffiTempSqliteError.Sqlite = Sqlite # type: ignore

SqliteError = _UniffiTempSqliteError # type: ignore
del _UniffiTempSqliteError


class _UniffiConverterTypeSqliteError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return SqliteError.Sqlite(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, SqliteError.Sqlite):
            _UniffiConverterString.check_lower(value.rusqlite_error)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, SqliteError.Sqlite):
            buf.write_i32(1)
            _UniffiConverterString.write(value.rusqlite_error, buf)


# TransactionError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TransactionError(Exception):
    pass

_UniffiTempTransactionError = TransactionError

class TransactionError:  # type: ignore
    class Io(_UniffiTempTransactionError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TransactionError.Io({})".format(str(self))
    _UniffiTempTransactionError.Io = Io # type: ignore
    class OversizedVectorAllocation(_UniffiTempTransactionError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TransactionError.OversizedVectorAllocation({})".format(str(self))
    _UniffiTempTransactionError.OversizedVectorAllocation = OversizedVectorAllocation # type: ignore
    class InvalidChecksum(_UniffiTempTransactionError):
        def __init__(self, expected, actual):
            super().__init__(", ".join([
                "expected={!r}".format(expected),
                "actual={!r}".format(actual),
            ]))
            self.expected = expected
            self.actual = actual

        def __repr__(self):
            return "TransactionError.InvalidChecksum({})".format(str(self))
    _UniffiTempTransactionError.InvalidChecksum = InvalidChecksum # type: ignore
    class NonMinimalVarInt(_UniffiTempTransactionError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TransactionError.NonMinimalVarInt({})".format(str(self))
    _UniffiTempTransactionError.NonMinimalVarInt = NonMinimalVarInt # type: ignore
    class ParseFailed(_UniffiTempTransactionError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TransactionError.ParseFailed({})".format(str(self))
    _UniffiTempTransactionError.ParseFailed = ParseFailed # type: ignore
    class UnsupportedSegwitFlag(_UniffiTempTransactionError):
        def __init__(self, flag):
            super().__init__(", ".join([
                "flag={!r}".format(flag),
            ]))
            self.flag = flag

        def __repr__(self):
            return "TransactionError.UnsupportedSegwitFlag({})".format(str(self))
    _UniffiTempTransactionError.UnsupportedSegwitFlag = UnsupportedSegwitFlag # type: ignore
    class OtherTransactionErr(_UniffiTempTransactionError):
        def __init__(self):
            pass

        def __repr__(self):
            return "TransactionError.OtherTransactionErr({})".format(str(self))
    _UniffiTempTransactionError.OtherTransactionErr = OtherTransactionErr # type: ignore

TransactionError = _UniffiTempTransactionError # type: ignore
del _UniffiTempTransactionError


class _UniffiConverterTypeTransactionError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TransactionError.Io(
            )
        if variant == 2:
            return TransactionError.OversizedVectorAllocation(
            )
        if variant == 3:
            return TransactionError.InvalidChecksum(
                _UniffiConverterString.read(buf),
                _UniffiConverterString.read(buf),
            )
        if variant == 4:
            return TransactionError.NonMinimalVarInt(
            )
        if variant == 5:
            return TransactionError.ParseFailed(
            )
        if variant == 6:
            return TransactionError.UnsupportedSegwitFlag(
                _UniffiConverterUInt8.read(buf),
            )
        if variant == 7:
            return TransactionError.OtherTransactionErr(
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TransactionError.Io):
            return
        if isinstance(value, TransactionError.OversizedVectorAllocation):
            return
        if isinstance(value, TransactionError.InvalidChecksum):
            _UniffiConverterString.check_lower(value.expected)
            _UniffiConverterString.check_lower(value.actual)
            return
        if isinstance(value, TransactionError.NonMinimalVarInt):
            return
        if isinstance(value, TransactionError.ParseFailed):
            return
        if isinstance(value, TransactionError.UnsupportedSegwitFlag):
            _UniffiConverterUInt8.check_lower(value.flag)
            return
        if isinstance(value, TransactionError.OtherTransactionErr):
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TransactionError.Io):
            buf.write_i32(1)
        if isinstance(value, TransactionError.OversizedVectorAllocation):
            buf.write_i32(2)
        if isinstance(value, TransactionError.InvalidChecksum):
            buf.write_i32(3)
            _UniffiConverterString.write(value.expected, buf)
            _UniffiConverterString.write(value.actual, buf)
        if isinstance(value, TransactionError.NonMinimalVarInt):
            buf.write_i32(4)
        if isinstance(value, TransactionError.ParseFailed):
            buf.write_i32(5)
        if isinstance(value, TransactionError.UnsupportedSegwitFlag):
            buf.write_i32(6)
            _UniffiConverterUInt8.write(value.flag, buf)
        if isinstance(value, TransactionError.OtherTransactionErr):
            buf.write_i32(7)


# TxidParseError
# We want to define each variant as a nested class that's also a subclass,
# which is tricky in Python.  To accomplish this we're going to create each
# class separately, then manually add the child classes to the base class's
# __dict__.  All of this happens in dummy class to avoid polluting the module
# namespace.
class TxidParseError(Exception):
    pass

_UniffiTempTxidParseError = TxidParseError

class TxidParseError:  # type: ignore
    class InvalidTxid(_UniffiTempTxidParseError):
        def __init__(self, txid):
            super().__init__(", ".join([
                "txid={!r}".format(txid),
            ]))
            self.txid = txid

        def __repr__(self):
            return "TxidParseError.InvalidTxid({})".format(str(self))
    _UniffiTempTxidParseError.InvalidTxid = InvalidTxid # type: ignore

TxidParseError = _UniffiTempTxidParseError # type: ignore
del _UniffiTempTxidParseError


class _UniffiConverterTypeTxidParseError(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return TxidParseError.InvalidTxid(
                _UniffiConverterString.read(buf),
            )
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if isinstance(value, TxidParseError.InvalidTxid):
            _UniffiConverterString.check_lower(value.txid)
            return

    @staticmethod
    def write(value, buf):
        if isinstance(value, TxidParseError.InvalidTxid):
            buf.write_i32(1)
            _UniffiConverterString.write(value.txid, buf)





class WordCount(enum.Enum):
    WORDS12 = 0
    
    WORDS15 = 1
    
    WORDS18 = 2
    
    WORDS21 = 3
    
    WORDS24 = 4
    


class _UniffiConverterTypeWordCount(_UniffiConverterRustBuffer):
    @staticmethod
    def read(buf):
        variant = buf.read_i32()
        if variant == 1:
            return WordCount.WORDS12
        if variant == 2:
            return WordCount.WORDS15
        if variant == 3:
            return WordCount.WORDS18
        if variant == 4:
            return WordCount.WORDS21
        if variant == 5:
            return WordCount.WORDS24
        raise InternalError("Raw enum value doesn't match any cases")

    @staticmethod
    def check_lower(value):
        if value == WordCount.WORDS12:
            return
        if value == WordCount.WORDS15:
            return
        if value == WordCount.WORDS18:
            return
        if value == WordCount.WORDS21:
            return
        if value == WordCount.WORDS24:
            return
        raise ValueError(value)

    @staticmethod
    def write(value, buf):
        if value == WordCount.WORDS12:
            buf.write_i32(1)
        if value == WordCount.WORDS15:
            buf.write_i32(2)
        if value == WordCount.WORDS18:
            buf.write_i32(3)
        if value == WordCount.WORDS21:
            buf.write_i32(4)
        if value == WordCount.WORDS24:
            buf.write_i32(5)





class _UniffiConverterOptionalUInt32(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterUInt32.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterUInt32.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterUInt32.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalString(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterString.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterString.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterString.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeTransaction(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeTransaction.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeTransaction.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeTransaction.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeCanonicalTx(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeCanonicalTx.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeCanonicalTx.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeCanonicalTx.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeKeychainAndIndex(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeKeychainAndIndex.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeKeychainAndIndex.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeKeychainAndIndex.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterOptionalTypeLocalOutput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        if value is not None:
            _UniffiConverterTypeLocalOutput.check_lower(value)

    @classmethod
    def write(cls, value, buf):
        if value is None:
            buf.write_u8(0)
            return

        buf.write_u8(1)
        _UniffiConverterTypeLocalOutput.write(value, buf)

    @classmethod
    def read(cls, buf):
        flag = buf.read_u8()
        if flag == 0:
            return None
        elif flag == 1:
            return _UniffiConverterTypeLocalOutput.read(buf)
        else:
            raise InternalError("Unexpected flag byte for optional type")



class _UniffiConverterSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterUInt8.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeAddressInfo(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeAddressInfo.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeAddressInfo.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeAddressInfo.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeCanonicalTx(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeCanonicalTx.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeCanonicalTx.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeCanonicalTx.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeLocalOutput(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeLocalOutput.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeLocalOutput.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeLocalOutput.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeScriptAmount(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeScriptAmount.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeScriptAmount.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeScriptAmount.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTxIn(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTxIn.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTxIn.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTxIn.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeTxOut(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeTxOut.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeTxOut.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeTxOut.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceSequenceUInt8(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterSequenceUInt8.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterSequenceUInt8.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterSequenceUInt8.read(buf) for i in range(count)
        ]



class _UniffiConverterSequenceTypeOutPoint(_UniffiConverterRustBuffer):
    @classmethod
    def check_lower(cls, value):
        for item in value:
            _UniffiConverterTypeOutPoint.check_lower(item)

    @classmethod
    def write(cls, value, buf):
        items = len(value)
        buf.write_i32(items)
        for item in value:
            _UniffiConverterTypeOutPoint.write(item, buf)

    @classmethod
    def read(cls, buf):
        count = buf.read_i32()
        if count < 0:
            raise InternalError("Unexpected negative sequence length")

        return [
            _UniffiConverterTypeOutPoint.read(buf) for i in range(count)
        ]

# External type Amount is in namespace "bitcoin", crate bitcoin_ffi




# External type FeeRate is in namespace "bitcoin", crate bitcoin_ffi




# External type Network is in namespace "bitcoin", crate bitcoin_ffi




# External type OutPoint is in namespace "bitcoin", crate bitcoin_ffi




# External type Script is in namespace "bitcoin", crate bitcoin_ffi




# Async support

__all__ = [
    "InternalError",
    "AddressParseError",
    "Bip32Error",
    "Bip39Error",
    "CalculateFeeError",
    "CannotConnectError",
    "ChainPosition",
    "ChangeSpendPolicy",
    "CreateTxError",
    "CreateWithPersistError",
    "DescriptorError",
    "DescriptorKeyError",
    "ElectrumError",
    "EsploraError",
    "ExtractTxError",
    "FromScriptError",
    "KeychainKind",
    "LoadWithPersistError",
    "PersistenceError",
    "PsbtError",
    "PsbtParseError",
    "RequestBuilderError",
    "SignerError",
    "SqliteError",
    "TransactionError",
    "TxidParseError",
    "WordCount",
    "AddressInfo",
    "Balance",
    "BlockId",
    "CanonicalTx",
    "ConfirmationBlockTime",
    "KeychainAndIndex",
    "LocalOutput",
    "ScriptAmount",
    "SentAndReceivedValues",
    "TxIn",
    "TxOut",
    "Address",
    "BumpFeeTxBuilder",
    "ChangeSet",
    "Connection",
    "DerivationPath",
    "Descriptor",
    "DescriptorPublicKey",
    "DescriptorSecretKey",
    "ElectrumClient",
    "EsploraClient",
    "FullScanRequest",
    "FullScanRequestBuilder",
    "FullScanScriptInspector",
    "Mnemonic",
    "Psbt",
    "SyncRequest",
    "SyncRequestBuilder",
    "SyncScriptInspector",
    "Transaction",
    "TxBuilder",
    "Update",
    "Wallet",
]

