from _typeshed import Incomplete
from collections.abc import Generator
from typing import Callable, Optional

version: str

# def primegen(limit=...) -> Generator[Incomplete, Incomplete, Incomplete]: ...
# def ilog(x, b): ...

def modinv(a: int, m: int) -> int: ...
def introot(n: int, r: int = 2) -> int: ...
def ispower(n: int, r: int = 0) -> Optional[tuple[int, int] | int]: ...

# def jacobi(a, n): ...

def isprime(
    n: int,
    tb: tuple[int, ...] = (
        3,
        5,
        7,
        11,
        13,
        17,
        19,
        23,
        29,
        31,
        37,
        41,
        43,
        47,
        53,
        59,
    ),
) -> bool: ...

# def pollardrho_brent(n, verbose: bool = False): ...
# def pollard_pm1(n, B1: int = 100, B2: int = 1000, verbose: bool = False): ...
# def mlucas(v, a, n): ...
# def williams_pp1(n, verbose: bool = False): ...
# def ecadd(p1, p2, p0, n): ...
# def ecdub(p, A, n): ...
# def ecmul(m, p, A, n): ...
# def secm(n, B1, B2, seed): ...
# def ecmparams(n) -> Generator[Incomplete, None, None]: ...
# def ecm(n, paramseq=..., nprocs: int = 1, verbose: bool = False): ...

def sqrtmod_prime(a: int, p: int) -> int: ...

# def siqs(n, verbose: bool = False): ...
# def multifactor(n, methods=..., verbose: bool = False): ...

def primefac(
    n: int,
    trial: int = 1000,
    rho: int = 42000,
    verbose: bool = False,
    methods: Callable[[int, Incomplete], int] = ...,
) -> Generator[int, None, None]: ...

# def rpn(instr) -> Generator[Incomplete, None, None]: ...

usage: str
