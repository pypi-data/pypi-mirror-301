# coding: utf-8

"""
    MetaCopier API

    Explore the power of the MetaCopier API! Our RESTful API offers scalable and secure access to accounts, projects, and more. Get started quickly with authentication, explore endpoints, and access code samples in various languages.<br/><br/>All dates are in ISO 8601<br/><br/>This API is not designed for real-time communication purposes. For instance, continuously polling account information such as open positions every second is not recommended.<br/><br/>Our frontend uses this API, so you can look at the requests on our frontend for examples.

    The version of the OpenAPI document: 0.9.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import json
import pprint
from pydantic import BaseModel, ConfigDict, Field, StrictStr, ValidationError, field_validator
from typing import Any, List, Optional
from metacopier_api.models.feature_copier_filter_dto import FeatureCopierFilterDTO
from metacopier_api.models.feature_keep_alive_trade_dto import FeatureKeepAliveTradeDTO
from metacopier_api.models.feature_permitted_symbols_dto import FeaturePermittedSymbolsDTO
from metacopier_api.models.feature_telegram_notification_dto import FeatureTelegramNotificationDTO
from pydantic import StrictStr, Field
from typing import Union, List, Set, Optional, Dict
from typing_extensions import Literal, Self

FEATURESETTINGDTO_ONE_OF_SCHEMAS = ["FeatureCopierFilterDTO", "FeatureKeepAliveTradeDTO", "FeaturePermittedSymbolsDTO", "FeatureTelegramNotificationDTO"]

class FeatureSettingDTO(BaseModel):
    """
    Configure setting for the specific feature
    """
    # data type: FeatureTelegramNotificationDTO
    oneof_schema_1_validator: Optional[FeatureTelegramNotificationDTO] = None
    # data type: FeatureCopierFilterDTO
    oneof_schema_2_validator: Optional[FeatureCopierFilterDTO] = None
    # data type: FeatureKeepAliveTradeDTO
    oneof_schema_3_validator: Optional[FeatureKeepAliveTradeDTO] = None
    # data type: FeaturePermittedSymbolsDTO
    oneof_schema_4_validator: Optional[FeaturePermittedSymbolsDTO] = None
    actual_instance: Optional[Union[FeatureCopierFilterDTO, FeatureKeepAliveTradeDTO, FeaturePermittedSymbolsDTO, FeatureTelegramNotificationDTO]] = None
    one_of_schemas: Set[str] = { "FeatureCopierFilterDTO", "FeatureKeepAliveTradeDTO", "FeaturePermittedSymbolsDTO", "FeatureTelegramNotificationDTO" }

    model_config = ConfigDict(
        validate_assignment=True,
        protected_namespaces=(),
    )


    def __init__(self, *args, **kwargs) -> None:
        if args:
            if len(args) > 1:
                raise ValueError("If a position argument is used, only 1 is allowed to set `actual_instance`")
            if kwargs:
                raise ValueError("If a position argument is used, keyword arguments cannot be used.")
            super().__init__(actual_instance=args[0])
        else:
            super().__init__(**kwargs)

    @field_validator('actual_instance')
    def actual_instance_must_validate_oneof(cls, v):
        instance = FeatureSettingDTO.model_construct()
        error_messages = []
        match = 0
        # validate data type: FeatureTelegramNotificationDTO
        if not isinstance(v, FeatureTelegramNotificationDTO):
            error_messages.append(f"Error! Input type `{type(v)}` is not `FeatureTelegramNotificationDTO`")
        else:
            match += 1
        # validate data type: FeatureCopierFilterDTO
        if not isinstance(v, FeatureCopierFilterDTO):
            error_messages.append(f"Error! Input type `{type(v)}` is not `FeatureCopierFilterDTO`")
        else:
            match += 1
        # validate data type: FeatureKeepAliveTradeDTO
        if not isinstance(v, FeatureKeepAliveTradeDTO):
            error_messages.append(f"Error! Input type `{type(v)}` is not `FeatureKeepAliveTradeDTO`")
        else:
            match += 1
        # validate data type: FeaturePermittedSymbolsDTO
        if not isinstance(v, FeaturePermittedSymbolsDTO):
            error_messages.append(f"Error! Input type `{type(v)}` is not `FeaturePermittedSymbolsDTO`")
        else:
            match += 1
        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when setting `actual_instance` in FeatureSettingDTO with oneOf schemas: FeatureCopierFilterDTO, FeatureKeepAliveTradeDTO, FeaturePermittedSymbolsDTO, FeatureTelegramNotificationDTO. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when setting `actual_instance` in FeatureSettingDTO with oneOf schemas: FeatureCopierFilterDTO, FeatureKeepAliveTradeDTO, FeaturePermittedSymbolsDTO, FeatureTelegramNotificationDTO. Details: " + ", ".join(error_messages))
        else:
            return v

    @classmethod
    def from_dict(cls, obj: Union[str, Dict[str, Any]]) -> Self:
        return cls.from_json(json.dumps(obj))

    @classmethod
    def from_json(cls, json_str: str) -> Self:
        """Returns the object represented by the json string"""
        instance = cls.model_construct()
        error_messages = []
        match = 0

        # deserialize data into FeatureTelegramNotificationDTO
        try:
            instance.actual_instance = FeatureTelegramNotificationDTO.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into FeatureCopierFilterDTO
        try:
            instance.actual_instance = FeatureCopierFilterDTO.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into FeatureKeepAliveTradeDTO
        try:
            instance.actual_instance = FeatureKeepAliveTradeDTO.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))
        # deserialize data into FeaturePermittedSymbolsDTO
        try:
            instance.actual_instance = FeaturePermittedSymbolsDTO.from_json(json_str)
            match += 1
        except (ValidationError, ValueError) as e:
            error_messages.append(str(e))

        if match > 1:
            # more than 1 match
            raise ValueError("Multiple matches found when deserializing the JSON string into FeatureSettingDTO with oneOf schemas: FeatureCopierFilterDTO, FeatureKeepAliveTradeDTO, FeaturePermittedSymbolsDTO, FeatureTelegramNotificationDTO. Details: " + ", ".join(error_messages))
        elif match == 0:
            # no match
            raise ValueError("No match found when deserializing the JSON string into FeatureSettingDTO with oneOf schemas: FeatureCopierFilterDTO, FeatureKeepAliveTradeDTO, FeaturePermittedSymbolsDTO, FeatureTelegramNotificationDTO. Details: " + ", ".join(error_messages))
        else:
            return instance

    def to_json(self) -> str:
        """Returns the JSON representation of the actual instance"""
        if self.actual_instance is None:
            return "null"

        if hasattr(self.actual_instance, "to_json") and callable(self.actual_instance.to_json):
            return self.actual_instance.to_json()
        else:
            return json.dumps(self.actual_instance)

    def to_dict(self) -> Optional[Union[Dict[str, Any], FeatureCopierFilterDTO, FeatureKeepAliveTradeDTO, FeaturePermittedSymbolsDTO, FeatureTelegramNotificationDTO]]:
        """Returns the dict representation of the actual instance"""
        if self.actual_instance is None:
            return None

        if hasattr(self.actual_instance, "to_dict") and callable(self.actual_instance.to_dict):
            return self.actual_instance.to_dict()
        else:
            # primitive type
            return self.actual_instance

    def to_str(self) -> str:
        """Returns the string representation of the actual instance"""
        return pprint.pformat(self.model_dump())


