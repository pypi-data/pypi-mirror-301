<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Using Stingray Reader &#8212; Stingray-Reader 5.1 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=27fed22d" />
    <script src="_static/documentation_options.js?v=4af8989d"></script>
    <script src="_static/doctools.js?v=9bcbadda"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Design Notes" href="design.html" />
    <link rel="prev" title="Installation" href="installation.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="using-stingray-reader">
<span id="using"></span><h1>Using <strong>Stingray Reader</strong><a class="headerlink" href="#using-stingray-reader" title="Link to this heading">¶</a></h1>
<p>We use <strong>Stingray</strong> to work with data files where the schema is either external or complex (or both).
The tool lets us tackle this question:</p>
<blockquote>
<div><p><strong>How do we process a file simply and consistently?</strong></p>
</div></blockquote>
<p>In some cases, we can extend this to a more comprehensive question:</p>
<blockquote>
<div><p><strong>How do we make a program independent of Physical Format and Logical Layout?</strong></p>
</div></blockquote>
<p>We can also use <strong>Stingray</strong> to answer questions about files, the schema those files purport to use, and the data in those files.
Specifically, we can tackle this question:</p>
<blockquote>
<div><p><strong>How do we ensure that a file and an application use the same schema?</strong></p>
</div></blockquote>
<p>There are two sides to this “using the same schema?” question:</p>
<ul class="simple">
<li><p><strong>Data Quality</strong>. Does the file match the required schema?</p></li>
<li><p><strong>Software Quality</strong>. Will this application process a file with the required schema?</p></li>
</ul>
<p>An underlying assumption is the schema is correct.
Files or applications may not match the schema, but the schema is the standard.</p>
<p>We also need to note the following.</p>
<blockquote>
<div><p><strong>If it was simple, we wouldn’t need this package, would we?</strong></p>
</div></blockquote>
<section id="concepts">
<h2>Concepts<a class="headerlink" href="#concepts" title="Link to this heading">¶</a></h2>
<p>Here are the three levels of schema that describe the data in a file:</p>
<ul class="simple">
<li><p><strong>Physical Format</strong>.
This defines how to unpack bytes into Python objects (e.g., decode a string to lines of text to atomic fields).
We want to make this transparent to our applications, so we can focus on the data and the processing.
When using <strong>Stingray</strong>, everything is a workbook with sheets, rows, cells, and a consistent API.</p></li>
<li><p><strong>Logical Layout</strong>.
This defines how to locate the values within row structures that may not have perfectly consistent column order.
Sometimes the Logical Layout is described by a schema embedded in the file: it might be the top row of a sheet in a workbook, for example.
Sometimes the logical layout can be in a separate file: a COBOL data definition, or perhaps a metadata sheet in a workbook.</p></li>
<li><p><strong>Conceptual Content</strong>.
A single conceptual schema of has data represented by a number of logical layouts.
Sometimes the data is represented in a number of physical formats.
An application should be able to tolerate variability as long is the data reflects a consistent <strong>conceptual content</strong>.</p></li>
</ul>
<p>We can’t make the logical layout of data completely transparent to the application programs.
The column names in the metadata, at a bare minimum, are a visible aspect of the layout.
The order or position of the columns in each row, however, need not be fixed.</p>
<p>Since we’re working in Python, the conceptual schema is often defined by an application’s class definitions.
The idea is to support ways to build class instances that are tolerant of variations in the logical layout.
This should also be independent of physical format.</p>
<p>The unifying theme is to have a conceptual schema.
This schema then supports application processing without regard to layout and format.</p>
</section>
<section id="schema-based-processing">
<h2>Schema-Based Processing<a class="headerlink" href="#schema-based-processing" title="Link to this heading">¶</a></h2>
<p>All <strong>Stingray</strong> applications involve two elements:</p>
<ul class="simple">
<li><p>a source of data, a <code class="xref py py-class docutils literal notranslate"><span class="pre">Workbook</span></code> object,</p></li>
<li><p>and a schema, an instance of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Schema</span></code> class.</p></li>
</ul>
<p>Here are the essential relationships among the concepts:</p>
<p class="plantuml">
<img src="_images/plantuml-d4952faaca1aef6d7d67a3c8aa5d6cdc1b66073c.png" alt="&#64;startuml

class Workbook {
    sheet(name): Sheet
}
class Sheet {
    name: str
    rows()
}
class Row

Workbook *-- Sheet
Sheet *-- Row

class Schema

Sheet ..&gt; Schema : &quot;described by&quot;
Row ..&gt; Schema : &quot;described by&quot;

class MyApp

MyApp -&gt; Schema : &quot;loads&quot;
MyApp -&gt; Workbook : &quot;open&quot;
&#64;enduml"/>
</p>
<p>The schema can originate in a variety of places:</p>
<ul class="simple">
<li><p>A Schema can be the first row of a spreadsheet.
Think of the <code class="xref py py-class docutils literal notranslate"><span class="pre">csv.DictReader</span></code> class, which examines the given file for a header row, creates a minimal schema from this row, and uses the schema to unpack the remaining rows.</p></li>
<li><p>A Schema can be in a separate document. There are a number of choices.</p>
<ul>
<li><p>For COBOL files, the schema is a “Copybook” with the COBOL Data Definition Entry (DDE) for the file.
The schema is COBOL code.</p></li>
<li><p>A sheet of a workbook may have “metadata” with column definitions.
This is a schema represented as a workbook.
The columns of this metadata sheet have a metaschema.</p></li>
</ul>
</li>
<li><p>A JSON Schema can be embedded in the code.
Ideally, it’s in a separate module that can be shared by many applications.
The sharing assures consistent Conceptual Content among applications.</p></li>
</ul>
<p>There are, in effect, four use cases for gathering schema that can be used to process data.</p>
<p class="plantuml">
<img src="_images/plantuml-e2808e2b3628e3e0626373475cc3f550e5cfbabd.png" alt="&#64;startuml
class Schema

abstract class SchemaLoader
class HeadingRowSchemaLoader {
    header()
    body()
}
class ExternalSchemaLoader {
    load() : Schema
}
class COBOLSchemaLoader {
    load() : Schema
}

SchemaLoader &lt;|-- HeadingRowSchemaLoader
SchemaLoader &lt;|-- ExternalSchemaLoader
ExternalSchemaLoader &lt;|-- COBOLSchemaLoader

HeadingRowSchemaLoader --&gt; Schema : &quot;extracts&quot;
ExternalSchemaLoader --&gt; Schema : &quot;loads&quot;
COBOLSchemaLoader --&gt; Schema : &quot;loads&quot;

class Sheet
Sheet ..&gt; Schema : &quot;described by&quot;

&#64;enduml"/>
</p>
<p>This leads us to four patterns for working with Schema to access data.
We’ll look at each of them in the next section.</p>
</section>
<section id="essential-patterns-of-schema-use">
<h2>Essential Patterns of Schema Use<a class="headerlink" href="#essential-patterns-of-schema-use" title="Link to this heading">¶</a></h2>
<p>There are four patterns to loading the schema
before working with the data:</p>
<ul class="simple">
<li><p>The schema is in one (or more) header rows of a sheet in a workbook.</p></li>
<li><p>The schema is in an external file, i.e., another workbook, or another sheet in the data workbook.</p></li>
<li><p>The schema is defined by a COBOL DDE in a “copybook”.   This is an external file, but with more complex syntax, not another workbook with a distinct metaschema.</p></li>
<li><p>A schema is embedded in the application as class definitions or JSON Schema documents.</p></li>
</ul>
<p>We’ll look at each in some detail.</p>
<section id="schema-in-header-rows">
<h3>Schema in Header Rows<a class="headerlink" href="#schema-in-header-rows" title="Link to this heading">¶</a></h3>
<p>When the header row has a schema, the processing is vaguely similar to working with the <code class="xref py py-mod docutils literal notranslate"><span class="pre">csv</span></code> module.
There are two steps to processing the data.</p>
<ol class="arabic simple">
<li><p>Load the schema from the first row.</p></li>
<li><p>Process the remaining rows using the loaded schema.</p></li>
</ol>
<p>For CSV, COBOL, and similar structures, there is a single conceptual sheet in the workbook.
This one-and-only sheet is named <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>.
Rather than assume a default sheet with this name, <strong>Stingray</strong> requires an explicit reference
to the sheet named <code class="docutils literal notranslate"><span class="pre">&quot;&quot;</span></code>.</p>
<p>The header row processing looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">stingray</span> <span class="kn">import</span> <span class="n">open_workbook</span><span class="p">,</span> <span class="n">HeadingRowSchemaLoader</span><span class="p">,</span> <span class="n">Row</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">process_rows</span><span class="p">(</span><span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Row</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;x123&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;y1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">data_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SAMPLES&quot;</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="s2">&quot;Anscombe_quartet_data.csv&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">open_workbook</span><span class="p">(</span><span class="n">data_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">workbook</span><span class="p">:</span>
<span class="gp">... </span>   <span class="n">sheet</span> <span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="n">sheet</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="gp">... </span>   <span class="n">_</span> <span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="n">set_schema_loader</span><span class="p">(</span><span class="n">HeadingRowSchemaLoader</span><span class="p">())</span>
<span class="gp">... </span>   <span class="n">process_rows</span><span class="p">(</span><span class="n">sheet</span><span class="o">.</span><span class="n">rows</span><span class="p">())</span>
<span class="go">10.0 8.04</span>
<span class="go">8.0 6.95</span>
<span class="go">13.0 7.58</span>
<span class="go">9.0 8.81</span>
<span class="go">11.0 8.33</span>
<span class="go">14.0 9.96</span>
<span class="go">6.0 7.24</span>
<span class="go">4.0 4.26</span>
<span class="go">12.0 10.84</span>
<span class="go">7.0 4.82</span>
<span class="go">5.0 5.68</span>
</pre></div>
</div>
<p>The essential processing, in the <code class="docutils literal notranslate"><span class="pre">process_rows()</span></code> function, uses the <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> class.
Each <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> instance has columns.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">HeadingRowSchemaLoader</span></code> built a schema from the header row.
This is a stripped-down-to-almost-nothing schema with column names and default data types
of string.
The schema derived from a CSV header – by itself – only has column names.
The schema <strong>could</strong> provide additional information, like data conversions to perform for each column.</p>
</section>
<section id="schema-in-an-external-file">
<h3>Schema in an External File<a class="headerlink" href="#schema-in-an-external-file" title="Link to this heading">¶</a></h3>
<p>For an external schema, here are the two steps to processing the data:</p>
<ol class="arabic simple">
<li><p>Load the schema. This involves opening a workbook that has the schema,
This external schema has its own metaschema, ideally as header rows.</p></li>
<li><p>Process data using the loaded schema.</p></li>
</ol>
<p>External schema processing look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">stingray</span> <span class="kn">import</span> <span class="n">open_workbook</span><span class="p">,</span> <span class="n">ExternalSchemaLoader</span><span class="p">,</span> <span class="n">Row</span><span class="p">,</span> <span class="n">SchemaMaker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">process_rows</span><span class="p">(</span><span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Row</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;x123&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;y1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>

<span class="go">1. Load the Schema by reading a CSV file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">schema_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SAMPLES&quot;</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="s2">&quot;Anscombe_schema.csv&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">open_workbook</span><span class="p">(</span><span class="n">schema_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">metaschema_workbook</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">schema_sheet</span> <span class="o">=</span> <span class="n">metaschema_workbook</span><span class="o">.</span><span class="n">sheet</span><span class="p">(</span><span class="s2">&quot;Sheet1&quot;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">metaschema</span> <span class="o">=</span> <span class="n">SchemaMaker</span><span class="p">()</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">ExternalSchemaLoader</span><span class="o">.</span><span class="n">META_SCHEMA</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">_</span> <span class="o">=</span> <span class="n">schema_sheet</span><span class="o">.</span><span class="n">set_schema</span><span class="p">(</span><span class="n">metaschema</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">json_schema</span> <span class="o">=</span> <span class="n">ExternalSchemaLoader</span><span class="p">(</span><span class="n">schema_sheet</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">schema</span> <span class="o">=</span> <span class="n">SchemaMaker</span><span class="p">()</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">json_schema</span><span class="p">)</span>

<span class="go">2. Process the rows using the schema</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SAMPLES&quot;</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="s2">&quot;Anscombe_quartet_data.csv&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">open_workbook</span><span class="p">(</span><span class="n">data_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">workbook</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">sheet</span> <span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="n">sheet</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">set_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">process_rows</span><span class="p">(</span><span class="n">sheet</span><span class="o">.</span><span class="n">rows</span><span class="p">())</span>
<span class="go">x123 y1</span>
<span class="go">10.0 8.04</span>
<span class="go">8.0 6.95</span>
<span class="go">13.0 7.58</span>
<span class="go">9.0 8.81</span>
<span class="go">11.0 8.33</span>
<span class="go">14.0 9.96</span>
<span class="go">6.0 7.24</span>
<span class="go">4.0 4.26</span>
<span class="go">12.0 10.84</span>
<span class="go">7.0 4.82</span>
<span class="go">5.0 5.68</span>
</pre></div>
</div>
<p>The first step – reading the external schema – involves opening a schema workbook, and preparing to read the schema sheet.
What’s on this schema definition sheet?
In this example, we’ve used the <code class="docutils literal notranslate"><span class="pre">ExternalSchemaLoader.META_SCHEMA</span></code> to define the columns of the schema.</p>
<p>If no metaschema is defined by the <code class="docutils literal notranslate"><span class="pre">set_schema()</span></code> method, a <code class="xref py py-class docutils literal notranslate"><span class="pre">HeadingRowSchemaLoader</span></code> is used.
This will use column names in the first row of the schema sheet.</p>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">ExternalSchemaLoader</span></code> builds a schema from a sheet that must provide column names,
column data conversions, and a column description.
The metaschema must match the following JSON Schema definition:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;generic meta schema for external schema documents&quot;</span><span class="p">,</span>
    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span>
    <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;field name&quot;</span><span class="p">,</span> <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
        <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;field description&quot;</span><span class="p">,</span>
            <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;dataType&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;field data type&quot;</span><span class="p">,</span>
            <span class="s2">&quot;position&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">},</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Three columns are required by this definition:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">description</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dataType</span></code></p></li>
</ul>
<p>If your schema doesn’t look like this, you’ll need to define a metaschema, similar to the JSON Schema document shown here.</p>
<p>Once the the external schema has been loaded, it is used to process the target data.
The <code class="docutils literal notranslate"><span class="pre">process_rows()</span></code> function can consume rows with the attribute names and types that
are defined in the external <code class="docutils literal notranslate"><span class="pre">Anscombe_schema.csv</span></code> file.
Because of the schema, automated conversions from strings to float can be done by <strong>Stingray</strong>.</p>
<p>An essential feature of this is the processing does <strong>not</strong> change, even though the source data physical format and logical layout can change.
Further, it becomes possible to tolerate a variety of schema definition alternatives.</p>
</section>
<section id="schema-in-a-cobol-copybook">
<h3>Schema in a COBOL Copybook<a class="headerlink" href="#schema-in-a-cobol-copybook" title="Link to this heading">¶</a></h3>
<p>COBOL Processing is similar to external schema loading.
First, the application loads the schema from the COBOL copybook file.
Then, the application can process data using the schema.</p>
<p>COBOL processing looks like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">stingray</span> <span class="kn">import</span> <span class="n">schema_iter</span><span class="p">,</span> <span class="n">COBOL_Text_File</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>

<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">process_rows</span><span class="p">(</span><span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Row</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;X123&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;Y1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>

<span class="go">1. Load the Schema by reading a COBOL CPY file</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">copybook_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SAMPLES&quot;</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="s2">&quot;anscombe.cpy&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">copybook_path</span><span class="o">.</span><span class="n">open</span><span class="p">()</span> <span class="k">as</span> <span class="n">source</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">schema_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">schema_iter</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">json_schema</span><span class="p">,</span> <span class="o">=</span> <span class="n">schema_list</span>  <span class="c1"># Take the first; ignore any other 01-level records</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">schema</span> <span class="o">=</span> <span class="n">SchemaMaker</span><span class="p">()</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">json_schema</span><span class="p">)</span>

<span class="go">2. Process the rows using the schema</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SAMPLES&quot;</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="s2">&quot;anscombe.data&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">COBOL_Text_File</span><span class="p">(</span><span class="n">data_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">workbook</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">sheet</span> <span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="n">sheet</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">set_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">process_rows</span><span class="p">(</span><span class="n">sheet</span><span class="o">.</span><span class="n">rows</span><span class="p">())</span>
<span class="go"> 010.00  008.04</span>
<span class="go"> 008.00  006.95</span>
<span class="go"> 013.00  007.58</span>
<span class="go"> 009.00  008.81</span>
<span class="go"> 011.00  008.33</span>
<span class="go"> 014.00  009.96</span>
<span class="go"> 006.00  007.24</span>
<span class="go"> 004.00  004.26</span>
<span class="go"> 012.00  010.84</span>
<span class="go"> 007.00  004.82</span>
<span class="go"> 005.00  005.68</span>
</pre></div>
</div>
<p>The <code class="xref py py-func docutils literal notranslate"><span class="pre">schema_iter()</span></code> function reads all of the COBOL record definitions in the given file.
While it’s common to have a single “01-level” layout in a file, this isn’t universally true.
The parser will examine all of the record definitions.
In the cases where there’s a single definition, the result will be a list with only one item.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">process_rows()</span></code> function for working with COBOL is nearly identical to the previous two examples.
The column names <code class="docutils literal notranslate"><span class="pre">x123</span></code> and <code class="docutils literal notranslate"><span class="pre">y1</span></code> are switched to upper case, which is a little more typical of COBOL.</p>
<p>The COBOL definition for this file is the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="mi">01</span>  <span class="n">ANSCOMBE</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">X123</span>   <span class="n">PIC</span> <span class="n">S999</span><span class="mf">.99</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">FILLER</span> <span class="n">PIC</span> <span class="n">X</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">Y1</span>     <span class="n">PIC</span> <span class="n">S999</span><span class="mf">.99</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">FILLER</span> <span class="n">PIC</span> <span class="n">X</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">Y2</span>     <span class="n">PIC</span> <span class="n">S999</span><span class="mf">.99</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">FILLER</span> <span class="n">PIC</span> <span class="n">X</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">Y3</span>     <span class="n">PIC</span> <span class="n">S999</span><span class="mf">.99</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">FILLER</span> <span class="n">PIC</span> <span class="n">X</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">X4</span>     <span class="n">PIC</span> <span class="n">S999</span><span class="mf">.99</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">FILLER</span> <span class="n">PIC</span> <span class="n">X</span><span class="o">.</span>
    <span class="mi">05</span>  <span class="n">Y4</span>     <span class="n">PIC</span> <span class="n">S999</span><span class="mf">.99</span><span class="o">.</span>
</pre></div>
</div>
<p>The attributes all use a “USAGE DISPLAY” format, which makes them string values.
Any conversion to a number becomes part of the application processing.
This is a consequence of sticking closely to COBOL semantics for the the data definitions.</p>
</section>
<section id="schema-in-the-application">
<h3>Schema In the Application<a class="headerlink" href="#schema-in-the-application" title="Link to this heading">¶</a></h3>
<p>A Schema can be built within the application, also. This can be done using <strong>Stingray</strong>‘s internal data structures.
However, it seems simpler to use JSON Schema as a starting point,
and build the internal structure from the JSON Schema document.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">stingray</span> <span class="kn">import</span> <span class="n">open_workbook</span><span class="p">,</span> <span class="n">ExternalSchemaLoader</span><span class="p">,</span> <span class="n">Row</span><span class="p">,</span> <span class="n">SchemaMaker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">os</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterable</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">process_rows</span><span class="p">(</span><span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Row</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
<span class="gp">... </span>        <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;x123&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span> <span class="n">row</span><span class="o">.</span><span class="n">name</span><span class="p">(</span><span class="s2">&quot;y1&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
</pre></div>
</div>
<ol class="arabic">
<li><p>Load a literal schema</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">json_schema</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;spike/Anscombe_quartet_data.csv&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Four series, use (x123, y1), (x123, y2), (x123, y3) or (x4, y4)&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;object&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="s2">&quot;properties&quot;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">... </span>        <span class="s2">&quot;x123&quot;</span><span class="p">:</span> <span class="p">{</span>
<span class="gp">... </span>            <span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;x123&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span>
<span class="gp">... </span>            <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;X values for series 1, 2, and 3.&quot;</span><span class="p">,</span>
<span class="gp">... </span>        <span class="p">},</span>
<span class="gp">... </span>        <span class="s2">&quot;y1&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;y1&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Y value for series 1.&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="s2">&quot;y2&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;y2&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Y value for series 2.&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="s2">&quot;y3&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;y3&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Y value for series 3.&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="s2">&quot;x4&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;x4&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;X value for series 4.&quot;</span><span class="p">},</span>
<span class="gp">... </span>        <span class="s2">&quot;y4&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;title&quot;</span><span class="p">:</span> <span class="s2">&quot;y4&quot;</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Y value for series 4.&quot;</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">},</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">schema</span> <span class="o">=</span> <span class="n">SchemaMaker</span><span class="p">()</span><span class="o">.</span><span class="n">from_json</span><span class="p">(</span><span class="n">json_schema</span><span class="p">)</span>
</pre></div>
</div>
</li>
<li><p>Process the rows using the schema</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SAMPLES&quot;</span><span class="p">,</span> <span class="s2">&quot;sample&quot;</span><span class="p">))</span> <span class="o">/</span> <span class="s2">&quot;Anscombe_quartet_data.csv&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">with</span> <span class="n">open_workbook</span><span class="p">(</span><span class="n">data_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">workbook</span><span class="p">:</span>
<span class="gp">... </span>    <span class="n">sheet</span> <span class="o">=</span> <span class="n">workbook</span><span class="o">.</span><span class="n">sheet</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">set_schema</span><span class="p">(</span><span class="n">schema</span><span class="p">)</span>
<span class="gp">... </span>    <span class="n">process_rows</span><span class="p">(</span><span class="n">sheet</span><span class="o">.</span><span class="n">rows</span><span class="p">())</span>
<span class="go">x123 y1</span>
<span class="go">10.0 8.04</span>
<span class="go">8.0 6.95</span>
<span class="go">13.0 7.58</span>
<span class="go">9.0 8.81</span>
<span class="go">11.0 8.33</span>
<span class="go">14.0 9.96</span>
<span class="go">6.0 7.24</span>
<span class="go">4.0 4.26</span>
<span class="go">12.0 10.84</span>
<span class="go">7.0 4.82</span>
<span class="go">5.0 5.68</span>
</pre></div>
</div>
</li>
</ol>
<p>The JSON Schema description is relatively clear, and easy to write as a Python dictionary literal.
This representation can be shared widely among multiple applications.
This could be part of an OpenAPI specification, for example, shared by a RESTful web server with the client applications.</p>
</section>
</section>
<section id="rows-and-navigation">
<h2>Rows and Navigation<a class="headerlink" href="#rows-and-navigation" title="Link to this heading">¶</a></h2>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> is a binding between an instance of raw data from the underlying
COBOL file or workbook structure, and a schema.</p>
<p>Most workbook rows are a flat sequence of named columns.
The JSON Schema definition is an “object”; each column is a property.
For COBOL, a simple list of columns isn’t appropriate.
For delimited files (i.e., NDJSON, YAML, or TOML) a flat list of names isn’t appropriate, either.</p>
<p>To unify all of these, a <code class="xref py py-class docutils literal notranslate"><span class="pre">Row</span></code> object uses a navigation aid.
These are <code class="xref py py-class docutils literal notranslate"><span class="pre">Nav</span></code> instances that are used to locate the proper strings of bytes.</p>
<p>Ordinarily, the <code class="xref py py-class docutils literal notranslate"><span class="pre">Nav</span></code> objects are invisible.
When an application uses an expression like <code class="docutils literal notranslate"><span class="pre">row.name(&quot;name&quot;).value()</span></code>, this will extract a Python object that is the value.
An intermediate <code class="xref py py-class docutils literal notranslate"><span class="pre">Nav</span></code> object will be created, but it is not visible.</p>
<p>A <code class="xref py py-class docutils literal notranslate"><span class="pre">Nav</span></code> object can be visible when we omit the <code class="xref py py-class docutils literal notranslate"><span class="pre">Nav.value</span></code> method.
This extracts the final Python object from the cell.
It may be useful to cache <code class="xref py py-class docutils literal notranslate"><span class="pre">Nav</span></code> objects to improve performance.</p>
<p>Here’s the relationship:</p>
<p class="plantuml">
<img src="_images/plantuml-cf9d9e65608b2f4ddde9288080e8b74a01213901.png" alt="&#64;startuml

class Row

abstract class Nav {
    name(): Nav
    index(): Nav
    value(): Any
}

abstract class Instance
class Schema

Row --&gt; Instance : &quot;gets data&quot;
Row ..&gt; Schema : &quot;defined by&quot;
Row --&gt; Nav : &quot;creates&quot;
Nav --&gt; Nav : &quot;creates&quot;

class PythonObject

Nav::value --&gt; PythonObject

&#64;enduml"/>
</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Instance</span></code> is a union of the various kinds of instance extraction protocols: <code class="xref py py-class docutils literal notranslate"><span class="pre">NDInstance</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">DInstance</span></code>, and <code class="xref py py-class docutils literal notranslate"><span class="pre">WBInstance</span></code>.
These handle the non-delimited files (i.e. COBOL, and similar), delimited files, and spreadsheet workbooks.
An <code class="docutils literal notranslate"><span class="pre">Instance</span></code> has methods to get items by name or by column number from the underlying file or workbook.</p>
<p>The fluent interface of a <code class="xref py py-class docutils literal notranslate"><span class="pre">Nav</span></code> will create additional
<code class="xref py py-class docutils literal notranslate"><span class="pre">Nav</span></code> navigation helpers to work down into a complex structure.
This is particularl important for COBOL.</p>
<p>Generally, COBOL programs assume all field names are unique. (They don’t have to be, but this is rare.)
To make this work out well, Stringray leverages JSON Schema <code class="docutils literal notranslate"><span class="pre">$anchor</span></code> keywords to
avoid complex path-based navigation into an object. Using anchor names allows
a <code class="xref py py-meth docutils literal notranslate"><span class="pre">Nav.name()</span></code> method to locate a field deeply nested inside a complex COBOL record.
The parallels the way the COBOL language works.</p>
</section>
<section id="application-design-considerations">
<h2>Application Design Considerations<a class="headerlink" href="#application-design-considerations" title="Link to this heading">¶</a></h2>
<p>We’ll cover several more examples of schema-based processing.
It’s important to design an application around data quality and software quality considerations.</p>
<p>More examples are in the demonstration applications shown in the <a class="reference internal" href="demo/index.html#demo"><span class="std std-ref">Demo Applications</span></a> section.</p>
<p>All schemae start as JSON Schema documents. These are Python <code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">Any]</span></code> structures.
A <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.workbook.SchemaMaker</span></code> object is used to transform the JSON Schema document into a usable <a class="reference internal" href="apidoc/modules/stingray.schema_instance.html#stingray.schema_instance.Schema" title="stingray.schema_instance.Schema"><code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.schema_instance.Schema</span></code></a> object.
This permits pre-processing the schema to add features or correct problems.</p>
<p>This use of JSON Schema assures that schema can be loaded from a wide variety of sources and are compatible with a wide variety of other software tools.</p>
<section id="data-capture-and-builder-functions">
<h3>Data Capture and Builder Functions<a class="headerlink" href="#data-capture-and-builder-functions" title="Link to this heading">¶</a></h3>
<p>There are two parts to data handling: <strong>Capture</strong> and <strong>Conversion</strong>.
Data processing starts with <strong>Capture</strong>.
Using a schema is the heart of solving the semantic problem of capturing data in spreadsheet and COBOL files.
We’ll look at <strong>Capture</strong> in this section, and then <strong>Conversion</strong> in the next section.</p>
<p>We want to have just one application that is adaptable to a number of variant logical layouts.
These must reflect alternative implementations of a single conceptual content.
Ideally, there’s one layout and one schema, but as a practical matter, there are often several similar schemae.</p>
<p>We need to provide three pieces of information for capture:</p>
<ul class="simple">
<li><p>Target variable (or attribute or parameter) used by our application.</p></li>
<li><p>Target data type needed by our application.</p></li>
<li><p>Source navigation based on attribute name or position in the source file.
In the case of COBOL or JSON with deeply nested structures, this navigation can be complex.
In the case of a CSV, it’s a name or column number.</p></li>
</ul>
<p>This triple is essentially a Python assignment statement with <em>target</em>, <em>to_type</em> and <em>source</em>.
A DSL or other encoding is unhelpful.</p>
<p>A simple description is the following:</p>
<pre class="literal-block"><em>target</em> = <em>to_type</em>(row['<em>source</em>'].value())</pre>
<p>There is a tiny bit of boilerplate in this assignment statement.
The overhead of the boilerplate is offset by the flexibility of using Python directly.</p>
<p>We can use either <code class="docutils literal notranslate"><span class="pre">schema.name('source')</span></code> or <code class="docutils literal notranslate"><span class="pre">schema['source']</span></code> as a way to locate a named attribute within a schema.</p>
<p>There are some common cases that will extend or modify the boilerplate.
In particular, COBOL structures that are not in first normal form will include array indexing.
COBOL can have ambiguous names, requiring a navigation path to an atomic value.
Finally, because of the COBOL redefines feature, it helps to do lazy evaluation to compute the value after navgiating to the desired string of bytes.</p>
<p>This is our preferred design pattern: a <strong>Builder Function</strong>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_record_dict</span><span class="p">(</span><span class="n">aRow</span><span class="p">:</span> <span class="n">Row</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;some column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;another column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_5</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">),</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>This function defines the application-specific mapping from a row in a source file.
It leverages logical layout information from the schema definition.</p>
<p>Of course, the schema can lie, and the application can misuse the data.
Those are inevitable (and therefore insoluble) problems.
This is why we must write customized software to handle these data sources.</p>
<p>In the case of variant schemae, we can use something like this.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_record_dict_1</span><span class="p">(</span><span class="n">aRow</span><span class="p">:</span> <span class="n">Row</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;some column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;another column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_5</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()),</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
    <span class="p">)</span>

<span class="k">def</span> <span class="nf">build_record_dict_2</span><span class="p">(</span><span class="n">aRow</span><span class="p">:</span> <span class="n">Row</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;variant column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;something different&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_5</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="s1">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()),</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s1">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>We can then define a handy factory which picks a builder based on the schema version.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_builder</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">namespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Row</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="k">return</span> <span class="nb">eval</span><span class="p">(</span><span class="s1">&#39;build_record_dict_</span><span class="si">{args.layout}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Some people worry that an Evil Super-Genius (ESG) might somehow try to exploit the <code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code> function.
The ESG would have to be both clever and utterly unaware that the source is easily edited Python
People who worry about an ESG that can manipulate the parameters while unable to simply edit the Python can use the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">{</span><span class="s1">&#39;1&#39;</span><span class="p">:</span> <span class="n">build_record_dict_1</span><span class="p">,</span> <span class="s1">&#39;2&#39;</span><span class="p">:</span> <span class="n">build_record_dict_2</span><span class="p">}[</span><span class="n">args</span><span class="o">.</span><span class="n">layout</span><span class="p">]</span>
</pre></div>
</div>
<p>The <code class="xref py py-func docutils literal notranslate"><span class="pre">make_builder()</span></code> function selects one of the available
builders based on a command-line option in the <code class="docutils literal notranslate"><span class="pre">args</span></code> structure.</p>
</section>
<section id="data-conversions">
<h3>Data Conversions<a class="headerlink" href="#data-conversions" title="Link to this heading">¶</a></h3>
<p>There are two parts to data handling: <strong>Capture</strong> and <strong>Conversion</strong>.
Conversion is part of the final application, once the source data has been captured.</p>
<p>A target data conversion can be rather complex.
It can involve involve any combination of filtering, cleansing, conforming to an existing database, or rewriting.</p>
<p>Here’s a much more complex <strong>Builder Function</strong> that includes conversion.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">build_record_3</span><span class="p">(</span><span class="n">aRow</span><span class="p">:</span> <span class="n">Row</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">aRow</span><span class="p">[</span><span class="s1">&#39;flag&#39;</span><span class="p">]:</span>
        <span class="k">return</span> <span class="p">{}</span>
    <span class="n">zip_str</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s1">&#39;zip&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">&#39;-&#39;</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">:</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_9</span><span class="p">(</span><span class="n">zip_str</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">zip</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_5</span><span class="p">(</span><span class="n">zip_str</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">zip</span> <span class="o">=</span> <span class="n">digits_9</span><span class="p">(</span><span class="n">zip_str</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s1">&#39;variant column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="n">address</span> <span class="o">=</span> <span class="n">arow</span><span class="p">[</span><span class="s1">&#39;different column&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
        <span class="nb">zip</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">,</span>
        <span class="n">phone</span> <span class="o">=</span> <span class="n">aRow</span><span class="p">[</span><span class="s1">&#39;phone&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span>
    <span class="p">)</span>
</pre></div>
</div>
<p>This shows filtering and cleansing operations.
Yes, it’s complex.
Indeed, it’s complex enough that attempting to define a domain-specific language will lead to more problems than simply using Python for this.</p>
</section>
</section>
<section id="stingray-application-design">
<h2><strong>Stingray</strong> Application Design<a class="headerlink" href="#stingray-application-design" title="Link to this heading">¶</a></h2>
<p>A application need to consider two tiers of testing.
Conventional unit testing makes sure the application’s processing is valid.
Beyond that, data quality testing ensures that the data itself is valid.</p>
<p>Data quality testing is facilitated by some specific design patterns for the application as a whole.</p>
<p>For application unit testing, our programs should be decomposed into three tiers of processing.</p>
<ul class="simple">
<li><p><strong>Row-Level</strong>.  Inidividual Python objects built from one row of the input.
This involves our builder functions.</p></li>
<li><p><strong>Sheet-Level</strong>.  Collections of Python objects built from all rows of a sheet.
This involves sheet processing functions. Mocked row-level functions should be used.</p></li>
<li><p><strong>Workbook-Level</strong>.  In some cases, we may need to work with a collection of sheets.
If required, these tests will need mocked sheet and row functions.</p></li>
</ul>
<p>Each of these tiers should be tested independently.</p>
<p>For data quality testing, we need to validate that the the input files meet the expected schema.
This can use the unit testing framework.
However, it’s often more helpful to design application software to work in a “dry-run” or “validation” mode.
This operating mode can check the data without make persistent state changes to other files or databases.</p>
<section id="row-level-processing">
<h3>Row-Level Processing<a class="headerlink" href="#row-level-processing" title="Link to this heading">¶</a></h3>
<p>Row-level processing is centered on the builder functions.
These handle the detailed mapping from variant logical layouts to a single conceptual schema.</p>
<p>A builder function can create a simple dictionary.
Note that there are two separate steps:</p>
<ul class="simple">
<li><p>Preparing data for a candidate object.
A <code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">Any]</span></code> has data values.
There may be a number of different builder functions for this.</p></li>
<li><p>Building an application object from candidate data.
These objects are often a <code class="xref py py-class docutils literal notranslate"><span class="pre">typing.NamedTuple</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">dataclasses.dataclass</span></code>.
These should not vary with the logical layout.</p></li>
</ul>
<p>This design echoes the design patterns from the <strong>Django</strong> project, where a <code class="docutils literal notranslate"><span class="pre">ModelForm</span></code>
is used to validate data before attempting to build a <code class="docutils literal notranslate"><span class="pre">Model</span></code> instance.</p>
<p>An alternative is to follow the design patterns of the <strong>Pydantic</strong> project, where validation is bundled into the class definition.
Using <code class="docutils literal notranslate"><span class="pre">pydantic</span></code> data class definitions can slightly simplify these examples by bundling validation into the model class.</p>
<p>Validation within the class <code class="docutils literal notranslate"><span class="pre">__init__()</span></code> method, while possible, is often awkwardly complex.
There are two separate things bound together: validating and initialization.
While these can be separated into methods used by <code class="docutils literal notranslate"><span class="pre">__init__()</span></code>, each change to a logical layout becomes yet another subclass.
In this case, composition seems more flexible than inheritance.</p>
<p>One additional reason for decomposing the building from the application object construction is to support multiprocessing pipelines.
It’s often quicker to serialize a Python object built as <code class="docutils literal notranslate"><span class="pre">dict[str,</span> <span class="pre">Any]</span></code> than to serialize an instance of a new class.</p>
<p>Here’s the three-part operation: <strong>Build, Validate, and Construct</strong>.</p>
<pre class="literal-block">def builder_1(row: Row) -&gt; dict[str, Any]:
    return dict(
        <em>key</em> = row['field'].vaue(),
    )

def is_valid(row_dict: dict[str, Any]) -&gt; bool:
    <em>All present or accounted for?</em>
    return <em>state</em>

def construct_object(row_dict: dict[str, Any]) -&gt; App_Object:
    return App_Object(**row_dict)</pre>
<p>The validation rules rarely change. The object construction doesn’t always
need to be a separate function, it can often be a simple class name, or a
classmethod of the class.</p>
<p>Our sheet processing can include a function like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">builder</span> <span class="o">=</span> <span class="n">make_builder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">sheet</span><span class="p">:</span>
    <span class="n">intermediate</span> <span class="o">=</span> <span class="n">builder</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_valid</span><span class="p">(</span><span class="n">intermediate</span><span class="p">):</span>
        <span class="k">yield</span> <span class="n">construct_object</span><span class="p">(</span><span class="n">intermediate</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">builder()</span></code> function allows processing to vary with the file’s actual schema.
We need to pick the builder based on a “logical layout” command-line option.
Something like the following is used to make an application
flexible with respect to layout.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">make_builder</span><span class="p">(</span><span class="n">args</span><span class="p">:</span> <span class="n">argparse</span><span class="o">.</span><span class="n">Namespace</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Row</span><span class="p">],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">layout</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">builder_1</span>
    <span class="k">elif</span> <span class="n">args</span><span class="o">.</span><span class="n">layout</span> <span class="o">==</span> <span class="s2">&quot;2&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">builder_2</span>
    <span class="k">else</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;unknown layout value: </span><span class="si">{</span><span class="n">args</span><span class="o">.</span><span class="n">layout</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The builders are tested individually.
They are subject to considerable change.
New builders are created frequently.</p>
<p>The validation should be common to all logical layouts.
It’s not subject to much variation.
The validation and object construction doesn’t have the change velocity that builders have.</p>
<p>Now that we can process individual rows, we need to provide a way to process the collection of rows in a single sheet.</p>
</section>
<section id="sheet-level-processing">
<h3>Sheet-Level Processing<a class="headerlink" href="#sheet-level-processing" title="Link to this heading">¶</a></h3>
<p>For the most part, sheets are  rows of a single logcal type.
In exceptional cases, a sheet may have multiple types coincedentally bound into a single sheet.
We’ll return to the multiple-types-per-sheet issue below.</p>
<p>For the single-type-per-sheet, we have a processing function like the following:</p>
<pre class="literal-block">def process_sheet(sheet: Sheet, builder: Builder = builder_1) -&gt; Counter:
    counts = Counter()
    object_iter = (
        builder(row)
        for row in sheet.row_iter()
    )
    for source in object_iter:
        counts['read'] += 1
        if is_valid(source):
            counts['valid'] += 1
            # <em>The real processing</em>
            obj = make_app_object(source)
            obj.save()
        else:
            counts['invalid'] += 1
    return counts</pre>
<p>This kind of sheet is tested two ways.
First, this can have a unit test with a fixture that provides specific rows based on requirements, edge-cases and other “white-box” considerations.</p>
<p>Second, an integration test can be performed with live data.
The counts can be checked.
This actually tests the file as much as it tests the sheet processing function.</p>
</section>
<section id="workbook-processing">
<h3>Workbook Processing<a class="headerlink" href="#workbook-processing" title="Link to this heading">¶</a></h3>
<p>The overall processing of a given workbook input looks like this.</p>
<pre class="literal-block">def process_workbook(source: Workbook, builder: Builder) -&gt; None:
    for name in source.sheet_iter():
        # <em>Sheet filter?  Or multi-way elif switch?</em>
        sheet = source.sheet(name).set_schema_loader(HeadingRowSchemaLoader)
        counts = process_sheet(sheet, builder)
        pprint.pprint(counts)</pre>
<p>This makes two claims about the workbook.</p>
<ul class="simple">
<li><p>All sheets in the workbook have the same schema rules.
In this example, it’s an embedded schema in each sheet and the schema is the heading row.</p></li>
<li><p>A single <code class="xref py py-func docutils literal notranslate"><span class="pre">process_sheet()</span></code> function is appropriate for all sheets.</p></li>
</ul>
<p>If a workbook doesn’t meet these criteria, then a (potentially) more complex workbook processing function is needed.
A sheet filter is usually necessary.</p>
<p>Sheet name filtering is also subject to the kind of change that builders are subject to.
Each variant logical layout may also have a variation in sheet names.
It helps to separate the sheet filter functions in the same way builders are separated.
New functions are added with remarkable regularity</p>
<pre class="literal-block">def sheet_filter_1(name: str):
    return re.match(r'<em>pattern</em>', name)</pre>
<p>Or, perhaps something like this that uses a shell file-name pattern instead of a more sophisticated regular expression.</p>
<pre class="literal-block">def sheet_filter_2(name: str):
    return fnmatch.fnmatch(name, '<em>pattern</em>')</pre>
</section>
<section id="command-line-interface">
<h3>Command-Line Interface<a class="headerlink" href="#command-line-interface" title="Link to this heading">¶</a></h3>
<p>We should design an application to an optional argument for verbosity.
It should use a positional argument that provides all the files to profile.
The design often looks like the following:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">parse_args</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">()</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-l&#39;</span><span class="p">,</span> <span class="s1">&#39;--layout&#39;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-v&#39;</span><span class="p">,</span> <span class="s1">&#39;--verbose&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;verbosity&#39;</span><span class="p">,</span>
        <span class="n">default</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_const&#39;</span><span class="p">,</span> <span class="n">const</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
</pre></div>
</div>
<p>The overall main program looks something like this.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">stream</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">()</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">verbosity</span><span class="p">)</span>
    <span class="n">builder</span> <span class="o">=</span> <span class="n">make_builder</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">workbook</span><span class="o">.</span><span class="n">open_workbook</span><span class="p">(</span><span class="nb">input</span><span class="p">)</span> <span class="k">as</span> <span class="n">source</span><span class="p">:</span>
                <span class="n">process_workbook</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">builder</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">shutdown</span><span class="p">()</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>
</pre></div>
</div>
<p>This main program switch allows us to test the various functions (<code class="xref py py-func docutils literal notranslate"><span class="pre">process_workbook()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">process_sheet()</span></code>, the builders, etc.) in isolation.</p>
<p>It also allows us to reuse these functions to build larger (and more complete) applications from smaller components.</p>
<p>In <a class="reference internal" href="demo/index.html#demo"><span class="std std-ref">Demo Applications</span></a> we’ll look at two demonstration applications, as well as a unit test.</p>
</section>
</section>
<section id="variant-records-and-cobol-redefines">
<h2>Variant Records and COBOL REDEFINES<a class="headerlink" href="#variant-records-and-cobol-redefines" title="Link to this heading">¶</a></h2>
<p>Ideally, a data source is in “first normal form”: all the rows are a single type of data.
If so, we can apply a <strong>Build, Validate, Construct</strong> sequence simply.</p>
<p>In too many cases, a data source has multiple types of data.
In COBOL files, it’s common to have header records or trailer records which are summaries of the details sandwiched in the middle.</p>
<p>Similarly, a spreadsheet may be populated with summary rows that must be discarded or handled separately.
We might, for example, write the summary to a different destination and use it to confirm that all rows were properly processed.</p>
<p>Because of the COBOL <code class="docutils literal notranslate"><span class="pre">REDEFINES</span></code> clause, we have multiple variants within a schema.
The JSON Schema <code class="docutils literal notranslate"><span class="pre">oneOf</span></code> keyword captures this.
This means that some of the alternatives may not have a valid decoding for the bytes.
This feature mandates lazy evaluation of each
attribute of each row.</p>
<p>We’ll look at a number of techniques for handling variant records.</p>
<section id="trivial-filtering">
<h3>Trivial Filtering<a class="headerlink" href="#trivial-filtering" title="Link to this heading">¶</a></h3>
<p>When loading a schema based on headers in the sheet, the <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.HeadingRowSchemaLoader</span></code> class will be used.
We can extend this loader to reject rows, also.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">stingray.HeadingRowSchemaLoader.body()</span></code> method can do simple filtering.
This is most appropriate for excluding blank rows or summary rows from a spreadsheet.</p>
</section>
<section id="multiple-passes-and-filters">
<h3>Multiple Passes and Filters<a class="headerlink" href="#multiple-passes-and-filters" title="Link to this heading">¶</a></h3>
<p>When we have multiple data types within a single sheet, we can process this data
using the <strong>Multiple Passes and Filters</strong> pattern. Each pass through the data uses different filters to separate the various types of data.</p>
<p>The multiple-pass option looks like this.
Each pass applies a filter and then does the appropriate processing:</p>
<pre class="literal-block">def process_sheet_filter_1(sheet: Sheet):
    counts = Counter()
    for source in sheet.row_iter():
        counts['read'] += 1
        if <em>filter_1(row)</em>:
            intermediate = <em>builder(row)</em>
            counts['filter_1/pass'] += 1
            <em>processing_1(intermediate)</em>
        else:
            counts['filter_1/reject'] += 1
    return counts</pre>
<p>Each filter is a simple boolean function like this.</p>
<pre class="literal-block">def filter_1(source: Rpw) -&gt; bool:
    return <em>some condition</em></pre>
<p>The conditions may be small boolean expressions like <code class="docutils literal notranslate"><span class="pre">source['column'].value()</span> <span class="pre">==</span> <span class="pre">value</span></code>, which means  a lambda object can be used.
It’s generally a good practice to encapsulate them as distinct, named functions.</p>
</section>
<section id="one-pass-and-case">
<h3>One Pass and Case<a class="headerlink" href="#one-pass-and-case" title="Link to this heading">¶</a></h3>
<p>When we have multiple data types within a single sheet,
we can make  single pass over the data, using an <code class="docutils literal notranslate"><span class="pre">if-elif</span></code> chain or a <code class="docutils literal notranslate"><span class="pre">match-case</span></code> statement.
Each type of row is handled separately.</p>
<p>The one-pass option looks like this.
A “switch” function is used to discriminate each kind of row that is found in the sheet.</p>
<pre class="literal-block">def process_sheet_switch(sheet: Sheet) -&gt; Counter:
    counts = Counter(int)
    for row in sheet.row_iter():
        counts['read'] += 1
        if <em>switch_1(row)</em>:
            intermediate_1 = <em>builder_1(row)</em>
            <em>processing_1(intermediate_1)</em>
            counts['switch_1'] += 1
        elif <em>switch_2(row)</em>:
            intermediate_2 = <em>builder_2(row)</em>
            <em>processing_2(intermediate_2)</em>
            counts['switch_2'] += 1
        <em>elif etc.</em>
        else:
            counts['rejected'] += 1
    return counts</pre>
<p>Each switch function is a simple boolean function like this.</p>
<pre class="literal-block">def switch_1(row: Row) -&gt; bool:
    return <em>some condition</em></pre>
<p>The conditions may be trivial: <code class="docutils literal notranslate"><span class="pre">source['column'].value()</span> <span class="pre">==</span> <span class="pre">value</span></code>.</p>
<p>It often makes sense to package switch, builder, and processing into a single class.</p>
<p>We may be able to build a mapping from switch function results to process function.</p>
<p>This allows us to write a sheet processing function like this&gt;</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_sheet_switch</span><span class="p">(</span><span class="n">sheet</span><span class="p">:</span> <span class="n">Sheet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Counter</span><span class="p">:</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sheet</span><span class="o">.</span><span class="n">row_iter</span><span class="p">():</span>
        <span class="n">counts</span><span class="p">[</span><span class="s1">&#39;read&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">choices</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Row</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="p">(</span><span class="n">switch_1</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="n">builder_1</span><span class="p">,</span> <span class="n">processing_1</span><span class="p">),</span>
            <span class="p">(</span><span class="n">switch_2</span><span class="p">(</span><span class="n">row</span><span class="p">),</span> <span class="n">builder_2</span><span class="p">,</span> <span class="n">processing_2</span><span class="p">),</span>
            <span class="o">...</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">switch</span><span class="p">,</span> <span class="n">builder_function</span><span class="p">,</span> <span class="n">processing_function</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">switch</span><span class="p">:</span>
                <span class="n">processed</span> <span class="o">=</span> <span class="n">switch</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">processed</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">intermediate</span> <span class="o">=</span> <span class="n">builder_function</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                <span class="n">processing_function</span><span class="p">(</span><span class="n">intermediate</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">processed</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="s1">&#39;rejected&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counts</span>
</pre></div>
</div>
<p>This can more easily be extended by adding to the <code class="docutils literal notranslate"><span class="pre">choices</span></code> mapping.</p>
</section>
<section id="more-complex-pipelines">
<h3>More complex pipelines<a class="headerlink" href="#more-complex-pipelines" title="Link to this heading">¶</a></h3>
<p>In many cases, we need to inject data quality validation before attempting to build the application object.
If so, that can be added to the mapping.</p>
<p>It can help to define a class to contain the various pieces of the processing.</p>
<pre class="literal-block">class Sequence(abc.ABC):
    &#64;abstractmethod
    def switch(self, row: Row) -&gt; bool: ...
    &#64;abstractmethod
    def builder(self, row: Row) -&gt; dict[str, Any]: ...
    &#64;abstractmethod
    def validate(self, dict[str, Any]:) -&gt; bool: ...
    &#64;abstractmethod
    def process(self, dict[str, Any]) -&gt; None: ...

    def handle(self, row: Row) -&gt; str:
        name = self.__class__.__name__
        if not self.switch(row):
            return f&quot;{name}-reject&quot;
        intermediate = self.builder(row)
        if not valid(intermediate):
            return f&quot;{name}-invalid&quot;
        self.process(intermediate)
        return f&quot;{name}-process&quot;

class Record_Type_1(Sequence):
    def switch(self, row: Row) -&gt; bool:
        return <em>some expression</em>
    def builder(self, row: Row) -&gt; dict[str, Any]: ...
        return {
            <em>name</em> = row[<em>column</em>].value(),
            ...
        }
    def validate(self, intermediate: dict[str, Any]) -&gt; bool:
        return <em>some expression</em>
    def process(self, intermediate: dict[str, Any]) -&gt; None:
        <em>do something</em>

OPTIONS = [Record_Type_1(), Record_Type_2(), ...]</pre>
<p>This serves as the configuration for a number of processing alternatives.
New classes can be added and the <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code> list updated to reflect the current state of the processing.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">process_sheet_switch</span><span class="p">(</span><span class="n">sheet</span><span class="p">:</span> <span class="n">Sheet</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Counter</span><span class="p">:</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">sheet</span><span class="o">.</span><span class="n">row_iter</span><span class="p">():</span>
        <span class="n">counts</span><span class="p">[</span><span class="s1">&#39;read&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">OPTIONS</span><span class="p">:</span>
            <span class="n">outcome</span> <span class="o">=</span> <span class="n">option</span><span class="o">.</span><span class="n">handle</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">outcome</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">counts</span>
</pre></div>
</div>
<p>This generic sheet processing can comfortably handle complex variant row issues.
It permits a single configuration via the <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code> sequence to handle records appropriately.</p>
<p>This design permits the switch conditions to overlap, potentially processing a single row multiple times.
If the conditions do not overlap, then the first
outcome that ends in “-process” would exit the loop.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">option</span> <span class="ow">in</span> <span class="n">OPTIONS</span><span class="p">:</span>
    <span class="n">outcome</span> <span class="o">=</span> <span class="n">option</span><span class="o">.</span><span class="n">handle</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="n">counts</span><span class="p">[</span><span class="n">outcome</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">outcome</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;-process&quot;</span><span class="p">):</span>
        <span class="k">break</span>
</pre></div>
</div>
<p>With this additional feature, the order of the conditions in the <code class="docutils literal notranslate"><span class="pre">OPTIONS</span></code> list becomes relevant.
A general, fall-back <code class="docutils literal notranslate"><span class="pre">switch()</span></code> method condition must be last.</p>
</section>
</section>
<section id="big-data-performance">
<h2>Big Data Performance<a class="headerlink" href="#big-data-performance" title="Link to this heading">¶</a></h2>
<p>We’ve broken appllication processing down into separate steps which work with generic Python data structures.
This permits use of multiprocessing to spread the pipeline into separate processors or cores.</p>
<p>We’ll set aside the initial switch decision-making for a moment and focus on a three step <strong>Build, Vaidate, Process</strong> sequence of operations.
Each stage of of this sequence can be processed concurrently.</p>
<p>The <strong>Build</strong> stage uses a Sheet object’ss <code class="docutils literal notranslate"><span class="pre">row_iter()</span></code> method to gather <code class="docutils literal notranslate"><span class="pre">Row</span></code> objects.
These can be validated and an intermediate object created and placed into a queue for validation.</p>
<p>The <strong>Validate</strong> stage dequeues intermediate objects, performs the validation checks.
Valid objects are placed in a queue for processing.</p>
<p>The <strong>Process</strong> stage dequeues intermediate objects and processes them.
There can be a pool of workers doing this in case the processing is very time-consuming.</p>
<p>This is amenable to <code class="docutils literal notranslate"><span class="pre">asyncio</span></code>, also.
In that case, the final processing would be a threadpool instead of a process pool.
When using <code class="docutils literal notranslate"><span class="pre">ayncio</span></code> it’s critical to avoid updates to shared data structures.
In the rare case when this is required, explicit locking will be required and can stall the async pipeline.</p>
</section>
<section id="file-naming-and-external-schema">
<h2>File Naming and External Schema<a class="headerlink" href="#file-naming-and-external-schema" title="Link to this heading">¶</a></h2>
<p>Some data management discipline is needed be sure that the schema and file match up properly.
Naming conventions and standardized directory structures are <em>essential</em> for working with external schema.</p>
<section id="well-known-formats">
<h3>Well Known Formats<a class="headerlink" href="#well-known-formats" title="Link to this heading">¶</a></h3>
<p>For well-known physical formats (<code class="file docutils literal notranslate"><span class="pre">.csv</span></code>, <code class="file docutils literal notranslate"><span class="pre">.xls</span></code>, <code class="file docutils literal notranslate"><span class="pre">.xlsx</span></code>, <code class="file docutils literal notranslate"><span class="pre">.xlsm</span></code>, <code class="file docutils literal notranslate"><span class="pre">.ods</span></code>,
<code class="file docutils literal notranslate"><span class="pre">.numbers</span></code>) the filename extension describes the physical format.
Additional schema information is required to determine the Logical Layout.</p>
<p>The schema may be loaded from column headers, in which case the binding is handled via an embedded schema loader.
If the  <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.HeadingRowSchemaLoader</span></code> is used, no more information is required.
If an external schema loader is used (perhaps because the headings are not part of the sheet), then we must bind each application to the appropriate external schema for a given file.</p>
<p>When the schema is external, the schema will often require a unique meta-schema.
This means a data file must be associated with a schema file and a schema loader for the schema.</p>
<p>File naming rules don’t often work out for this, and some kind of explicit configuration file may be required.
In some cases, the directory structure can be used to associate data files and schema files and meta-schema.</p>
</section>
<section id="fixed-formats-and-cobol">
<h3>Fixed Formats and COBOL<a class="headerlink" href="#fixed-formats-and-cobol" title="Link to this heading">¶</a></h3>
<p>For fixed-format files, the filename extension does <strong>not</strong> describe the physical layout.
There is not widely-used extension for fixed-format files.
A suffix like <code class="docutils literal notranslate"><span class="pre">.dat</span></code> is uninformative.
Making things slightly sompler, a fixed format schema combines logical layout and physical format into a single description.</p>
<p>For fixed format files, the following conventions help bind a file to its schema.</p>
<ul class="simple">
<li><p>The data file suffix should be the base name of a schema file.
For example, <code class="file docutils literal notranslate"><span class="pre">mydata.someschema</span></code> points to the <code class="file docutils literal notranslate"><span class="pre">someschema.cob</span></code> or
<code class="file docutils literal notranslate"><span class="pre">someschema.json</span></code> schema.</p></li>
<li><p>Schema files must be be either JSON Schema, a COBOL DDE file, or a workbook in a well-known format.
For example
<code class="file docutils literal notranslate"><span class="pre">someschema.cob</span></code> or <code class="file docutils literal notranslate"><span class="pre">someschema.xlsx</span></code>.</p></li>
</ul>
<p><strong>Examples</strong>.  We might see the following file names.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">september_2001</span><span class="o">.</span><span class="n">exchange_1</span>
<span class="n">november_2011</span><span class="o">.</span><span class="n">some_dde_name</span>
<span class="n">october_2011</span><span class="o">.</span><span class="n">some_dde_name</span>
<span class="n">exchange_1</span><span class="o">.</span><span class="n">xls</span>
<span class="n">some_dde_name</span><span class="o">.</span><span class="n">cob</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">september_2001.exchange_1</span></code> file is a fixed format file which requires the <code class="docutils literal notranslate"><span class="pre">exchange_1.xls</span></code> metadata workbook.
The metadata workbook should have an easy-to-understand schema, ideally a heading row.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">november_2011.some_dde_name</span></code> and <code class="docutils literal notranslate"><span class="pre">october_2011.some_dde_name</span></code> files are fixed format files which require the <code class="docutils literal notranslate"><span class="pre">some_dde_name.cob</span></code> metadata.</p>
</section>
<section id="external-schema-workbooks">
<h3>External Schema Workbooks<a class="headerlink" href="#external-schema-workbooks" title="Link to this heading">¶</a></h3>
<p>A workbook with an external schema sheet must adhere to a few conventions to be usable.
These rules form the basis for the <code class="xref py py-class docutils literal notranslate"><span class="pre">stingray.ExternalSchemaLoader</span></code> class.
To change the rules, extend that class.</p>
<p>The metaschema is defined in the class-level <code class="docutils literal notranslate"><span class="pre">META_SCHEMA</span></code> variable.
This is a JSON Schema definition with the following properties:</p>
<ul class="simple">
<li><p>The column names “name”, “description”, “dataType” are used.</p></li>
<li><p>Additional columns are allowed, but will be ignored.</p></li>
<li><p>Type definitions are the JSON Schema values: “string”, “number”, “integer”, and “boolean”.</p></li>
</ul>
<p>For simple column name changes, the <code class="docutils literal notranslate"><span class="pre">META_SCHEMA</span></code> can be replaced.
For more complex changes, the class will need to be extended.</p>
</section>
</section>
<section id="binding-a-schema-to-an-application">
<h2>Binding a Schema to an Application<a class="headerlink" href="#binding-a-schema-to-an-application" title="Link to this heading">¶</a></h2>
<p>We would like to be sure that our application’s expectations for a schema are aligned with the schema actually present.
An application has several ways to bind its schema information.</p>
<ul class="simple">
<li><p><strong>Implicitly</strong>.  The code simply mentions specific columns
(either by name or position).
If the schema definition doesn’t match the code
there will be run-time <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> exceptions.</p></li>
<li><p><strong>Explicitly</strong>. The code has a formal “requires” check to be sure
that the schema provided by the input file actually matches the
schema required by the application.</p></li>
</ul>
<p>The idea of explicit schema  parallels the configuration management issue of module dependency.
A data file can be said to <em>conform to</em> a given schema and an application <em>requires</em> conformance to a given schema.</p>
<p>An explicit check is far from fool proof.
It’s – at best – a minimal confirmation that an expected set of attributes are present.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">valid</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
    <span class="n">req</span> <span class="ow">in</span> <span class="n">schema</span> <span class="k">for</span> <span class="n">req</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;some&#39;</span><span class="p">,</span> <span class="s1">&#39;list&#39;</span><span class="p">,</span> <span class="s1">&#39;of&#39;</span><span class="p">,</span> <span class="s1">&#39;required&#39;</span><span class="p">,</span> <span class="s1">&#39;columns&#39;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This is essential when using a spreadsheets heading row as a schema.</p>
<p>A better approach is to have an expected schema.
We can then compare the schema built by the heading row with the expected schema.
A heading row schema has no data type or conversion information, making it inadequate for most applications.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">valid</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span>
    <span class="n">prop_name</span> <span class="ow">in</span> <span class="n">found_schema</span><span class="o">.</span><span class="n">properties</span> <span class="k">for</span> <span class="n">prop_name</span> <span class="ow">in</span> <span class="n">expected_schema</span><span class="o">.</span><span class="n">properties</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This assures us that the heading row schema found in the file includes the expected schema.
It may have additional columns, which will be ignored.</p>
<p>The more complete check is row-by-row data validation.
This is often necessary.
We’ll turn to data validation below.</p>
</section>
<section id="schema-version-numbering">
<h2>Schema Version Numbering<a class="headerlink" href="#schema-version-numbering" title="Link to this heading">¶</a></h2>
<p>JSON Schema and XSD’s can have version numbers.
This is a very cool.</p>
<p>See <a class="reference external" href="http://www.xfront.com/Versioning.pdf">http://www.xfront.com/Versioning.pdf</a> for detailed discussion of how to represent schema version information.</p>
<p>Databases, however, lack version numbering in the schema.
This leads to potential compatibilty issues between application programs that expect version 3 of the schema and an older database that implements version 2 of the schema.</p>
<p>Our file schema, similarly, don’t have a tidy, unambiguous numbering.</p>
<p>For external schema, we can embed the version in the file names.
We might want to use something like this <code class="docutils literal notranslate"><span class="pre">econometrics_vendor_1.2</span></code>.
This identifies the generic type of data, the source for that file, and the schema version number.</p>
<p>Within a SQL database, we can use the schema name to carry version information.
We could have a <code class="samp docutils literal notranslate"><span class="pre">name_</span><em><span class="pre">version</span></em></code> kind of convention for the database schema objects that contain our tables.
This allows an application to confirm schema compatibility with a trivial SQL query.</p>
<p>For embedded schema in a spreadsheet, however, we have no <em>easy</em> way to provide schema identification
and version numbering.
We’re forced to build an algorithm to examine the actual names in the embedded schema to deduce the version.</p>
<p>This problem with embedded schema leads to using data profiling to reason out what the file is.
This may devolve to a manual examination of the data profiling results to allow a human to determine the schema.
Then, once the schema has been identified, command-line options can be used to bind the schema to file for correct processing.</p>
</section>
<section id="data-handling-special-cases">
<h2>Data Handling Special Cases<a class="headerlink" href="#data-handling-special-cases" title="Link to this heading">¶</a></h2>
<p>We’ll look at a number of special cases for handling bad or unusual data.</p>
<section id="handling-bad-data">
<h3>Handling Bad Data<a class="headerlink" href="#handling-bad-data" title="Link to this heading">¶</a></h3>
<p>For inexplicable reasons, we can wind up with files that are damaged in some way.</p>
<blockquote>
<div><p>“there is a 65-byte “header” at the start of the file, what would be the best
(least hacky) way to skip over the first 65 bytes?”</p>
</div></blockquote>
<p>This is one of the reasons why use both a file name and an open file object as arguments for opening a workbook.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;file_with_junk.some_schema&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="n">path</span><span class="o">.</span><span class="n">open</span><span class="p">(,</span><span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">cobol</span><span class="p">:</span>
    <span class="n">cobol</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">66</span><span class="p">)</span>
    <span class="n">wb</span> <span class="o">=</span> <span class="n">stingray</span><span class="o">.</span><span class="n">COBOL_EBCDIC_File</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">file_object</span><span class="o">=</span><span class="n">cobol</span><span class="p">)</span>
</pre></div>
</div>
<p>This skips past the junk.</p>
</section>
<section id="leading-zeroes-digit-strings-us-zip-codes-social-security-numbers-etc">
<h3>Leading Zeroes Digit Strings – US ZIP Codes, Social Security Numbers, etc.<a class="headerlink" href="#leading-zeroes-digit-strings-us-zip-codes-social-security-numbers-etc" title="Link to this heading">¶</a></h3>
<p>Spreadsheets turn US Zip codes into numbers, and the leading zeroes get lost.
This happens with social security numbers, also.
It’s rare with telephone numbers.
Some part numbers and UUID’s may have leading zeroes that can be lost when a spreadsheet touches the values.</p>
<p>In all cases, these are “digit strings”.
A code that’s essentially a string but the domain of characters for that string is limited to the ten decimal digits.</p>
<p>This also happens with JSON, YAML, and TOML files.
The solution in those cases is to add quotes to force interpretation as a string.
This can’t be done to workbook data.</p>
<p>To handle digit strings, <strong>Stingray</strong> has conversion functions like <code class="docutils literal notranslate"><span class="pre">stingray.digits_5()</span></code> to
turn an integer into a 5-position string with leading zeroes.</p>
</section>
</section>
<section id="currency">
<h2>Currency<a class="headerlink" href="#currency" title="Link to this heading">¶</a></h2>
<p>Spreadsheets turn currency into floating-point numbers.
Any computation can lead to horrible ‘3.9999999997’ numbers instead of ‘4.00’.
This is masked by spreadsheet applications through extremely clever formatting rules that will obscure the underlying complexity of representing currency with floating-point values.</p>
<p>To handle currency politely, <strong>Stingray</strong> has a <code class="docutils literal notranslate"><span class="pre">stingray.decimal_2()</span></code> conversion function to
provide a decimal value rounded to two decimal places. When this is done as early in the processing as possible, currency computations work out nicely.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/Stingray_belon1553_small.png" alt="Logo of Stingray-Reader"/>
            </a></p>
<h1 class="logo"><a href="index.html">Stingray-Reader</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Using <strong>Stingray Reader</strong></a></li>
<li class="toctree-l1"><a class="reference internal" href="design.html">Design Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="background.html">Additional Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="demo/index.html">Demo Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="apidoc/index.html">stingray API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="testing.html">Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">The TODO List</a></li>
<li class="toctree-l1"><a class="reference internal" href="history.html">History</a></li>
<li class="toctree-l1"><a class="reference internal" href="license.html">Commercial Use</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="installation.html" title="previous chapter">Installation</a></li>
      <li>Next: <a href="design.html" title="next chapter">Design Notes</a></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2021, S.Lott.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.0</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
      |
      <a href="_sources/developer.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>