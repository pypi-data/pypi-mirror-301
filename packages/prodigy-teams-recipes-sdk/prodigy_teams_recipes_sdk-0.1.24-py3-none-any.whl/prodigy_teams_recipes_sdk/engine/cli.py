from collections import UserDict
from pathlib import Path
from typing import TYPE_CHECKING, Any, Callable, Dict, List, Optional, cast

import srsly
from pydantic import BaseSettings
from radicli import Arg, ExistingFilePath, PathOrDash, Radicli, get_list_converter

from .. import about
from . import registry
from .preview import serve_preview
from .util import get_app_dir

if TYPE_CHECKING:
    from .recipe import Recipe


LOCAL_OBJECTS_PATH = Path(get_app_dir()) / "objects_map.json"


class ServerSettings(BaseSettings):
    """Settings for starting the local Prodigy server and form UI previews."""

    host: str = "localhost"
    port: int = 9090
    app_url: Optional[str] = None

    class Config:
        env_prefix: str = "PRODIGY_TEAMS_RECIPES_"
        case_sensitive = False


class ObjectsData(BaseSettings):
    """
    Settings to provide an objects map with definitions of assets and
    datasets that match those returned by the cluster and can be used to
    construct objects like Asset, Dataset etc.
    """

    path: Optional[str] = None
    data: Optional[str] = None

    def read(self) -> Dict[str, Dict[str, Dict[str, Any]]]:
        if self.path is not None:
            data = srsly.read_json(self.path)
        elif self.data is not None:
            data = srsly.json_loads(self.data)
        elif LOCAL_OBJECTS_PATH.exists():
            data = srsly.read_json(LOCAL_OBJECTS_PATH)
        else:
            data = {}
        return cast(Dict[str, Dict[str, Dict[str, Any]]], data)

    class Config:
        env_prefix: str = "PRODIGY_TEAMS_RECIPES_OBJECTS_"
        case_sensitive = False


server_settings = ServerSettings()
cli = Radicli(
    prog=about.__prog__,
    help=about.__summary__,
    version=about.__version__,
    fill_defaults=False,
)


@cli.command(
    "create-meta",
    imports=Arg(help="Recipe packages to index", converter=get_list_converter(str)),
    output=Arg("--output", help="Path for output JSON file or '-' for standard output"),
)
def create_meta(imports: List[str], output: PathOrDash = "-"):
    """Produce a meta.json file"""
    reg = registry.get_recipes_registry()
    # Pass the imports as a load path to ensure we index only the recipes
    # belonging to the package we're interested in.
    recipes = reg.get_all(imports)
    metas = []
    for recipe in recipes.values():
        metas.append(recipe.to_json())
    if output == "-":
        print(srsly.json_dumps(metas, indent=2))
    else:
        srsly.write_json(output, metas, indent=2)


@cli.command(
    "preview",
    name=Arg(help="Name of recipe to test"),
    path=Arg(help="File containing the recipe you're developing"),
    host=Arg("--host", help="Host to serve UI preview on"),
    port=Arg("--port", help="Port to serve UI preview on"),
)
def preview(
    name: str,
    path: Optional[ExistingFilePath] = None,
    *,
    host: str = server_settings.host,
    port: int = server_settings.port,
):
    """Preview the UI form generated by a recipe."""
    serve_preview(name, path, host=host, port=port)


@cli.command(
    "create-object",
    name=Arg(help="Name of the object"),
    attributes=Arg(help="JSON-encoded dictionary of attributes"),
)
def create_object(name: str, attributes: str):
    """Add an object record, to use for 'ptr run' recipe invocations.

    On the cluster, you'll often want to use the named pointers to data that are stored
    in the Prodigy Teams server --- for instance, to provide some input data by name,
    rather than a cluster path. For testing, the 'ptr' commands use a json file with
    the objects data instead.
    """
    attributes_dict = srsly.json_loads(attributes)
    if LOCAL_OBJECTS_PATH.exists():
        objects_data = cast(dict, srsly.read_json(LOCAL_OBJECTS_PATH))
    else:
        objects_data = {}
    objects_data[name] = attributes_dict
    LOCAL_OBJECTS_PATH.parent.mkdir(parents=True, exist_ok=True)
    srsly.write_json(LOCAL_OBJECTS_PATH, objects_data)


@cli.command("delete-object", name=Arg(help="Name of the object"))
def delete_object(name: str) -> None:
    """Delete an object record, to use for 'ptr run' recipe invocations. See 'create-object'."""
    objects_data = cast(dict, srsly.read_json(LOCAL_OBJECTS_PATH))
    objects_data.pop(name)
    LOCAL_OBJECTS_PATH.parent.mkdir(parents=True, exist_ok=True)
    srsly.write_json(LOCAL_OBJECTS_PATH, objects_data)


@cli.command(
    "list-objects",
)
def list_objects() -> None:
    """List the local object references (datasets, inputs, models etc) to
    use as arguments for 'ptr run' recipe invocations.

    See 'create-objects'.
    """
    if LOCAL_OBJECTS_PATH.exists():
        objects_data = cast(dict, srsly.read_json(LOCAL_OBJECTS_PATH))
    else:
        objects_data = {}
    print(srsly.json_dumps(objects_data, indent=2))


@cli.command(
    "clear-objects",
)
def clear_objects() -> None:
    """Remove all object records. See 'create-object'"""
    LOCAL_OBJECTS_PATH.parent.mkdir(parents=True, exist_ok=True)
    srsly.write_json(LOCAL_OBJECTS_PATH, {})


@cli.command(
    "import-objects",
)
def import_objects(path: Path):
    """Add a set of objects from a json file. The format should be:

    {
        "cat-pictures": {...},
        "org-patters": {...}
    }

    Each outer key is an arbitrary object name, and the dictionary provides
    its attributes.

    See 'create-object'
    """
    new_objects = cast(dict, srsly.read_json(path))
    if LOCAL_OBJECTS_PATH.exists():
        objects_data = cast(dict, srsly.read_json(LOCAL_OBJECTS_PATH))
    else:
        objects_data = {}
    objects_data.update(new_objects)
    LOCAL_OBJECTS_PATH.parent.mkdir(parents=True, exist_ok=True)
    srsly.write_json(LOCAL_OBJECTS_PATH, objects_data)


def get_run_recipe(recipe: "Recipe") -> Callable:
    """
    Wrapper for running a recipe, parsing arguments received from the CLI
    and starting th Prodigy server if neeed (i.e. if it's an annotation recipe).
    """

    def run_recipe(**kwargs):
        from prodigy.app import server
        from prodigy.core import Controller

        objects_map = ObjectsData().read()
        parsed_args, parsed_kwargs = recipe.parse_plan(kwargs, objects_map)
        output = recipe.func(*parsed_args, **parsed_kwargs)
        if not recipe.is_action:
            controller = Controller.from_components(recipe.name, output)
            controller.config["host"] = server_settings.host
            controller.config["port"] = server_settings.port
            server(controller, controller.config, server_url=server_settings.app_url)

    return run_recipe


class LazyRecipeSubcommands(UserDict):
    """
    Workaround to allow lazy indexing of recipe subcommands. This is passed
    to Radicli as the subcommands dictionary for the "run" command.
    """

    def __init__(self):
        self._initialized = False
        self._data = {}

    @property
    def data(self):
        # TODO: this loads all of the recipe packages, but we only really
        # need the single recipe that was requested if it exists.
        # We can override the __getitem__ and __iter__ separately
        # to be more efficient.
        self._ensure_init()
        return self._data

    @classmethod
    def _make_subcommands(cls, reg: registry.RecipeRegistry) -> Dict[str, "Recipe"]:
        recipe_commands = {}
        for recipe_name, recipe in reg.get_all().items():
            command = recipe.cli
            command.parent = "run"
            command.func = get_run_recipe(recipe)
            recipe_commands[recipe_name] = command
        return recipe_commands

    def _ensure_init(self):
        if not self._initialized:
            reg = registry.get_recipes_registry()
            self._data.update(self._make_subcommands(reg))
            self._initialized = True


cli.subcommands["run"] = LazyRecipeSubcommands()  # type: ignore


def document_cli(cli: Radicli, *, root: Path = Path.cwd()) -> str:
    """Auto-generate Markdown API docs for ptr CLI"""
    title = "Prodigy Teams Recipes development CLI"
    desc = (
        f"This package includes recipes and utilities for developing recipes for "
        f"Prodigy Teams. Using the CLI, you can execute recipes locally and "
        f"preview the UI forms generated for a given recipe in the app. "
        f"To see all available commands or subcommands, you can use the `--help` "
        f"flag, e.g. `{cli.prog} --help`."
    )
    return cli.document(title=title, description=desc, path_root=root)


__all__ = ["cli", "document_cli"]
