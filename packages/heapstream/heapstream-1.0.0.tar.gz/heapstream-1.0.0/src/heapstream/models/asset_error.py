# This file was generated by liblab | https://liblab.com/

from enum import Enum
from typing import List

from .utils.base_model import BaseModel
from .utils.json_map import JsonMap


class AssetErrorType(Enum):
    """An enumeration representing different categories.

    :cvar FETCHHTTPERROR: "fetch_http_error"
    :vartype FETCHHTTPERROR: str
    :cvar INVALIDUPLOAD: "invalid_upload"
    :vartype INVALIDUPLOAD: str
    :cvar EXPIREDUPLOAD: "expired_upload"
    :vartype EXPIREDUPLOAD: str
    :cvar INVALIDAUDIOLANGCODE: "invalid_audio_lang_code"
    :vartype INVALIDAUDIOLANGCODE: str
    """

    FETCHHTTPERROR = "fetch_http_error"
    INVALIDUPLOAD = "invalid_upload"
    EXPIREDUPLOAD = "expired_upload"
    INVALIDAUDIOLANGCODE = "invalid_audio_lang_code"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, AssetErrorType._member_map_.values()))


@JsonMap({"type_": "type"})
class AssetError(BaseModel):
    """AssetError

    :param audio_track_id: ID of the audio track this error is connected to., defaults to None
    :type audio_track_id: int, optional
    :param messages: Error messages with more details.
    :type messages: List[str]
    :param type_: The type of the error.
    :type type_: AssetErrorType
    """

    def __init__(
        self, messages: List[str], type_: AssetErrorType, audio_track_id: int = None
    ):
        """AssetError

        :param audio_track_id: ID of the audio track this error is connected to., defaults to None
        :type audio_track_id: int, optional
        :param messages: Error messages with more details.
        :type messages: List[str]
        :param type_: The type of the error.
        :type type_: AssetErrorType
        """
        if audio_track_id is not None:
            self.audio_track_id = audio_track_id
        self.messages = messages
        self.type_ = self._enum_matching(type_, AssetErrorType.list(), "type_")
