# This file was generated by liblab | https://liblab.com/

from enum import Enum
from typing import List

from .utils.base_model import BaseModel
from .utils.json_map import JsonMap


class UploadMetadataAutoTt(Enum):
    """An enumeration representing different categories.

    :cvar EN: "en"
    :vartype EN: str
    :cvar ES: "es"
    :vartype ES: str
    :cvar IT: "it"
    :vartype IT: str
    :cvar PT: "pt"
    :vartype PT: str
    :cvar DE: "de"
    :vartype DE: str
    :cvar FR: "fr"
    :vartype FR: str
    :cvar KO: "ko"
    :vartype KO: str
    :cvar NL: "nl"
    :vartype NL: str
    :cvar TH: "th"
    :vartype TH: str
    :cvar RU: "ru"
    :vartype RU: str
    :cvar PL: "pl"
    :vartype PL: str
    :cvar JA: "ja"
    :vartype JA: str
    :cvar SV: "sv"
    :vartype SV: str
    :cvar TR: "tr"
    :vartype TR: str
    :cvar CA: "ca"
    :vartype CA: str
    :cvar ID: "id"
    :vartype ID: str
    :cvar UK: "uk"
    :vartype UK: str
    :cvar MS: "ms"
    :vartype MS: str
    :cvar ZH: "zh"
    :vartype ZH: str
    :cvar FI: "fi"
    :vartype FI: str
    :cvar NO: "no"
    :vartype NO: str
    :cvar RO: "ro"
    :vartype RO: str
    """

    EN = "en"
    ES = "es"
    IT = "it"
    PT = "pt"
    DE = "de"
    FR = "fr"
    KO = "ko"
    NL = "nl"
    TH = "th"
    RU = "ru"
    PL = "pl"
    JA = "ja"
    SV = "sv"
    TR = "tr"
    CA = "ca"
    ID = "id"
    UK = "uk"
    MS = "ms"
    ZH = "zh"
    FI = "fi"
    NO = "no"
    RO = "ro"

    def list():
        """Lists all category values.

        :return: A list of all category values.
        :rtype: list
        """
        return list(map(lambda x: x.value, UploadMetadataAutoTt._member_map_.values()))


@JsonMap({})
class UploadMetadata(BaseModel):
    """UploadMetadata

    :param auto_tt: List of language codes to transcribe the video. If set to NULL, will use the project settings., defaults to None
    :type auto_tt: List[UploadMetadataAutoTt], optional
    :param encoding_tier: The encoding tier serves as the factor that dictates the pricing and qualities accessible for the asset. By default, the encoding tier of the project is the one applied., defaults to None
    :type encoding_tier: str, optional
    :param normalize_audio: Whether to normalize the audio tracks of this video., defaults to None
    :type normalize_audio: bool, optional
    :param size: The size of the file in bytes that will be uploaded. Needs to be exact.
    :type size: int
    :param title: Title of the video., defaults to None
    :type title: str, optional
    :param watermark_id: id of watermark to use in this video., defaults to None
    :type watermark_id: int, optional
    """

    def __init__(
        self,
        size: int,
        auto_tt: List[UploadMetadataAutoTt] = None,
        encoding_tier: str = None,
        normalize_audio: bool = None,
        title: str = None,
        watermark_id: int = None,
    ):
        """UploadMetadata

        :param auto_tt: List of language codes to transcribe the video. If set to NULL, will use the project settings., defaults to None
        :type auto_tt: List[UploadMetadataAutoTt], optional
        :param encoding_tier: The encoding tier serves as the factor that dictates the pricing and qualities accessible for the asset. By default, the encoding tier of the project is the one applied., defaults to None
        :type encoding_tier: str, optional
        :param normalize_audio: Whether to normalize the audio tracks of this video., defaults to None
        :type normalize_audio: bool, optional
        :param size: The size of the file in bytes that will be uploaded. Needs to be exact.
        :type size: int
        :param title: Title of the video., defaults to None
        :type title: str, optional
        :param watermark_id: id of watermark to use in this video., defaults to None
        :type watermark_id: int, optional
        """
        if auto_tt is not None:
            self.auto_tt = self._define_list(auto_tt, UploadMetadataAutoTt)
        if encoding_tier is not None:
            self.encoding_tier = encoding_tier
        if normalize_audio is not None:
            self.normalize_audio = normalize_audio
        self.size = self._define_number("size", size, ge=1, le=9223372036854776000)
        if title is not None:
            self.title = title
        if watermark_id is not None:
            self.watermark_id = self._define_number(
                "watermark_id", watermark_id, ge=1, le=9223372036854776000
            )
