import json
from pathlib import Path
from typing import Any

import pytest
from eip712 import EIP712DAppDescriptor

from erc7730.common.pydantic import model_from_json_file_with_includes, model_to_json_str
from erc7730.convert.convert import convert_and_print_errors
from erc7730.convert.convert_eip712_to_erc7730 import EIP712toERC7730Converter
from erc7730.convert.convert_erc7730_input_to_resolved import ERC7730InputToResolved
from erc7730.convert.convert_erc7730_to_eip712 import ERC7730toEIP712Converter
from erc7730.model.display import FieldFormat
from erc7730.model.input.descriptor import InputERC7730Descriptor
from tests.assertions import assert_dict_equals, assert_model_json_equals
from tests.cases import path_id
from tests.dict_utils import del_by_path, is_in_path, map_by_path
from tests.files import ERC7730_EIP712_DESCRIPTORS, LEGACY_EIP712_DESCRIPTORS


def _adapt_and_comapre_erc7730(input: InputERC7730Descriptor, output: InputERC7730Descriptor) -> None:
    input_dict, output_dict = json.loads(model_to_json_str(input)), json.loads(model_to_json_str(output))

    # $schema is not present in EIP-712
    del_by_path(input_dict, "$schema")

    # Addresses may be in EIP-55 format, convert to lower case in input
    def _lowercase_addresses(deployments: list[dict[str, Any]]) -> Any:
        for deployment in deployments:
            if "address" in deployment:
                deployment["address"] = deployment["address"].lower()
        return deployments

    map_by_path(
        input_dict,
        _lowercase_addresses,
        "context",
        "eip712",
        "deployments",
    )

    # chainId and verifyingContract are always generated by the converter
    # even when not explicitly present in the input
    for key in "chainId", "verifyingContract":
        path = "context", "eip712", "domain", key
        if not is_in_path(input_dict, *path):
            del_by_path(output_dict, *path)

    # Some metadata cannot be stored in EIP712, and thus are lost with the roundtrip
    del_by_path(input_dict, "metadata", "info")
    del_by_path(input_dict, "metadata", "token")
    del_by_path(input_dict, "metadata", "token")
    del_by_path(input_dict, "context", "eip712", "domain", "version")

    # Adapt formats objects to match EIP-712 conversion
    def _cleanup_formats(formats: dict[str, Any]) -> Any:
        for _, message in formats.items():
            # Remove ERC-7730 specific fields
            del_by_path(message, "$id")
            del_by_path(message, "required")
            del_by_path(message, "screens")
            if "fields" in message:
                for field in message["fields"]:
                    # Other formats are always converted to RAW
                    if "format" in field and field["format"] not in (
                        FieldFormat.AMOUNT,
                        FieldFormat.TOKEN_AMOUNT,
                        FieldFormat.DATE,
                    ):
                        field["format"] = "raw"

        return formats

    map_by_path(input_dict, _cleanup_formats, "display", "formats")

    assert_dict_equals(input_dict, output_dict)


@pytest.mark.parametrize("input_file", ERC7730_EIP712_DESCRIPTORS, ids=path_id)
def test_roundtrip_from_erc7730(input_file: Path) -> None:
    input_erc7730_descriptor = InputERC7730Descriptor.load(input_file)
    resolved_erc7730_descriptor = convert_and_print_errors(input_erc7730_descriptor, ERC7730InputToResolved())
    assert resolved_erc7730_descriptor is not None
    if isinstance(resolved_erc7730_descriptor, dict):
        pytest.skip("Multiple descriptors tests not supported")
    legacy_eip712_descriptor = convert_and_print_errors(resolved_erc7730_descriptor, ERC7730toEIP712Converter())
    assert legacy_eip712_descriptor is not None
    if isinstance(legacy_eip712_descriptor, dict):
        pytest.skip("Multiple descriptors tests not supported")
    output_erc7730_descriptor = convert_and_print_errors(legacy_eip712_descriptor, EIP712toERC7730Converter())
    assert output_erc7730_descriptor is not None
    if isinstance(output_erc7730_descriptor, dict):
        pytest.skip("Multiple descriptors tests not supported")
    _adapt_and_comapre_erc7730(input_erc7730_descriptor, output_erc7730_descriptor)


@pytest.mark.parametrize("input_file", LEGACY_EIP712_DESCRIPTORS, ids=path_id)
def test_roundtrip_from_legacy_eip712(input_file: Path) -> None:
    input_legacy_eip712_descriptor = model_from_json_file_with_includes(input_file, EIP712DAppDescriptor)
    input_erc7730_descriptor = convert_and_print_errors(input_legacy_eip712_descriptor, EIP712toERC7730Converter())
    assert input_erc7730_descriptor is not None
    if isinstance(input_erc7730_descriptor, dict):
        pytest.skip("Multiple descriptors tests not supported")
    resolved_erc7730_descriptor = convert_and_print_errors(input_erc7730_descriptor, ERC7730InputToResolved())
    assert resolved_erc7730_descriptor is not None
    if isinstance(resolved_erc7730_descriptor, dict):
        pytest.skip("Multiple descriptors tests not supported")
    output_legacy_eip712_descriptor = convert_and_print_errors(resolved_erc7730_descriptor, ERC7730toEIP712Converter())
    assert output_legacy_eip712_descriptor is not None
    if isinstance(output_legacy_eip712_descriptor, dict):
        pytest.skip("Multiple descriptors tests not supported")
    assert_model_json_equals(input_legacy_eip712_descriptor, output_legacy_eip712_descriptor)
