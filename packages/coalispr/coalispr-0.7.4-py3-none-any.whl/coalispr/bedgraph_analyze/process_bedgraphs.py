#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#  process_bedgraphs.py
#  (bedgraph_compare.py)
#
#  Copyright 2020-2024 Rob van Nues <sborg63@disroot.org>
#
#  "Licensed under the EUPL-1.2 or later"
#
#

"""Module to process and compare bedgraph data of small RNA-sequencing samples.

   With RNAi data as an example, bedgraph signals picked up by sequencing
   RNA isolated from strains without RNAi active, that is without a functioning
   Ago1, Rdp1, or Dicer (Dcr1 and Dcr2 both inactivated) are taken as noise.
   The reads in these samples are not specific, based on the finding that no
   siRNAs were detected by gamma-labeling or by Northern blotting of the RNA
   inputs. The noise-data most likely derive from molecules that came along in
   the procedure and need to be treated as background.
   It is to be expected that these background signals will be present in all
   data sets, when these have been obtained by the same method.

   Comparing bedgraph files of collapsed reads in a genome browser shows
   distinctive gaps in RNAi-minus tracks where there are distinctive peaks
   in RNAi-plus tracks. On the basis of this, we programmatically retrieve
   hit-regions by 'subtracting' RNAi-minus bedgraphs from RNAi-plus bedgraphs
   in pandas. All magic to get bedgraph files into Pandas is in functions
   ``coalispr.bedgraph_analyze.process_bedgraphs.bin_bedgraphs()`` and
   ``coalispr.bedgraph_analyze.genom.create_genom_indexes()``.

   Bedgraph values for reads in subsequent intervals defined by **BINSTEP**
   are collected for each strand. All bins where background (RNAi-minus)
   reads are found are emptied (dropped, and set to 0) unless the mean of
   the values for these reads in RNAi-plus samples is much higher.
   The constant **UNSPECLOG10** defines the cutoff for this (10\
   :sup:`UNSPECLOG10`). This threshold can be set, tested and altered.

   Data is stored persistently for reuse. Figures can be created easily.
   The program uses bedgraph values as generated by the STAR aligner.
"""
import sys ; sys.path.insert(0, '..')
import logging
import pandas as pd

from coalispr.bedgraph_analyze.bedgraph_plots import plot_chrset
from coalispr.bedgraph_analyze.collect_bedgraphs import (
    checkset,
    collect_references,
    collect_bedgraphs,
    )
from coalispr.bedgraph_analyze.compare import (
    unspecific,
    specific,
    get_indexes,
    )
from coalispr.bedgraph_analyze.experiment import (
    negative,
    reference,
    )
from coalispr.bedgraph_analyze.genom import (
    chroms,
    chr_test,
    get_genom_indexes,
    )
from coalispr.bedgraph_analyze.references import (
    referencetrack,
    retrieve_merged_reference,
    filtered_referencetrack,
    )
from coalispr.bedgraph_analyze.store import (
    retrieve_merged,
    retrieve_processed_files,
    store_chromosome_data,
    retrieve_merged_unselected,
    )
from coalispr.resources.constant import (
    EXPFILE,
    FILEKEY,
    LOG2BG,
    MINUS,
    PLOTALL, PLOTSPEC, PLOTUNSP, PLUS,
    SPECIFIC,
    UNSPECIFIC, UNSPECLOG10,
    )
from coalispr.resources.utilities import (
    merg,
    thisfunc,
    timer,
    )

# create logger
logger = logging.getLogger(__name__)

# Process data bedgraph files
# ---------------------------
def bin_bedgraphs(framefilename, name):
    """Split bedgraphs in equal bins so that they can be compared to each other.

    For this, split each bedgraph with respect to one and the same bin-sequence;
    Keep a connection between values and experiment: collect readings under the
    short 'name' heading.

    Keep chrs separate because of the way indexing works (need equal lengths for
    multi-indexed, multi-dimensional arrays)

    Parameters
    ----------
    framefilename : str
        Complete name of file with raw bedgraph values (from bam alignment-file)
    name : str
        Short name as header for column with summed bedgraph values

    Returns
    -------
    dict
        Dictionary with as keys chromosome names and as values a dataframe with
        summed bedgraph values and a common genome index for a sample file

    """
    try:
        # give the column with bedgraph values (floats) the short sample name
        # no <NA> or NaN expected here; thus no need for "nullable integers"
        # with dtype = pd.Int64Dtype or "Int64".
        colnames = ['chr','start','end', name]
        dtypes = { 'chr': 'str',
                 'start': 'int',
                   'end': 'int',
                    name: 'float',
                    }
        df = pd.read_csv(framefilename, sep="\t", header=None, names=colnames,
                dtype=dtypes)
        print(f"Processing input file '{framefilename}'")
    except KeyError:
        msg = (f"Cannot process input file '{framefilename}' according to "
               f"descriptor '{name}' (maybe check '{EXPFILE}').")
        logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
        raise SystemExit(msg)
    except FileNotFoundError:
        msg = (f"Cannot load bedgraph file '{framefilename}' using descriptor "
               f"'{name}'.")
        logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
        raise SystemExit(msg)
    except ValueError:
        msg = (f"Reading '{framefilename}' as filename; invalid file "
               f"path:\nMaybe '{FILEKEY}' in '{EXPFILE}' does not match real "
               f"file name for '{name}'?")
        logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
        raise SystemExit(msg)

    # ensure we have positive values to work with
    df[name]=df[name].abs()
    # add 'mid' column; remove 'start' and 'end' used to create it,
    # force integer to use 'mid' as index and omit 'mid' as column.
    col = df.apply(lambda x : int(0.5*(x.start + x.end)), axis=1)
    df = df.assign(mid = col.values).drop(['start', 'end'],
        axis=1).set_index(['mid'], drop=True)

    # create dict of separate chromosomes from chroms() for binning
    chrs = { x: df[ df['chr']==x ]  for x in chroms()}
    # indexes: create intervals that support merging/comparison
    intervals = get_genom_indexes(do_interval=True)
    # create an index to simplify drawing on a linear axis
    left_edge_intervals = get_genom_indexes(do_interval=False)
    # https://github.com/pandas-dev/pandas/issues/37949
    # obtain the added bedgraph values for each bin/interval
    binnedvalues = { x : chrs[x].groupby(
        pd.cut(chrs[x].index, bins=intervals[x])
        ).sum(numeric_only=True, min_count=1) for x in chroms() }
    # combine new index with summed value into a new data frame and reduce size
    # by removing empty rows
    binnedchrs = { x : pd.DataFrame(binnedvalues[x][name], dtype='float',
        index=left_edge_intervals[x]).dropna() for x in chroms() }
    # clear memory:
    del chrs
    del binnedvalues
    return binnedchrs


@timer
def process_graphs(select, tag, saveas='data', force=False):
    """Process bedgraphs and store processed data as pickle files.

    1. Load bedgraph files into dataframes.
    2. Bin bedgraph values (gives a dict of chr:dataframe); slow, so store it:
    3. Reuse and save as pickle for reuse.

    So, only need to run this once.

    Parameters
    ----------
    select : list
        List of samples to process bedgraphs for.
    tag : str
        Flag **TAG** to indicate kind of aligned-reads, **TAGUNCOLL** or
        **TAGCOLL**.
    saveas : str
        Name for storing data, 'data' or 'reference_data'.

    Returns
    -------
    None
        Print message upon completion of function.
    """
    if not select:
        msg = "Please provide a set of bedgraphs to process"
        print(msg)
        logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
        return

    select = [select] if not isinstance(select, list) else select

    notag = True if saveas == 'reference_data' else False

    if not force:
        plus_frames, minus_frames = retrieve_processed_files(saveas, tag=tag,
        notag=notag)
    elif force:
        plus_frames, minus_frames = {}, {}

    todo = _get_todo_list(select, minus_frames.keys())

    if len(todo) == 0:
        return

    # create inputs
    if saveas == 'reference_data':
        bedgraphdict1, bedgraphdict2 = collect_references()
    else:
        bedgraphdict1, bedgraphdict2 = collect_bedgraphs(tag=tag)

    # do the binning; this step takes very long
    for name in todo: #bedgraphdict1.keys():
        msg = f'bin_bedgraphs for {PLUS}-strand {name}'
        print(msg)
        logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
        plus_frames[name] = bin_bedgraphs(bedgraphdict1[name], name)
    for name in todo: #bedgraphdict2.keys():
        msg = f'bin_bedgraphs for {MINUS}-strand {name}'
        print(msg)
        logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
        minus_frames[name] = bin_bedgraphs(bedgraphdict2[name], name)

    store_chromosome_data(saveas, plus_frames, minus_frames, notag=notag,
        tag=tag)


def _get_todo_list(select, datakeys):
    """Check whether time-consuming step has been done before

    Parameters
    ----------
    select : list
        List of samples to process bedgraphs for.

    Returns
    -------
    list
        List of samples (still) to be processed.
    """
    _select = checkset(select)
    todo = []
    # check what needs doing
    try:
        for name in _select:
            if name in datakeys:
                msg = (f"Binned bedgraph-frames available for '{name}'; "
                       "will be skipped.")
            elif name not in datakeys:
                msg = (f"Binned bedgraph-frames are created for '{name}'; "
                        "this will take some time.")
                todo.append(name)
            print(msg)
            logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
    except KeyError:
        todo.extend(_select)

    if len(todo)==0:
        msg = "Nothing left to bin, skip this."
        print(msg)
        logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")

    return todo


@timer
def merge_sets(select, tag, saveasname=None, force=False):
    """For bedgraph comparison merge the data.

    1. merge plus files; merge minus files
    2. this has to be done for each chromosome
    3. store in dictionaries (only for non-overlapping sets to save space)
    4. allow merged sets outwith the major dataset

    Parameters
    ----------
    select : list
        List of samples to process bedgraphs for.
    tag : str
        Flag **TAG** to indicate kind of aligned-reads, **TAGUNCOLL** or
        **TAGCOLL**.
    saveas : str
        Name for storing data, like 'merged'.

    Returns
    -------
    None
        Print message upon completion of function.
    """
    saveasname = 'merged' if not saveasname else saveasname

    _select = checkset(select)
    if not force:
        if saveasname == 'merged':
            mergs1all, mergs2all = retrieve_merged(tag=tag)
        else:
            mergs1all, mergs2all = retrieve_processed_files(name=saveasname,
                tag=tag)
    elif force:
        mergs1all, mergs2all = {}, {}

    todo=[]
    if mergs1all == {}:
        todo.extend(_select)
    else:
        for expname in _select:
            if expname in mergs1all.get(chr_test()).columns:
                msg = f"Data for '{expname}' have already been merged/stored."
            else:
                msg = f"Bedgraph data frames will be merged for {expname}."
                todo.append(expname)
            #print(msg)
            logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
        if len(todo)==0:
            msg = "No data to merge; all done before..."
            #print(msg)
            logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
            return

    msg = f"Loading '{tag}' data to merge for {len(todo)} experiments.."
    print(msg)
    logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
    plus_frames, minus_frames = retrieve_processed_files(name='data', tag=tag)

    try:
        for chrnam in chroms():
            print(f'.. merging chr. {chrnam} ..')
            mergs1={}
            mergs2={}
            if mergs1all == {} or chrnam not in mergs1all.keys():
                mergs1[chrnam] = plus_frames.get(todo[0])[chrnam]
                mergs2[chrnam] = minus_frames.get(todo[0])[chrnam]
                rest=range(1, len(todo))
            else:
                rest=range(0, len(todo))
                mergs1[chrnam] = mergs1all[chrnam]
                mergs2[chrnam] = mergs2all[chrnam]

            for exp in rest:
                mergs1[chrnam] = merg(
                    mergs1[chrnam],
                    plus_frames.get(todo[exp])[chrnam],
                    )
                mergs2[chrnam]= merg(
                    mergs2[chrnam],
                    minus_frames.get(todo[exp])[chrnam],
                    )

            mergs1all[chrnam] = mergs1[chrnam].fillna(0).round(2)
            mergs2all[chrnam] = mergs2[chrnam].fillna(0).round(2)

        store_chromosome_data(saveasname, mergs1all, mergs2all, tag=tag)
    except KeyError as k:
        msg = (f"KeyError {k}, stopping.. \n"
               "Have all files to be merged already been binned?")
        logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
        raise SystemExit(msg)
    except TypeError as e:
        logging.debug(f"{__name__}.{thisfunc()}:\n{e}")
        raise SystemExit(f"Merging not possible because of '{e}'")
    return


# Process reference bedgraph files
# --------------------------------
@timer
def process_reference(tag, minimal=True, force=False):
    """Pickle reference bedgraphs and filter unspecific hits.

    Set 'tee' to True when stored data has to be used directly
    which happens when storing the data in this combined run.

    Parameters
    ----------
    tag : str
        Flag **TAG** to indicate kind of aligned-reads, **TAGUNCOLL** or
        **TAGCOLL**.
    minimal : bool
        Flag defining negative-samples list.

    Returns
    -------
    None
        Print message upon completion of function.
    """
    try:
        refplus_merg, refminus_merg = merge_reference(tag, tee=True, force=False)
        filter_negative_from_reference(tag, refplus_merg, refminus_merg,
            minimal=True)
    except TypeError: # no references found
        pass


def merge_reference(tag, tee=False, force=False):
    """Reference bedgraphs are combined but kept separate from the data.

    Parameters
    ----------
    tag : str
        Flag **TAG** to indicate kind of aligned-reads, **TAGUNCOLL** or
        **TAGCOLL**.
    tee : bool
        Flag defining to return dataframes for immediate use (storing them does
        not allow for this).

    Returns
    -------
    dict, dict
        When tee is **True**, dicts, one for each strand, with dataframes, one
        for each chromosome, with merged data for reference samples. Otherwise,
        when tee is **False**, print message upon completion of function.
    """
    # check whether it has been done before
    refplus, refminus = retrieve_merged_reference()
    if not tee and refplus != {} and refminus != {}:
        msg = "Merged reference dataframes available!"
        print(msg)
        logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
        return
    # collect and bin reference files
    to_do = reference()
    if len(to_do) == 0:
        msg = "No reference bedgraphs files."
        print(msg)
        logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
        return
    process_graphs(to_do, tag=tag, saveas='reference_data', force=force)
    # merge reference files
    mergs1all, mergs2all = {}, {}
    refplus_data, refminus_data = retrieve_processed_files('reference_data',
        tag=None, notag=True)
    for chrnam in chroms():
        mergs1, mergs2 = {}, {}
        mergs1[chrnam] = refplus_data.get(reference()[0])[chrnam]
        mergs2[chrnam] = refminus_data.get(reference()[0])[chrnam]
        for exp in range(1, len(reference())):
            mergs1[chrnam] = merg(
                mergs1[chrnam],
                refplus_data.get(reference()[exp])[chrnam],
                )
            mergs2[chrnam] = merg(
                mergs2[chrnam],
                refminus_data.get(reference()[exp])[chrnam],
                )
        mergs1all[chrnam] = mergs1[chrnam].fillna(0).round(2)
        mergs2all[chrnam] = mergs2[chrnam].fillna(0).round(2)
    store_chromosome_data('reference_merged', mergs1all, mergs2all, tag=tag,
        notag=True)
    if tee:
        return mergs1all, mergs2all


def filter_negative_from_reference(tag, refplus_merg, refminus_merg,
    minimal=True):
    """Split merged references along with specified data; store as pickle files.

    Parameters
    ----------
    tag : str
        Flag **TAG** to indicate kind of aligned-reads, **TAGUNCOLL** or
        **TAGCOLL**.
    refplus_merg, refminus_merg : dict, dict
        Dicts, for **PLUS** and **MINUS** strand, with data of merged
        references.
    minimal : bool
        Flag defining negative-samples list.

    Returns
    -------
    None
        Print message upon completion of function.
    """
    msg = ("Merged references to filter: "
          f"{list(refplus_merg[chr_test()].columns)}")
    print(msg)
    logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
    ref1idx, notref1idx, ref2idx, notref2idx = {}, {}, {}, {}
    ref1, notref1, ref2, notref2 = {}, {}, {}, {}
    # merge references with negative data
    ref1merg, ref2merg, todo = _merge_reference_negative(minimal, tag,
        refplus_merg, refminus_merg)

    for chrnam in chroms():
        # get indices
        ref1idx, notref1idx = get_indexes(ref1merg[chrnam],
            keep = "refs")
        ref2idx, notref2idx = get_indexes(ref2merg[chrnam],
            keep = "refs")
        # split up the merged dataframe and remove data at end
        ref1[chrnam] = ref1merg[chrnam].reindex(ref1idx).dropna(how=
                            'all').fillna(0).drop(todo, axis=1)
        ref2[chrnam] = ref2merg[chrnam].reindex(ref2idx).dropna(how=
                            'all').fillna(0).drop(todo, axis=1)
        notref1[chrnam] = ref1merg[chrnam].reindex(notref1idx).drop(todo,
                            axis=1).dropna(how='all').fillna(0)
        notref2[chrnam] = ref2merg[chrnam].reindex(notref2idx).drop(todo,
                            axis=1).dropna(how='all').fillna(0)

    store_chromosome_data(f"reference_{SPECIFIC.lower()}_{UNSPECLOG10}",
        ref1, ref2, tag)
    store_chromosome_data(f"reference_{UNSPECIFIC.lower()}_{UNSPECLOG10}",
        notref1, notref2, tag)


def _merge_reference_negative(minimal, tag, refplus_merg, refminus_merg):
    """Merge unspecific reads with merged references.

    This, for better comparison to specific reads in analyzed sRNAs.
    With minimal is **True**, only unspecific reads as found in the absence of
    (immunoprecipitated) protein (binding specific sRNAs) are merged.

    Parameters
    ----------
    minimal : bool
        Flag defining negative-samples list.
    tag : str
        Flag **TAG** to indicate kind of aligned-reads, **TAGUNCOLL** or
        **TAGCOLL**.
    refplus_merg, refminus_merg : dict, dict
        Dicts, for **PLUS** and **MINUS** strand, with data of merged
        references.

    Returns
    -------
    dict, dict, list
        Dicts, for **PLUS** and **MINUS** strand, with merged negative data and
        references. Then a list with samples to use as negative data.

    """
    plus_frames, minus_frames = retrieve_processed_files('data', tag=tag)
    mergs1all, mergs2all = {}, {}
    # merge reference with negative; this can be a subset e.g. TESTSAMPLES;
    # check first whether the negatives are in the retrieved data
    todo = list(set(negative(minimal)).intersection(plus_frames.keys() ))
    msg = f"Using {todo} for removing aspecific signals from references"
    print(msg)
    logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
    for chrnam in chroms():
        mergs1, mergs2 = {}, {}
        mergs1[chrnam] = refplus_merg[chrnam]
        mergs2[chrnam] = refminus_merg[chrnam]
        for exp in range(0, len(todo)):
            mergs1[chrnam] = merg(
                mergs1[chrnam],
                plus_frames.get(todo[exp])[chrnam],
                )
            mergs2[chrnam] = merg(
                mergs2[chrnam],
                minus_frames.get(todo[exp])[chrnam],
                )
        mergs1all[chrnam] = mergs1[chrnam].round(2)
        mergs2all[chrnam] = mergs2[chrnam].round(2)
    msg = "Merged reference and negative dataframes"
    logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
    return mergs1all, mergs2all, todo


# Process unselected bedgraph files
# ---------------------------------

#see coalispr.bedgraph_analyze.unselected


# Show coverage comparison
# ------------------------
def show_chr(chrnam, setlist, tag, refs=False, title=PLOTALL,
    unsel=False, dowhat='show', scale=None, lim=None, ridx=None, side=None):
    """Plot all reads for both chromosome strands in one figure.

    These are interactive plots with all signals, i.e. unfiltered reads.

    Parameters
    ----------
    chrnam : str
        Name of chromosome to display bedgraph traces for.
    setlist : list
        List of samples to display traces for.
    setname : str
        Name of displayed sample set; will be part of figure title.
    tag : str
        Flag **TAG** to indicate kind of aligned-reads, **TAGUNCOLL** or
        **TAGCOLL**.
    refs : bool
        Flag to include (when **True**) reference data.
    unsel : bool
        Flag to include (when **True**) unselected data.
    title : str
        First section of figure title, set to **PLOTALL**.
    dowhat : str
        Instruction to 'show' (default), 'save' (as .png), 'savesvg' or 'return'
        the figure.
    scale : str
        Set scale of y-axis to linear or log2
    lim   : int
        Set limit of y-axis
    ridx  : list
        List with boundaries for a region to be shown, if **None**, show whole
        of the chromosome.
    side  : list
        The sidepatcheslist, a list describing groups of samples to be shown
        under separate headings in the side panel.
    """
    explist = checkset(setlist)
    msg = f"Building {len(explist)} plots for {explist}"
    #print(msg)
    logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
    # no selection done yet; no use for unselected reads
    try:
        plus_merg, minus_merg = retrieve_merged(tag)
        df1 = plus_merg.get(chrnam)[explist]
        df2 = minus_merg.get(chrnam)[explist]
        setname = f"{len(df1.columns)}"
        title = f"{title} ({tag})"
        unsel_= None
        if refs:
            ref1, ref2 = referencetrack(chrnam)
            df1 = merg(ref1, plus_merg.get(chrnam)[explist])
            df2 = merg(ref2, minus_merg.get(chrnam)[explist])
        if unsel:
            unsel_ = UNSPECIFIC
            unsel1, unsel2 = retrieve_merged_unselected()
            df1 = merg(unsel1.get(chrnam), df1)
            df2 = merg(unsel2.get(chrnam), df2)

        plot_chrset(chrnam, [df1, df2], setname, refs, unsel_, title, dowhat, scale,
            lim, ridx, side)
    except TypeError as e:
        msg = "No stored data to show, stopping..."
        logging.debug(f"{__name__}.{thisfunc()}:\nType Error '{e}': {msg}")
        raise SystemExit(msg)



def show_specific_chr(chrnam, setlist, tag, refs=False, title=PLOTSPEC,
    unsel=False, dowhat='show', scale=None, lim=None, ridx=None, side=None):
    """Plot specific reads for both chromosome strands in one figure.

    Interactive plots with all specific signals, i.e. filtered reads;
    without signals that overlap with negative-controls.

    Parameters
    ----------
    chrnam : str
        Name of chromosome to display bedgraph traces for.
    setlist : list
        List of samples to display traces for.
    setname : str
        Name of displayed sample set; will be part of figure title.
    tag : str
        Flag **TAG** to indicate kind of aligned-reads, **TAGUNCOLL** or
        **TAGCOLL**.
    refs : bool
        Flag to include (when **True**) reference data.
    title : str
        First section of figure title, set to **PLOTSPEC**.
    dowhat : str
        Instruction to 'show' (default), 'save' (as .png), 'savesvg' or 'return'
        the figure.
    scale : str
        Set scale of y-axis to linear or log2
    lim   : int
        Set limit of y-axis
    ridx  : list
        List with boundaries for a region to be shown, if **None**, show whole
        of the chromosome.
    side  : list
        The sidepatcheslist, a list describing groups of samples to be shown
        under separate headings in the side panel.
    """
    explist=checkset(setlist)
    msg = f"\nBuilding {len(explist)} plots for {explist}\n"
    #print(msg)
    logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
    try:
        df1, df2 = specific(chrnam, tag, explist)
        # ignore columns with only background signals
        df1drop = df1.loc[:,(df1 < 2**LOG2BG).all(axis=0)].columns.to_list()
        df2drop = df2.loc[:,(df2 < 2**LOG2BG).all(axis=0)].columns.to_list()
        # remove 'only background' columns from setlist (incl. legend too)
        dropcols = set(df1drop).intersection(set(df2drop))
        df1 = df1.drop(dropcols, axis =1)
        df2 = df2.drop(dropcols, axis =1)

        setname = f"{len(df1.columns)}" # will be 0 (samples) for empty dataframe
        title = f"{title} ({tag})"

        if refs:
            ref1, ref2 = filtered_referencetrack(chrnam, tag, specific=True)
            df1 = merg(ref1, df1)
            df2 = merg(ref2, df2)

        plot_chrset(chrnam, [df1, df2], setname, refs, None, title, dowhat, scale,
            lim, ridx, side)
    except TypeError as e:
        msg = "No stored data to show, stopping..."
        logging.debug(f"{__name__}.{thisfunc()}:\nType Error '{e}': {msg}")
        raise SystemExit(msg)


def show_unspecific_chr(chrnam, setlist, tag, refs=False, unsel=False,
    title=PLOTUNSP, dowhat='show', scale=None, lim=None, ridx=None, side=None):
    """Plot unspecific reads for both chromosome strands in one figure.

    Interactive plots with all unspecific signals, i.e. negative control data
    and reads that overlap with negative-control signals but do not meet the
    thresholds. This will also contain reference info if that exists.

    Parameters
    ----------
    chrnam : str
        Name of chromosome to display bedgraph traces for.
    setlist : list
        List of samples to display traces for.
    setname : str
        Name of displayed sample set; will be part of figure title.
    tag : str
        Flag **TAG** to indicate kind of aligned-reads, **TAGUNCOLL** or
        **TAGCOLL** .
    refs : bool
        Flag to include (when **True**) reference data.
    unsel : bool
        Flag to include (when **True**) unselected data from negative control
        samples.
    title : str
        First section of figure title, set to **PLOTUNSP**.
    dowhat : str
        Instruction to 'show' (default), 'save' (as .png), 'savesvg' or 'return'
        the figure.
    scale : str
        Set scale of y-axis to linear or log2
    lim   : int
        Set limit of y-axis
    ridx  : list
        List with boundaries for a region to be shown, if **None**, show whole
        of the chromosome.
    side  : list
        The sidepatcheslist, a list describing groups of samples to be shown
        under separate headings in the side panel.
    """
    explist = checkset(setlist)
    msg = f"\nBuilding {len(explist)} plots for {explist}\n"
    #print(msg)
    logging.debug(f"{__name__}.{thisfunc()}:\n{msg}")
    try:
        unsel_ = None
        df1, df2 = unspecific(chrnam, tag, explist)
        setname = f"{len(df1.columns)}"
        title = f"{title} ({tag})"

        if refs:
            ref1, ref2 = filtered_referencetrack(chrnam, tag, specific=False)
            df1 = merg(ref1, df1)
            df2 = merg(ref2, df2)
        if unsel:
            unsel_ = UNSPECIFIC
            unsel1, unsel2 = retrieve_merged_unselected()
            df1 = merg(unsel1.get(chrnam), df1)
            df2 = merg(unsel2.get(chrnam), df2)

        plot_chrset(chrnam, [df1, df2], setname, refs, unsel_, title, dowhat, scale,
            lim, ridx, side)
    except TypeError as e:
        msg = "No stored data to show, stopping..."
        logging.debug(f"{__name__}.{thisfunc()}:\nType Error '{e}': {msg}")
        raise SystemExit(msg)
