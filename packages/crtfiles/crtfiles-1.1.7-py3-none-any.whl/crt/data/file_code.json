{
  "/$$/": "/n",
  "aiogram-bot": {
    "bot/filters/admin.py": "from aiogram.filters import BaseFilter/$$/from aiogram.types import Message/$$//$$/from bot.config import Config/$$//$$//$$/class AdminFilter(BaseFilter):/$$/    is_admin: bool = True/$$//$$/    async def __call__(self, obj: Message, config: Config) -> bool:/$$/        return (obj.from_user.id in config.tg_bot.admin_ids) == self.is_admin",
    "bot/handlers/__init__.py": "#Import all routers and add them to routers_list./$$/from .admin import admin_router/$$/from .echo import echo_router/$$/from .simple_menu import menu_router/$$/from .user import user_router/$$//$$/routers_list = [/$$/    admin_router,/$$/    menu_router,/$$/    user_router,/$$/    echo_router,  # echo_router must be last/$$/]/$$//$$/__all__ = [/$$/    'routers_list',/$$/]/$$/",
    "bot/handlers/admin.py": "from aiogram import Router/$$/from aiogram.filters import CommandStart/$$/from aiogram.types import Message/$$//$$/from bot.filters.admin import AdminFilter/$$//$$/admin_router = Router()/$$/admin_router.message.filter(AdminFilter())/$$//$$//$$/@admin_router.message(CommandStart())/$$/async def admin_start(message: Message):/$$/    await message.reply('Hello, Admin')",
    "bot/handlers/echo.py": "from aiogram import types, Router, F/$$/from aiogram.filters import StateFilter/$$/from aiogram.fsm.context import FSMContext/$$/from aiogram.utils.markdown import hcode/$$//$$/echo_router = Router()/$$//$$//$$/@echo_router.message(F.text, StateFilter(None))/$$/async def bot_echo(message: types.Message):/$$/    text = ['You entered:', message.text]/$$//$$/    await message.answer('/$$/'.join(text))/$$//$$//$$/@echo_router.message(F.text)/$$/async def bot_echo_all(message: types.Message, state: FSMContext):/$$/    state_name = await state.get_state()/$$/    text = [/$$/        f'You {hcode(state_name)}',/$$/        'Message content :',/$$/        hcode(message.text),/$$/    ]/$$/    await message.answer('/$$/'.join(text))",
    "bot/handlers/menu.py": "from aiogram import Router, F/$$/from aiogram.enums import ParseMode/$$/from aiogram.filters import Command/$$/from aiogram.types import Message, CallbackQuery/$$/from aiogram.utils.formatting import as_section, as_key_value, as_marked_list/$$//$$/from bot.keyboards.inline import simple_menu_keyboard, my_orders_keyboard,     OrderCallbackData/$$//$$/menu_router = Router()/$$//$$//$$/@menu_router.message(Command('menu'))/$$/async def show_menu(message: Message):/$$/    await message.answer('Select an item from the menu:', reply_markup=simple_menu_keyboard())/$$//$$//$$/# We can use F.data filter to filter callback queries by data field from CallbackQuery object/$$/@menu_router.callback_query(F.data == 'create_order')/$$/async def create_order(query: CallbackQuery):/$$/    # Firstly, always answer callback query (as Telegram API requires)/$$/    await query.answer()/$$//$$/    # This method will send an answer to the message with the button, that user pressed/$$/    # Here query - is a CallbackQuery object, which contains message: Message object/$$/    await query.message.answer('You have chosen to create an order!')/$$//$$/    # You can also Edit the message with a new text/$$/    # await query.message.edit_text('You have chosen to create an order!')/$$//$$//$$/# Let's create a simple list of orders for demonstration purposes/$$/ORDERS = [/$$/    {'id': 1, 'title': 'Order 1', 'status': 'Executed '},/$$/    {'id': 2, 'title': 'Order 2', 'status': 'Done'},/$$/    {'id': 3, 'title': 'Order 3', 'status': 'Done'},/$$/]/$$//$$//$$/@menu_router.callback_query(F.data == 'my_orders')/$$/async def my_orders(query: CallbackQuery):/$$/    await query.answer()/$$/    await query.message.edit_text('You have selected to view your orders!',/$$/                                  reply_markup=my_orders_keyboard(ORDERS))/$$//$$//$$/# To filter the callback data, that was created with CallbackData factory, you can use .filter() method/$$/@menu_router.callback_query(OrderCallbackData.filter())/$$/async def show_order(query: CallbackQuery, callback_data: OrderCallbackData):/$$/    await query.answer()/$$//$$/    # You can get the data from callback_data object as attributes/$$/    order_id = callback_data.order_id/$$//$$/    # Then you can get the order from your database (here we use a simple list)/$$/    order_info = next(/$$/        (order for order in ORDERS if order['id'] == order_id), None)/$$//$$/    if order_info:/$$/        # Here we use aiogram.utils.formatting to format the text/$$/        # https://docs.aiogram.dev/en/latest/utils/formatting.html/$$/        text = as_section(/$$/            as_key_value('Order #', order_info['id']),/$$/            as_marked_list(/$$/                as_key_value('Product', order_info['title']),/$$/                as_key_value('Status', order_info['status']),/$$/            ),/$$/        )/$$/        # Example:/$$/        # Order #: 2/$$/        # - Product: Order 2/$$/        # - Status: done/$$//$$/        await query.message.edit_text(text.as_html(), parse_mode=ParseMode.HTML)/$$//$$/        # You can also use MarkdownV2:/$$/        # await query.message.edit_text(text.as_markdown(), parse_mode=ParseMode.MARKDOWN_V2)/$$/    else:/$$/        await query.message.edit_text('Order not found!')/$$/",
    "bot/handlers/user.py": "from aiogram import Router/$$/from aiogram.filters import CommandStart/$$/from aiogram.types import Message/$$//$$/user_router = Router()/$$//$$//$$/@user_router.message(CommandStart())/$$/async def user_start(message: Message):/$$/    await message.reply('Greetings, regular user!')",
    "bot/keyboards/inline.py": "from aiogram.filters.callback_data import CallbackData/$$/from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton/$$/from aiogram.utils.keyboard import InlineKeyboardBuilder/$$//$$//$$/# This is a simple keyboard, that contains 2 buttons/$$/def very_simple_keyboard():/$$/    buttons = [/$$/        [/$$/            InlineKeyboardButton(text='📝 Create an order',/$$/                                 callback_data='create_order'),/$$/            InlineKeyboardButton(text='📋 My orders',/$$/                                 callback_data='my_orders'),/$$/        ],/$$/    ]/$$//$$/    keyboard = InlineKeyboardMarkup(/$$/        inline_keyboard=buttons,/$$/    )/$$/    return keyboard/$$//$$//$$/# This is the same keyboard, but created with InlineKeyboardBuilder (preferred way)/$$/def simple_menu_keyboard():/$$/    # First, you should create an InlineKeyboardBuilder object/$$/    keyboard = InlineKeyboardBuilder()/$$//$$/    # You can use keyboard.button() method to add buttons, then enter text and callback_data/$$/    keyboard.button(/$$/        text='📝 Create an order',/$$/        callback_data='create_order'/$$/    )/$$/    keyboard.button(/$$/        text='📋 My orders',/$$/        # In this simple example, we use a string as callback_data/$$/        callback_data='my_orders'/$$/    )/$$//$$/    # If needed you can use keyboard.adjust() method to change the number of buttons per row/$$/    # keyboard.adjust(2)/$$//$$/    # Then you should always call keyboard.as_markup() method to get a valid InlineKeyboardMarkup object/$$/    return keyboard.as_markup()/$$//$$//$$/# For a more advanced usage of callback_data, you can use the CallbackData factory/$$/class OrderCallbackData(CallbackData, prefix='order'):/$$/    order_id: int/$$//$$//$$/def my_orders_keyboard(orders: list):/$$/    # Here we use a list of orders as a parameter (from simple_menu.py)/$$//$$/    keyboard = InlineKeyboardBuilder()/$$/    for order in orders:/$$/        keyboard.button(/$$/            text=f'📝 {order['title']}',/$$/            # Here we use an instance of OrderCallbackData class as callback_data parameter/$$/            # order id is the field in OrderCallbackData class, that we defined above/$$/            callback_data=OrderCallbackData(order_id=order['id'])/$$/        )/$$//$$/    return keyboard.as_markup()",
    "bot/keyboards/reply.py": "",
    "bot/middlewares/config.py": "from typing import Callable, Dict, Any, Awaitable/$$//$$/from aiogram import BaseMiddleware/$$/from aiogram.types import Message/$$//$$//$$/class ConfigMiddleware(BaseMiddleware):/$$/    def __init__(self, config) -> None:/$$/        self.config = config/$$//$$/    async def __call__(/$$/        self,/$$/        handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]],/$$/        event: Message,/$$/        data: Dict[str, Any],/$$/    ) -> Any:/$$/        data['config'] = self.config/$$/        return await handler(event, data)/$$/",
    "bot/middlewares/database.py": "from typing import Callable, Dict, Any, Awaitable/$$//$$/from aiogram import BaseMiddleware/$$/from aiogram.types import Message/$$//$$/from infrastructure.database.repo.requests import RequestsRepo/$$//$$//$$/class DatabaseMiddleware(BaseMiddleware):/$$/    def __init__(self, session_pool) -> None:/$$/        self.session_pool = session_pool/$$//$$/    async def __call__(/$$/        self,/$$/        handler: Callable[[Message, Dict[str, Any]], Awaitable[Any]],/$$/        event: Message,/$$/        data: Dict[str, Any],/$$/    ) -> Any:/$$/        async with self.session_pool() as session:/$$/            repo = RequestsRepo(session)/$$//$$/            user = await repo.users.get_or_create_user(/$$/                event.from_user.id,/$$/                event.from_user.full_name,/$$/                event.from_user.language_code,/$$/                event.from_user.username/$$/            )/$$//$$/            data['session'] = session/$$/            data['repo'] = repo/$$/            data['user'] = user/$$//$$/            result = await handler(event, data)/$$/        return result/$$/",
    "bot/services/broadcaster.py": "import asyncio/$$/import logging/$$/from typing import Union/$$//$$/from aiogram import Bot/$$/from aiogram import exceptions/$$/from aiogram.types import InlineKeyboardMarkup/$$//$$//$$/async def send_message(/$$/    bot: Bot,/$$/    user_id: Union[int, str],/$$/    text: str,/$$/    disable_notification: bool = False,/$$/    reply_markup: InlineKeyboardMarkup = None,/$$/) -> bool:/$$/    '''/$$/    Safe messages sender/$$//$$/    :param bot: Bot instance./$$/    :param user_id: user id. If str - must contain only digits./$$/    :param text: text of the message./$$/    :param disable_notification: disable notification or not./$$/    :param reply_markup: reply markup./$$/    :return: success./$$/    '''/$$/    try:/$$/        await bot.send_message(/$$/            user_id,/$$/            text,/$$/            disable_notification=disable_notification,/$$/            reply_markup=reply_markup,/$$/        )/$$/    except exceptions.TelegramBadRequest as e:/$$/        logging.error('Telegram server says - Bad Request: chat not found')/$$/    except exceptions.TelegramForbiddenError:/$$/        logging.error(f'Target [ID:{user_id}]: got TelegramForbiddenError')/$$/    except exceptions.TelegramRetryAfter as e:/$$/        logging.error(/$$/            f'Target [ID:{user_id}]: Flood limit is exceeded. Sleep {e.retry_after} seconds.'/$$/        )/$$/        await asyncio.sleep(e.retry_after)/$$/        return await send_message(/$$/            bot, user_id, text, disable_notification, reply_markup/$$/        )  # Recursive call/$$/    except exceptions.TelegramAPIError:/$$/        logging.exception(f'Target [ID:{user_id}]: failed')/$$/    else:/$$/        logging.info(f'Target [ID:{user_id}]: success')/$$/        return True/$$/    return False/$$//$$//$$/async def broadcast(/$$/    bot: Bot,/$$/    users: list[Union[str, int]],/$$/    text: str,/$$/    disable_notification: bool = False,/$$/    reply_markup: InlineKeyboardMarkup = None,/$$/) -> int:/$$/    '''/$$/    Simple broadcaster./$$/    :param bot: Bot instance./$$/    :param users: List of users./$$/    :param text: Text of the message./$$/    :param disable_notification: Disable notification or not./$$/    :param reply_markup: Reply markup./$$/    :return: Count of messages./$$/    '''/$$/    count = 0/$$/    try:/$$/        for user_id in users:/$$/            if await send_message(/$$/                bot, user_id, text, disable_notification, reply_markup/$$/            ):/$$/                count += 1/$$/            await asyncio.sleep(/$$/                0.05/$$/            )  # 20 messages per second (Limit: 30 messages per second)/$$/    finally:/$$/        logging.info(f'{count} messages successful sent.')/$$//$$/    return count",
    "bot/config.py": "from dataclasses import dataclass/$$/from typing import Optional/$$//$$/from environs import Env/$$//$$//$$/@dataclass/$$/class DbConfig:/$$/    '''/$$/    Database configuration class./$$/    This class holds the settings for the database, such as host, password, port, etc./$$//$$/    Attributes/$$/    ----------/$$/    host : str/$$/        The host where the database server is located./$$/    password : str/$$/        The password used to authenticate with the database./$$/    user : str/$$/        The username used to authenticate with the database./$$/    database : str/$$/        The name of the database./$$/    port : int/$$/        The port where the database server is listening./$$/    '''/$$//$$/    host: str/$$/    password: str/$$/    user: str/$$/    database: str/$$/    port: int = 5432/$$//$$/    # For SQLAlchemy/$$/    def construct_sqlalchemy_url(self, driver='asyncpg', host=None, port=None) -> str:/$$/        '''/$$/        Constructs and returns a SQLAlchemy URL for this database configuration./$$/        '''/$$/        # TODO: If you're using SQLAlchemy, move the import to the top of the file!/$$/        from sqlalchemy.engine.url import URL/$$//$$/        if not host:/$$/            host = self.host/$$/        if not port:/$$/            port = self.port/$$/        uri = URL.create(/$$/            drivername=f'postgresql+{driver}',/$$/            username=self.user,/$$/            password=self.password,/$$/            host=host,/$$/            port=port,/$$/            database=self.database,/$$/        )/$$/        return uri.render_as_string(hide_password=False)/$$//$$/    @staticmethod/$$/    def from_env(env: Env):/$$/        '''/$$/        Creates the DbConfig object from environment variables./$$/        '''/$$/        host = env.str('DB_HOST')/$$/        password = env.str('POSTGRES_PASSWORD')/$$/        user = env.str('POSTGRES_USER')/$$/        database = env.str('POSTGRES_DB')/$$/        port = env.int('DB_PORT', 5432)/$$/        return DbConfig(/$$/            host=host, password=password, user=user, database=database, port=port/$$/        )/$$//$$//$$/@dataclass/$$/class bot:/$$/    '''/$$/    Creates the bot object from environment variables./$$/    '''/$$//$$/    token: str/$$/    admin_ids: list[int]/$$/    use_redis: bool/$$//$$/    @staticmethod/$$/    def from_env(env: Env):/$$/        '''/$$/        Creates the bot object from environment variables./$$/        '''/$$/        token = env.str('BOT_TOKEN')/$$/        admin_ids = env.list('ADMINS', subcast=int)/$$/        use_redis = env.bool('USE_REDIS')/$$/        return bot(token=token, admin_ids=admin_ids, use_redis=use_redis)/$$//$$//$$/@dataclass/$$/class RedisConfig:/$$/    '''/$$/    Redis configuration class./$$//$$/    Attributes/$$/    ----------/$$/    redis_pass : Optional(str)/$$/        The password used to authenticate with Redis./$$/    redis_port : Optional(int)/$$/        The port where Redis server is listening./$$/    redis_host : Optional(str)/$$/        The host where Redis server is located./$$/    '''/$$//$$/    redis_pass: Optional[str]/$$/    redis_port: Optional[int]/$$/    redis_host: Optional[str]/$$//$$/    def dsn(self) -> str:/$$/        '''/$$/        Constructs and returns a Redis DSN (Data Source Name) for this database configuration./$$/        '''/$$/        if self.redis_pass:/$$/            return f'redis://:{self.redis_pass}@{self.redis_host}:{self.redis_port}/0'/$$/        else:/$$/            return f'redis://{self.redis_host}:{self.redis_port}/0'/$$//$$/    @staticmethod/$$/    def from_env(env: Env):/$$/        '''/$$/        Creates the RedisConfig object from environment variables./$$/        '''/$$/        redis_pass = env.str('REDIS_PASSWORD')/$$/        redis_port = env.int('REDIS_PORT')/$$/        redis_host = env.str('REDIS_HOST')/$$//$$/        return RedisConfig(/$$/            redis_pass=redis_pass, redis_port=redis_port, redis_host=redis_host/$$/        )/$$//$$//$$/@dataclass/$$/class Miscellaneous:/$$/    '''/$$/    Miscellaneous configuration class./$$//$$/    This class holds settings for various other parameters./$$/    It merely serves as a placeholder for settings that are not part of other categories./$$//$$/    Attributes/$$/    ----------/$$/    other_params : str, optional/$$/        A string used to hold other various parameters as required (default is None)./$$/    '''/$$//$$/    other_params: str = None/$$//$$//$$/@dataclass/$$/class Config:/$$/    '''/$$/    The main configuration class that integrates all the other configuration classes./$$//$$/    This class holds the other configuration classes, providing a centralized point of access for all settings./$$//$$/    Attributes/$$/    ----------/$$/    tg_bot : bot/$$/        Holds the settings related to the Telegram Bot./$$/    misc : Miscellaneous/$$/        Holds the values for miscellaneous settings./$$/    db : Optional[DbConfig]/$$/        Holds the settings specific to the database (default is None)./$$/    redis : Optional[RedisConfig]/$$/        Holds the settings specific to Redis (default is None)./$$/    '''/$$//$$/    tg_bot: bot/$$/    misc: Miscellaneous/$$/    db: Optional[DbConfig] = None/$$/    redis: Optional[RedisConfig] = None/$$//$$//$$/def load_config(path: str = None) -> Config:/$$/    '''/$$/    This function takes an optional file path as input and returns a Config object./$$/    :param path: The path of env file from where to load the configuration variables./$$/    It reads environment variables from a .env file if provided, else from the process environment./$$/    :return: Config object with attributes set as per environment variables./$$/    '''/$$//$$/    # Create an Env object./$$/    # The Env object will be used to read environment variables./$$/    env = Env()/$$/    env.read_env(path)/$$//$$/    return Config(/$$/        tg_bot=bot.from_env(env),/$$/        # db=DbConfig.from_env(env),/$$/        # redis=RedisConfig.from_env(env),/$$/        misc=Miscellaneous(),/$$/    )/$$/",
    ".env": "BOT_TOKEN=/$$/ADMINS=/$$/USE_REDIS=False/$$/",
    "bot.py": "import asyncio/$$/import logging/$$//$$/import betterlogging as bl/$$/from aiogram import Bot, Dispatcher/$$/from aiogram.fsm.storage.memory import MemoryStorage/$$/from aiogram.fsm.storage.redis import RedisStorage, DefaultKeyBuilder/$$//$$/from bot.config import load_config, Config/$$/from bot.handlers import routers_list/$$/from bot.middlewares.config import ConfigMiddleware/$$/from bot.services import broadcaster/$$//$$//$$/async def on_startup(bot: Bot, admin_ids: list[int]):/$$/    await broadcaster.broadcast(bot, admin_ids, 'Бот був запущений')/$$//$$//$$/def register_global_middlewares(dp: Dispatcher, config: Config, session_pool=None):/$$/    '''/$$/    Register global middlewares for the given dispatcher./$$/    Global middlewares here are the ones that are applied to all the handlers (you specify the type of update)/$$//$$/    :param dp: The dispatcher instance./$$/    :type dp: Dispatcher/$$/    :param config: The configuration object from the loaded configuration./$$/    :param session_pool: Optional session pool object for the database using SQLAlchemy./$$/    :return: None/$$/    '''/$$/    middleware_types = [/$$/        ConfigMiddleware(config),/$$/        # DatabaseMiddleware(session_pool),/$$/    ]/$$//$$/    for middleware_type in middleware_types:/$$/        dp.message.outer_middleware(middleware_type)/$$/        dp.callback_query.outer_middleware(middleware_type)/$$//$$//$$/def setup_logging():/$$/    '''/$$/    Set up logging configuration for the application./$$//$$/    This method initializes the logging configuration for the application./$$/    It sets the log level to INFO and configures a basic colorized log for/$$/    output. The log format includes the filename, line number, log level,/$$/    timestamp, logger name, and log message./$$//$$/    Returns:/$$/        None/$$//$$/    Example usage:/$$/        setup_logging()/$$/    '''/$$/    log_level = logging.INFO/$$/    bl.basic_colorized_config(level=log_level)/$$//$$/    logging.basicConfig(/$$/        level=logging.INFO,/$$/        format='%(filename)s:%(lineno)d #%(levelname)-8s [%(asctime)s] - %(name)s - %(message)s',/$$/    )/$$/    logger = logging.getLogger(__name__)/$$/    logger.info('Starting bot')/$$//$$//$$/def get_storage(config):/$$/    '''/$$/    Return storage based on the provided configuration./$$//$$/    Args:/$$/        config (Config): The configuration object./$$//$$/    Returns:/$$/        Storage: The storage object based on the configuration./$$//$$/    '''/$$/    if config.tg_bot.use_redis:/$$/        return RedisStorage.from_url(/$$/            config.redis.dsn(),/$$/            key_builder=DefaultKeyBuilder(with_bot_id=True, with_destiny=True),/$$/        )/$$/    else:/$$/        return MemoryStorage()/$$//$$//$$/async def main():/$$/    setup_logging()/$$//$$/    config = load_config('.env')/$$/    storage = get_storage(config)/$$//$$/    bot = Bot(token=config.tg_bot.token, parse_mode='HTML')/$$/    dp = Dispatcher(storage=storage)/$$//$$/    dp.include_routers(*routers_list)/$$//$$/    register_global_middlewares(dp, config)/$$//$$/    await on_startup(bot, config.tg_bot.admin_ids)/$$/    await dp.start_polling(bot)/$$//$$//$$/if __name__ == '__main__':/$$/    try:/$$/        asyncio.run(main())/$$/    except (KeyboardInterrupt, SystemExit):/$$/        logging.error('Бот був вимкнений!')/$$/"
  }
}
