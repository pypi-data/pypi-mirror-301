import{x as U,bj as V,a7 as I,j as w,bf as q,ac as N,ad as k,K as F,bk as L,i as G}from"./three.module-qgqTrDJv.js";import{LineSegmentsGeometry as H}from"./LineSegmentsGeometry-C6S7Ou6q.js";import{LineMaterial as K}from"./LineMaterial-pWfFDf-c.js";const v=new w,j=new w,n=new L,i=new L,x=new L,_=new w,T=new G,r=new q,C=new w,B=new N,z=new k,y=new L;let h,g;function D(u,e,s){return y.set(0,0,-e,1).applyMatrix4(u.projectionMatrix),y.multiplyScalar(1/y.w),y.x=g/s.width,y.y=g/s.height,y.applyMatrix4(u.projectionMatrixInverse),y.multiplyScalar(1/y.w),Math.abs(Math.max(y.x,y.y))}function R(u,e){const s=u.matrixWorld,o=u.geometry,a=o.attributes.instanceStart,c=o.attributes.instanceEnd,l=Math.min(o.instanceCount,a.count);for(let t=0,p=l;t<p;t++){r.start.fromBufferAttribute(a,t),r.end.fromBufferAttribute(c,t),r.applyMatrix4(s);const f=new w,m=new w;h.distanceSqToSegment(r.start,r.end,m,f),m.distanceTo(f)<g*.5&&e.push({point:m,pointOnLine:f,distance:h.origin.distanceTo(m),object:u,face:null,faceIndex:t,uv:null,uv1:null})}}function J(u,e,s){const o=e.projectionMatrix,c=u.material.resolution,l=u.matrixWorld,t=u.geometry,p=t.attributes.instanceStart,f=t.attributes.instanceEnd,m=Math.min(t.instanceCount,p.count),d=-e.near;h.at(1,x),x.w=1,x.applyMatrix4(e.matrixWorldInverse),x.applyMatrix4(o),x.multiplyScalar(1/x.w),x.x*=c.x/2,x.y*=c.y/2,x.z=0,_.copy(x),T.multiplyMatrices(e.matrixWorldInverse,l);for(let M=0,E=m;M<E;M++){if(n.fromBufferAttribute(p,M),i.fromBufferAttribute(f,M),n.w=1,i.w=1,n.applyMatrix4(T),i.applyMatrix4(T),n.z>d&&i.z>d)continue;if(n.z>d){const S=n.z-i.z,b=(n.z-d)/S;n.lerp(i,b)}else if(i.z>d){const S=i.z-n.z,b=(i.z-d)/S;i.lerp(n,b)}n.applyMatrix4(o),i.applyMatrix4(o),n.multiplyScalar(1/n.w),i.multiplyScalar(1/i.w),n.x*=c.x/2,n.y*=c.y/2,i.x*=c.x/2,i.y*=c.y/2,r.start.copy(n),r.start.z=0,r.end.copy(i),r.end.z=0;const W=r.closestPointToPointParameter(_,!0);r.at(W,C);const A=F.lerp(n.z,i.z,W),P=A>=-1&&A<=1,O=_.distanceTo(C)<g*.5;if(P&&O){r.start.fromBufferAttribute(p,M),r.end.fromBufferAttribute(f,M),r.start.applyMatrix4(l),r.end.applyMatrix4(l);const S=new w,b=new w;h.distanceSqToSegment(r.start,r.end,b,S),s.push({point:b,pointOnLine:S,distance:h.origin.distanceTo(b),object:u,face:null,faceIndex:M,uv:null,uv1:null})}}}class $ extends U{constructor(e=new H,s=new K({color:Math.random()*16777215})){super(e,s),this.isLineSegments2=!0,this.type="LineSegments2"}computeLineDistances(){const e=this.geometry,s=e.attributes.instanceStart,o=e.attributes.instanceEnd,a=new Float32Array(2*s.count);for(let l=0,t=0,p=s.count;l<p;l++,t+=2)v.fromBufferAttribute(s,l),j.fromBufferAttribute(o,l),a[t]=t===0?0:a[t-1],a[t+1]=a[t]+v.distanceTo(j);const c=new V(a,2,1);return e.setAttribute("instanceDistanceStart",new I(c,1,0)),e.setAttribute("instanceDistanceEnd",new I(c,1,1)),this}raycast(e,s){const o=this.material.worldUnits,a=e.camera;a===null&&!o&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2 while worldUnits is set to false.');const c=e.params.Line2!==void 0&&e.params.Line2.threshold||0;h=e.ray;const l=this.matrixWorld,t=this.geometry,p=this.material;g=p.linewidth+c,t.boundingSphere===null&&t.computeBoundingSphere(),z.copy(t.boundingSphere).applyMatrix4(l);let f;if(o)f=g*.5;else{const d=Math.max(a.near,z.distanceToPoint(h.origin));f=D(a,d,p.resolution)}if(z.radius+=f,h.intersectsSphere(z)===!1)return;t.boundingBox===null&&t.computeBoundingBox(),B.copy(t.boundingBox).applyMatrix4(l);let m;if(o)m=g*.5;else{const d=Math.max(a.near,B.distanceToPoint(h.origin));m=D(a,d,p.resolution)}B.expandByScalar(m),h.intersectsBox(B)!==!1&&(o?R(this,s):J(this,a,s))}}export{$ as LineSegments2};
//# sourceMappingURL=LineSegments2-dYhy5yD8.js.map
